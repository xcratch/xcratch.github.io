{"version":3,"file":"chunks/preload_https_3A_2F_2Fyokobond_2Egithub_2Eio_2Fxcx-vpen_2Fdist_2FxcxVPen_2Emjs_extension_mjs.70fe3849586c1dfbffb0.js","mappings":";;;;;;;;;;;;;;AAAA;AAsBA;AACA;AAIA;AACA;AACA;AACA;AACA;AAoLA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAOA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAwDA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAyDA;AACA;AACA;AACA;AAWA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAOA;AAQA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAIA;AAGA;AAIA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AASA;AAaA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AAUA;AAIA;AAIA;AACA;AACA;AACA;AAKA;AAGA;AAGA;AAGA;AAGA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAkDA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;AAqCA;AAeA;AASA;AAcA;AAiDA;AAMA;AAUA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AA0CA;AA6BA;AAeA;AACA;AA6BA;AAiEA;AACA;AAsCA;AAqBA;AAGA;AAWA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAiCA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AAQA;AACA;AASA;AACA;AAMA;AAYA;AACA;AAkBA;AACA;AACA;AACA;AACA;AAiEA;AAWA;AAEA;AAgBA;AAaA;AAwBA;AACA;AAKA;AACA;AAOA;AAKA;AAIA;AAQA;AA6DA;AA0DA;AACA;AAaA;AAcA;AAmBA;AA0DA;AAkEA;AAw5IA;AAOA;AAKA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAqCA;AASA;AA0EA;AA2DA;AA6EA;AAOA;AAwBA;AAOA;AASA;AAmBA;AAWA;AAWA;AAUA;AAMA;AAEA;AAWA;AAKA;AAEA;AAiCA;AAkDA;AAKA;AASA;AAwBA;AACA;AAgBA;AACA;AAMA;AACA;AAIA;AACA;AAUA;AACA;AAoBA;AACA;AAMA;AACA;AAsBA;AACA;AAkBA;AACA;AAqCA;AAiCA;AACA;AAoBA;AASA;AA+BA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2IA;AAmEA;AACA;AAsEA;AAWA;AAkBA;AAKA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AASA;AACA;AAkCA;AA0CA;AAGA;AAEA;AACA;AAMA;AAKA;AAgBA;AAsDA;AACA;AAyGA;AACA;AACA;AACA;AAMA;AAw8IA;AAEA;AAsEA;AAcA;AAyBA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAeA;AAGA;AAIA;AAGA;AAMA;AAOA;AAGA;AAEA;AAIA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAqCA;AAgCA;AA4IA;AACA;AASA;AACA;AACA;AAiBA;AACA;AAOA;AAkBA;AACA;AAoCA;AAsCA;AA0UA;AACA;AAOA;AACA;AAIA;AAYA;AAQA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AAkDA;AAqHA;AACA;AACA;AACA;AACA;AAGA;AAGA;AA4CA;AAIA;AACA;AAKA;AA8GA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAeA;AAIA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAaA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AAQA;AACA;AACA;AAiBA;AACA;AAKA;AACA;AAqBA;AACA;AACA;AAkBA;AAkBA;AAIA;AAqCA;AACA;AASA;AAiGA;AAsBA;AAWA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAaA;AA2CA;AACA;AAgIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AASA;AAEA;AAIA;AAUA;AAKA;AAEA;AAMA;AA+FA;AAoCA;AAKA;AAKA;AAUA;AAkCA;AAuFA;AACA;AAIA;AAaA;AACA;AACA;AAMA;AAGA;AA0FA;AACA;AAqbA;AAQA;AAIA;AAOA;AAUA;AAKA;AAeA;AACA;AACA;AACA;AAEA;AA0BA;AAgCA;AAEA;AAIA;AAEA;AAEA;AA2BA;AAEA;AAEA;AAEA;AAIA;AAKA;AAMA;AAOA;AAGA;AAMA;AAoCA;AAoCA;AAIA;AACA;AACA;AASA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAKA;AAKA;AASA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAKA;AAKA;AAIA;AAGA;AAGA;AASA;AAOA;AAKA;AASA;AAUA;AAIA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAKA;AACA;AAMA;AAMA;AA4OA;AAKA;AAeA;AAqBA;AACA;AAWA;AAMA;AAQA;AACA;AACA;AACA;AASA;AACA;AAYA;AACA;AACA;AACA;AACA;AAIA;AAUA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AAGA;AAGA;AAMA;AAWA;AAKA;AACA;AAIA;AAEA;AAMA;AACA;AAsBA;AAGA;AAGA;AAYA;AAGA;AAEA;AAaA;AACA;AACA;AACA;AACA;AACA;AAGA;AAYA;AASA;AACA;AACA;AACA;AACA;AAGA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAiFA;AAGA;AACA;AAIA;AACA;AAGA;AAeA;AACA;AACA;AAGA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAuGA;AAMA;AAqMA;AAyFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0OA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AA4DA;AAEA;AACA;AACA;AACA;AACA;AACA;AA6CA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAQA;AAGA;AAUA;AACA;AAKA;AAGA;AAMA;AAqBA;AA0BA;AAMA;AA2CA;AA8BA;AAIA;AAKA;AAiDA;AA8BA;AAmMA;AAcA;AA2RA;AAkCA;AAYA;AAqDA;AAsBA;AA6DA;AA4MA;AACA;AAgBA;AAOA;AAgBA;AAMA;AAIA;AAWA;AAKA;AAQA;AAIA;AAaA;AAoDA;AAmBA;AAOA;AAwEA;AAsJA;AACA;AAiBA;AACA;AAkBA;AA2KA;AACA;AAiBA;AACA;AACA;AAKA;AACA;AACA;AACA;AAQA;AACA;AA+BA;AAyQA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAuCA;AAkCA;AACA;AAsCA;AAaA;AAyFA;AAkBA;AAsBA;AAMA;AAYA;AAkEA;AAIA;AAkEA;AA0CA;AAaA;AAcA;AAgFA;AAmBA;AAcA;AAuDA;AACA;AAaA;AA0BA;AAYA;AAIA;AAIA;AAUA;AAIA;AAIA;AAWA;AA2FA;AAqBA;AAsDA;AACA;AA2FA;AAMA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAaA;AA2BA;AAKA;AA4BA;AACA;AACA;AAMA;AA0DA;AAQA;AASA;AASA;AAuDA;AA0BA;AAaA;AAUA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAMA;AAWA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AAMA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAOA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAMA;AACA;AACA;AAQA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAaA;AAKA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAYA;AASA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAeA;AASA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AAKA;AAQA;AAQA;AAKA;AA8BA;AAOA;AACA;AAIA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAGA;AAwBA;AAEA;AACA;AAGA;AAEA;AAqBA;AACA;AACA;AACA;AACA;AACA;AA+CA;AACA;AACA;AACA;AAmBA;AACA;AACA;AAaA;AACA;AACA;AAUA;AACA;AACA;AAKA;AACA;AAIA;AAEA;AACA;AACA;AAMA;AACA;AAIA;AACA;AACA;AAKA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAOA;AAGA;AACA;AACA;AAuBA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAOA;AAKA;AASA;AACA;AACA;AAQA;AAQA;AAaA;AACA;AACA;AASA;AACA;AACA;AAGA;AAOA;AAIA;AAGA;AAOA;AAIA;AAEA;AAEA;AAGA;AACA;AAMA;AACA;AACA;AAeA;AACA;AACA;AA0BA;AACA;AACA;AACA;AAMA;AACA;AAGA;AAIA;AAKA;AAEA;AAIA;AAMA;AAGA;AAMA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsCA;AACA;AACA;AACA;AAsBA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0BA;AACA;AACA;AACA;AACA;AACA;AAUA;AAaA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAeA;AAIA;AAIA;AAOA;AAMA;AAmBA;AAQA;AACA;AACA;AACA;AAUA;AAcA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AAUA;AACA;AACA;AAMA;AAEA;AAIA;AACA;AACA;AAOA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8BA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAUA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAMA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAeA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAUA;AAMA;AACA;AACA;AACA;AACA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AAKA;AAIA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BA;AACA;AACA;AACA;AACA;AACA;AAUA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AAgBA;AACA;AAKA;AAsBA;AACA;AACA;AAMA;AAeA;AACA;AACA;AACA;AASA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AAWA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAGA;AACA;AACA;AACA;AAIA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAuBA;AACA;AASA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAaA;AACA;AAOA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AA0CA;AAoBA;AACA;AAGA;AACA;AACA;AACA;AAOA;AACA;AACA;AAGA;AACA;AACA;AAMA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AAYA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AASA;AA4BA;AACA;AAMA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAwBA;AACA;AACA;AAKA;AAIA;AAGA;AAWA;AACA;AACA;AAWA;AAeA;AACA;AACA;AAUA;AACA;AACA;AAmBA;AACA;AACA;AASA;AACA;AAmBA;AACA;AACA;AACA;AAgBA;AACA;AAqBA;AACA;AACA;AAKA;AAeA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AAcA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAsBA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AAKA;AAIA;AAMA;AACA;AACA;AAyBA;AACA;AACA;AACA;AAaA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAWA;AAOA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AAQA;AACA;AACA;AA0BA;AACA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AAgBA;AACA;AACA;AACA;AAUA;AACA;AACA;AASA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAmBA;AACA;AAKA;AAEA;AACA;AAMA;AACA;AAKA;AAEA;AACA;AAMA;AACA;AACA;AAWA;AACA;AACA;AAWA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AAgBA;AAKA;AAkBA;AACA;AACA;AACA;AAMA;AAIA;AAiBA;AACA;AACA;AAQA;AACA;AAgBA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AA4BA;AACA;AAQA;AACA;AAQA;AACA;AACA;AAiCA;AACA;AAuBA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AAuKA;AAWA;AAaA;AAKA;AAOA;AAKA;AAgBA;AACA;AACA;AACA;AAIA;AAIA;AAQA;AAUA;AASA;AAgBA;AAOA;AAqBA;AAGA;AAgBA;AAIA;AACA;AAGA;AAQA;AAEA;AAGA;AAMA;AAGA;AAIA;AAmBA;AAGA;AAKA;AAEA;AAWA;AAwBA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AAQA;AAIA;AAKA;AAIA;AAKA;AASA;AAiCA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAGA;AAMA;AAKA;AAUA;AAUA;AAgBA;AAIA;AAUA;AAkBA;AAKA;AAGA;AAMA;AAOA;AAKA;AAKA;AAeA;AAGA;AAwCA;AAEA;AAMA;AAGA;AAMA;AAYA;AACA;AACA;AA8FA;AAIA;AAaA;AAGA;AAOA;AAOA;AAaA;AAKA;AAGA;AAKA;AAYA;AAGA;AAOA;AAIA;AAQA;AAUA;AAuCA;AAoCA;AAMA;AAKA;AAOA;AAMA;AAQA;AAIA;AACA;AAQA;AAKA;AAYA;AAKA;AASA;AAKA;AAOA;AAIA;AACA;AAQA;AAOA;AAIA;AAKA;AAIA;AACA;AAMA;AAKA;AA8CA;AAaA;AAKA;AAKA;AAKA;AAKA;AACA;AAkBA;AACA;AAQA;AAOA;AACA;AAOA;AAMA;AA+CA;AA6DA;AAMA;AAcA;AAYA;AAgBA;AAUA;AAyBA;AASA;AAOA;AAMA;AAQA;AAIA;AACA;AAOA;AACA;AAIA;AAIA;AAEA;AASA;AAUA;AASA;AASA;AAGA;AAMA;AAGA;AAeA;AAIA;AAQA;AAIA;AAMA;AAIA;AAsBA;AASA;AAMA;AAWA;AAmBA;AAaA;AAqBA;AAOA;AAiBA;AAaA;AAOA;AAoBA;AAOA;AAYA;AAOA;AAIA;AAMA;AAOA;AAGA;AAGA;AACA;AAMA;AAKA;AA4BA;AAaA;AAWA;AAoCA;AAIA;AAQA;AAgBA;AACA;AACA;AAiBA;AAwBA;AAeA;AAeA;AAaA;AA6CA;AAGA;AACA;AAKA;AAMA;AAKA;AACA;AAQA;AAaA;AACA;AAMA;AAKA;AACA;AAIA;AAQA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAMA;AAaA;AACA;AA+DA;AAyCA;AAGA;AAGA;AAKA;AAkBA;AAeA;AAcA;AAOA;AAGA;AAQA;AAIA;AAGA;AAKA;AAMA;AAMA;AAOA;AAEA;AAKA;AAQA;AASA;AAQA;AAWA;AA2CA;AAkBA;AAQA;AAgBA;AAOA;AAEA;AASA;AAKA;AAGA;AAIA;AAIA;AA2BA;AAOA;AAKA;AAoBA;AAWA;AAEA;AAWA;AAaA;AAIA;AAEA;AAKA;AAGA;AAOA;AAYA;AAQA;AAQA;AAuCA;AAGA;AAEA;AAiBA;AAMA;AAGA;AAGA;AAIA;AAKA;AAIA;AAGA;AAIA;AAEA;AAKA;AAIA;AAuBA;AAOA;AAYA;AAOA;AASA;AAIA;AAOA;AAMA;AAGA;AAGA;AAMA;AAoBA;AAOA;AAiBA;AAYA;AAIA;AAKA;AAIA;AAOA;AAOA;AASA;AAMA;AAGA;AAIA;AAOA;AASA;AAOA;AAUA;AAQA;AA0BA;AAOA;AASA;AAeA;AAIA;AAOA;AAUA;AAEA;AAGA;AAIA;AAIA;AAKA;AAIA;AAKA;AAIA;AAOA;AAKA;AACA;AAGA;AAIA;AAGA;AAMA;AAoBA;AAGA;AAIA;AAMA;AAQA;AAOA;AAOA;AAQA;AAOA;AAQA;AAaA;AAOA;AAOA;AAoBA;AAOA;AAUA;AAQA;AAQA;AAQA;AAOA;AAQA;AAOA;AAkBA;AAQA;AAaA;AAYA;AAEA;AAKA;AAGA;AAQA;AAmBA;AAYA;AAMA;AAMA;AAaA;AAMA;AAQA;AAIA;AAMA;AAUA;AAEA;AAiBA;AAKA;AAEA;AAGA;AAKA;AAWA;AAUA;AAKA;AAEA;AAMA;AAMA;AAoCA;AAGA;AA4CA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AAoCA;AAkBA;AAWA;AACA;AAOA;AAwCA;AAmBA;AAOA;AAIA;AAGA;AAOA;AAWA;AAMA;AAYA;AAOA;AAmBA;AAOA;AAIA;AAGA;AAOA;AAUA;AA6BA;AAUA;AAKA;AAUA;AAQA;AAeA;AAmBA;AAeA;AAMA;AAIA;AASA;AAOA;AAIA;AACA;AAIA;AACA;AAGA;AAOA;AAOA;AAQA;AAYA;AAKA;AAYA;AAQA;AAcA;AAKA;AAKA;AAMA;AAkBA;AAOA;AAQA;AAOA;AAmBA;AAYA;AAKA;AACA;AAUA;AAOA;AAaA;AAOA;AAOA;AAIA;AAGA;AAOA;AAYA;AAKA;AAEA;AAKA;AAIA;AAIA;AAWA;AACA;AACA;AACA;AAyBA;AAuBA;AAGA;AASA;AAGA;AA+BA;AACA;AACA;AAwBA;AACA;AACA;AAyBA;AAIA;AAOA;AAyBA;AAGA;AAIA;AAGA;AAmCA;AAiRA;AAMA;AAIA;AAGA;AAIA;AA4BA;AAWA;AAIA;AAIA;AACA;AAIA;AAoBA;AAIA;AAQA;AAoFA;AAKA;AAyGA;AAeA;AACA;AAGA;AAuCA;AAMA;AAaA;AAuBA;AAOA;AAQA;AAQA;AAOA;AAOA;AAOA;AAQA;AAOA;AAOA;AAOA;AAGA;AAGA;AAEA;AAOA;AAKA;AAMA;AAKA;AAKA;AAkBA;AAWA;AAEA;AAYA;AAWA;AAEA;AAYA;AAeA;AAeA;AAOA;AASA;AAOA;AAUA;AAIA;AAIA;AAMA;AAOA;AAIA;AAmBA;AAKA;AAKA;AAMA;AAGA;AAMA;AAOA;AAEA;AAgBA;AACA;AAIA;AAOA;AAIA;AAWA;AAuBA;AAQA;AAaA;AAKA;AA2CA;AAaA;AAQA;AACA;AAEA;AAKA;AAEA;AAqBA;AA0CA;AAYA;AAYA;AAUA;AAgBA;AAOA;AACA;AAEA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAGA;AACA;AAMA;AAGA;AAKA;AACA;AAGA;AAKA;AAKA;AACA;AAIA;AAEA;AAGA;AAQA;AACA;AAaA;AACA;AAIA;AAGA;AAUA;AA8BA;AAGA;AAGA;AAGA;AAMA;AAKA;AAGA;AAKA;AAGA;AAIA;AASA;AAaA;AACA;AACA;AACA;AA6BA;AA+BA;AACA;AACA;AACA;AACA;AAkBA;AAOA;AAKA;AA+BA;AASA;AACA;AACA;AACA;AACA;AAGA;AASA;AAMA;AAgBA;AACA;AACA;AACA;AAkCA;AAOA;AAKA;AAOA;AAGA;AAKA;AAIA;AASA;AACA;AACA;AAIA;AAGA;AAIA;AAKA;AACA;AAQA;AACA;AACA;AACA;AAeA;AAaA;AAIA;AAGA;AAEA;AAGA;AAIA;AAQA;AASA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAIA;AAGA;AAGA;AACA;AAMA;AAIA;AAKA;AAOA;AACA;AAGA;AAeA;AAQA;AA4CA;AAQA;AA2DA;AAGA;AAgCA;AACA;AACA;AACA;AAMA;AACA;AAAA;AASA;AACA;AACA;AAYA;AAUA;AAkBA;AAIA;AAEA;AAGA;AAGA;AAKA;AAGA;AAGA;AAGA;AAsBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAIA;AAQA;AAKA;AAGA;AAMA;AACA;AAaA;AAIA;AAUA;AACA;AAkBA;AAKA;AASA;AAIA;AAwBA;AAGA;AAcA;AAKA;AAGA;AASA;AAOA;AAIA;AAIA;AAOA;AAIA;AAEA;AAaA;AAIA;AAIA;AAEA;AAeA;AAIA;AAsCA;AAcA;AAmBA;AACA;AAWA;AAWA;AAkBA;AAEA;AAKA;AAKA;AAKA;AACA;AACA;AASA;AAaA;AASA;AAsBA;AAyBA;AAOA;AACA;AACA;AAIA;AAKA;AAKA;AAKA;AAIA;AAKA;AAwBA;AAiBA;AAIA;AAMA;AAMA;AAKA;AAMA;AAGA;AAGA;AAGA;AAMA;AAQA;AAKA;AAYA;AAMA;AAIA;AAQA;AAOA;AAIA;AAGA;AAGA;AAQA;AAIA;AAuBA;AAKA;AA4BA;AAOA;AAuBA;AAkBA;AAKA;AAKA;AAYA;AAMA;AAKA;AAGA;AAGA;AAgCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAEA;AAEA;AA8EA;AAiBA;AAQA;AAWA;AAmBA;AA2BA;AAOA;AAKA;AAKA;AAiBA;AAKA;AAGA;AAGA;AAiBA;AAaA;AAUA;AAiEA;AAOA;AASA;AAYA;AAWA;AAQA;AAKA;AAEA;AAIA;AAGA;AAQA;AAGA;AAMA;AAEA;AAKA;AASA;AACA;AAgBA;AAKA;AAOA;AA8GA;AACA;AACA;AACA;AACA;AAMA;AACA;AAUA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AACA;AAIA;AACA;AACA;AAIA;AAIA;AACA;AACA;AASA;AACA;AACA;AAGA;AACA;AAGA;AAMA;AACA;AACA;AACA;AAKA;AACA;AACA;AAIA;AACA;AACA;AAKA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AAiBA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAaA;AAOA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAUA;AACA;AAGA;AAOA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAMA;AAYA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAKA;AAUA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAKA;AACA;AAqBA;AACA;AACA;AACA;AASA;AAIA;AAMA;AAIA;AACA;AACA;AACA;AASA;AAaA;AACA;AACA;AACA;AAQA;AAQA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAUA;AAWA;AAKA;AACA;AACA;AACA;AACA;AASA;AAMA;AAKA;AACA;AACA;AACA;AACA;AASA;AAMA;AAKA;AACA;AACA;AACA;AACA;AASA;AAMA;AACA;AACA;AACA;AACA;AAUA;AAmBA;AACA;AACA;AACA;AACA;AASA;AAcA;AACA;AACA;AACA;AAQA;AAOA;AAIA;AAKA;AAGA;AACA;AAGA;AAWA;AACA;AACA;AAKA;AACA;AAMA;AACA;AACA;AAQA;AACA;AACA;AACA;AAKA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AAaA;AACA;AAWA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AAWA;AASA;AACA;AACA;AACA;AACA;AACA;AAMA;AAuBA;AACA;AACA;AACA;AAgBA;AACA;AA6XA;AACA;AACA;AAOA;AACA;AAYA;AACA;AAQA;AACA;AACA;AAQA;AACA;AACA;AACA;AAMA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAEA;AAEA;AAOA;AACA","sources":["webpack://GUI/./preload/https%3A%2F%2Fyokobond%2Egithub%2Eio%2Fxcx-vpen%2Fdist%2FxcxVPen%2Emjs/extension.mjs"],"sourcesContent":["var img$2 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAF0CAYAAAD/4EcMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAIABJREFUeJzt3XmQnGlh5/nfe+SddUoqle67pVYf9EE30M0NxhxhM7Y5hsaAZ8zueGZgPGPmiJmN3XDEboRjvOsBxoTXw7rHwdjGxuC2wUODoblMd0ObPuhb6JZKaqmkKtWV93vtH2+n+lKV6s16M988vp+IihZSvpmPpFTll+d93uc1Pn53EAgAAACxMZMeAAAAQL8hsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDM76QEAGFx5r6L1tRmtr89otDGvoltS0SlpyFlSwS1LkqzAU8arS5IcMyXHTEmSqlZOi+lhleyiSnZRC+kRzWTWaya7XiW7mNjvCQAkAgtAB2T8uraVp7S1ckbbS6e1rTKlidoF5d1KW16vaud0MbNBpwvbdSa/VVOFbZrKb1PVzrXl9QDg5QgsALHLexVds3BY1ywe1t6lo9pROiVTfsdeP+dWtd09re3l05d/zjdMnclv1ZHhfTo8fI2ODO3TUmqoY2MCMFiMj98dBEkPAkDv21C7qBvnn9CrLj2uaxYPywq8pIe0okCGThe269mRa/X4+Kt0rLhHgWEkPSwAfYLAAtCydfVZ3Tb7E9154QFNVs8nPZw1uZQZ12PjN+vBDXfodGF70sMB0OMILACRZPy6Xnvxx7rzwgPaVTqR9HDaYqqwTQ9suFMPTtyhqsW6LQDREVgAVmWyel5vnv6+7rjwoHJeNenhdETdyuih9a/R9ze+WVOFbUkPB0APIbAArGh36bjefeZe3Tj/hIwB/nbxzMhB3bv13frZ8P6khwKgB3AVIYArOrBwSO85+3UdWDiU9FC6wsGFZ3Rw4RkdG9qjr295j54cuyHpIQHoYsxgAXiJbeUp/fLpe3T9/FNJD6WrHR6+Rl/Z8T6dKO5KeigAuhCBBUCSNNqY1y+fvkevvfhjGeLbwmoEhqFHx2/RX23/FV3Mbkh6OAC6CIEFDDhTvt5y/nt679RXlXMHY/F63BwzpW9ufqe+seVdl2/lA2CwEVjAANuzdEy/evxPtbVyJrlB+L5ULktLS+F/a7Xwq16XGg0pCF74Mk3JMKR0OvzK5aRMRioUpKEhqVgMH5OQ6exG/dnuD+vZkWsTGwOA7kBgAQPIDly9d+qresdz35IZdO4WNqrXpelpaXZWunQp/G+pFEZWHAwjjKzxcWnduvBrYiIMsQ4JDEM/2PgmfWX7+1S3Mh17XQDdhcACBsy28pR+/ejd2lI52/4XcxzpzBnp7NkwrObm2v+aVzIyIk1OSps3S1u3hrNebXYhO6H/vvef6tjQnra/FoDuQ2ABA+St57+r95/6smzfbd+LVKvS8ePSqVPS+fPxzU7FxTCkjRulHTuk3bvD04tt4humvrbtF3Xv5ndzn0NgwBBYwADIejV97NgX9OrZh9vzAq4rnTghHT0qPfdcuF6qFxhGOLO1d28YW6n2LFB/cuwG3b3311W22xdzALoLgQX0uU3Vc/oXP/uD9tyMeWFBOnRIOnw4XF/Vy1Ipad8+6dprpbGx2J9+NrNOf7D/X3AjaWBAEFhAH7t24Vn9xuE/VN6txPvEs7PSU0+FM1b9+C1kclK68UZpe7wxVLcyunvvr+ux8ZtjfV4A3YfAAvrU6y/cr189/qeyAi++J71wQXrkkXDR+iCYnJRuvVXatCm2pwxk6Cs73qdvbX5HbM8JoPsQWEAf+sUzX9MvTP1tfE+4sCA9/HC4zmoQbdsm3XZbuP1DTL47+Vb9xc5/zOJ3oE9xs2egjxhBoA+c+ku9/dx98Tyh40iPPio9/XT3XQ3YSVNT4XYT+/eHoRXDNg9vPf9dZb2avrDnY/KN5DZHBdAeBBbQJ8zA10eO/4lef+H+eJ7wxAnpxz8Od1dHuNbs0KFw+4nbbw8XxK/RHRcfVMav64/2flyuybdjoJ/wLxroA4YCfezYF3THxQfX/mS1mnT//dLJk2t/rn5UrUo/+IF07Jj0hjeseR+tW2cfkRV4+n/3/3P5YiYL6Bf8awb6wIdO/Hk8cXX6tPRXf0VcrcaZM9I994ShtUY3Xfqp/umR/y5DLIkF+gUzWECP++XT9+gt57+3tifx/fDqwMcfj2dQg6Jel773vTC27rxTslv/lvqamYfkmra+sPtjLHwH+gCBBfSwt53/jt519htre5JyWfrud8N7BaI1R46EN69+29uk4eGWn+bOCw9oLj2mr257b4yDA5AEThECPeqGuSf1gZN/ubYnuXhR+pu/Ia7iMDsrffWr4a2C1uA9Z7+u1138UUyDApAUAgvoQdvLp/XPDv83mcEatk44eVL6+tfDRduIR70uffOb0rPPtvwURhBesHBg4VCMAwPQaQQW0GOGnCV94tDnlPHXcO+/p5+WvvOd8CbNiJfvSw88EO4f1iIr8PTPDv83jTcuxTgwAJ1EYAE9xAx8/S9H/j+NNeZaf5LHHpN+9KP+vIdgN3n0Uemhh1o+vOiW9Bs/+0PZPhEM9CICC+ghv3Dmb3XtQuunn/STn4RXC6Iznnwy3FOsRbtKJ/T+U1+OcUAAOoXAAnrEwYVn9J4zX2/9CR59lG0YknDoUDhj2KK3nv+uXj37cIwDAtAJBBbQA/JuRR879oXWN6J8+uk1rQnCGj39dHiz7BZ95PifrO20MICOI7CAHnDXiS9qvN7igucjR9Y0g4KY/PSn0lNPtXRo3q3oI8f/RAbr5oCeQWABXe7W2Uf0mpkWF0ufOyf98IfxDgite+ih8GbRLbhh7km9/mJMN/IG0HYEFtDFcl5VHzr5560dvLAg3XdfuG0AukMQhLfWmZ1t6fD3n/yyRhoLMQ8KQDsQWEAX+6XTf93aB6rrhnFVX8NeWWgP15W+/e2W/m5yXpWrCoEeQWABXWpH+ZTeNP2D1g5+4AFpjkXRXatUkr7//Zb2InvNzENr26oDQEcQWEAXMoJAdx3/Ymu3wjl0KFzYju42NSU98URLh9514osyxalfoJsRWEAXuvXSI9pdOh79wKWlNe0ejg575BFpZibyYZPV83rDNBcvAN2MwAK6jBV4+qXTfx39wCCQfvADyXHiHxTaw/fDU4WeF/nQ9059VVmvFv+YAMSCwAK6zBun/14TtQvRD3zySen8+fgHhPaan29pE9ghZ0lvP3dfGwYEIA4EFtBF7MDVu8/eG/3Acjm8iTN605NPSpeibyT7jue+pbxbacOAAKwVgQV0kTsuPKjRxnz0Ax98kFODvcz3w7/DiHJetfUrTQG0FYEFdAkz8PXO574Z/cAzZ1reHRxd5Px56dixyIe9/dx9SvnENdBtCCygS9x66RFtqF2MdlAQSP/wD+0ZEDrv4YcjL3gfdhb1+gvcQgfoNgQW0CXedu470Q86cqSltTvoUktL0rPRNxF96/nvciNooMsQWEAX2Fae0p6liKeHfL+lq8/Q5R57LPJ6usnqee1f/FmbBgSgFQQW0AXecv570Q86ejS85Qr6S73e0izWm6e/H/9YALSMwAISlvVqun024jqqIJAef7w9A0Lynnoq8lqsm2cf07Cz2KYBAYiKwAISdvOlx5Tx6tEOOnlSWlhoy3jQBSqVyPeTNOXrtpmftGlAAKIisICE3T7TwlWATz8d/0DQXZ56KvIhr5nhPpRAtyCwgAQNOUs6OP9MtIPm57klziBo4e95V+lEa7dZAhA7AgtI0C2XHpUpP9pBz0QMMvSuFha7v3rm4TYMBEBUBBaQoBvnnoh2gO+3tNs3etTJk1KjEemQG+afbM9YAERCYAEJSfmODiwcinbQmTPhZfwYDJ4X+TZIu0vHVXTZvgNIGoEFJOTahWeV9qPNTjB7NYCOHo30cDPwdf1c9AXyAOJFYAEJuW4+4pWAniedPt2ewaB7nTsXedbyugWuMgWSRmABCdm3FG2fI507F/kWKugDvh+eGo7gmsXDbRoMgNUisIAE5LyqtlTORjuI2avBNTUV6eHj9UtaV59t02AArAaBBSRg7+JRmUHE7RnORgwy9I+IM1gSs1hA0ggsIAG7S8ejHVCtcmucQVarhRuPRrB7KeJ7DECsCCwgAdvK0U75sHM7or4Htlaiz3oBiA+BBSSAwEJkLQSWEQRtGgyAqyGwgA4rOiWNNy5FO2hmpj2DQe+I+B7IejWtr/O+AZJCYAEdNllrYTbqUsQgQ/9ZWJBcN9Ihm6vPtWkwAK6GwAI6bEPtYrQDFhfZ/wpSEERe6M4MFpAcAgvosMgfehE/VNHHIr4XIsc8gNgQWECHra9FDKylpfYMBL1ncTHSwyO/1wDEhsACOizyAncCC00R3wuR32sAYkNgAR025EQMplKpPQNB74kYWJHfawBiQ2ABHVZ0IwZTtdqegaD31GqRHl50iHMgKQQW0EFGEET/0Iv4oYo+FvG9YAeuMn69TYMBsBICC+igjF+XFXjRDiKw0FSvh9s1RFBwym0aDICVEFhAB9lBtI0iJbEHFl4QBJIXLdAjBz2AWBBYQAfZfguB5fvxDwS9K2JgpXwCHUgCgQV0UOTZhIgfphgAEd8TLc2aAlgzAgvoIDOIOBsVcb0NBkDEGU1OEQLJILCADvJMK9oBJv9E8TJWtPeQa9htGgiAlfDdG+ggTwQW1ihqYJkEFpAEvnsDHeRYqegHRfxARZ+LGN3MYAHJILCADnKMFgIrnY5/IOhNpinZ0YLJMVt4zwFYMwIL6CDHTKlhRgymbLY9g0HvaeG9UEoV2zAQAFdDYAEdVrIjfuARWGiK+F6oWVlOEQIJIbCADos8o5DLtWcg6D0R3wtlu9CmgQC4GgIL6LDF1HC0A4aG2jMQ9J6I74WlFO8dICkEFtBhs5l10Q4gsNAU8b0wk1nfpoEAuBoCC+iwyB96BBaahqPNfhJYQHIILKDDZrIRP/TGx9szEPSesbFID7+Y3dCmgQC4GgIL6LDIH3q5HAvdEe5/NTIS6RACC0gOgQV02HO5zfKj/tNbF3HdFvrP2JhkGJEOOZvf0qbBALgaAgvoMMdMaTq3MdpBG5iJGHjro51aXkwNR79iFUBsCCwgAVOFbdEOmJxsz0DQOyK+ByK/xwDEisACEjCVj/jhNzER+Sa/6DMEFtBT+I4NJODo8N5oB6RSrMMaZCMjUiHaruxHhyK+xwDEisACEnCyuFOOmYp20DZmJAZWxL/7wDB0rLinTYMBsBoEFpAA17B1orgr2kHbt7dnMOh+EQPrbG5L9HteAogVgQUk5PDwNdEOWL9eyufbMxh0r1Qq8vqryO8tALEjsICEPDV6ffSDdkWc9ULv27FDsqxIh7T03gIQKwILSMjxod1aSkW8z+Ae1tUMnIh/5w0zrUMjB9o0GACrRWABCQlkRJ9pmJiIfLsU9LBsVtoSbTf2Z0eujX4BBYDYEVhAgh4fe1X0g/bti38g6E779kXe/+yJsRvbNBgAURBYQIKeGLtRVSvijZwPHIi8Jgc96kC0U32eYenR8VvaNBgAURBYQIIcM6Wfjt8U7aBsVtq5sy3jQRfZujXy6eCnRq9newagSxBYQMIeWv+a6Addd138A0F3OXgw8iEPbWjhvQSgLQgsIGHPjl6r+fRotIMmJqRNm9ozICRvfDzyxrJVK9famj4AbUFgAQnzZeqHE2+IfuBNEU8tone08Hf7ow2vU8NMt2EwAFpBYAFd4O83vlF+1H+OW7aEM1noL6OjkTeUDQxD3598c3vGA6AlBBbQBebTo3ps3c3RD7z99vgHg2TddptkGJEO+dnwfp3LccoY6CYEFtAl7tv09ugHTU5yE+h+snFjeGuciL4z+bY2DAbAWhBYQJc4OrRXR4Zb2ET09tsjb0aJLvWa6FcBns1vYXE70IX4rgx0kXu3vDv6QaOj0vXc3Lfn7d/f0pq6b2x5l4KIpxQBtB+BBbTMlxG4ku9c/jLkSwpafsanRq/X6UILp/xuuUUqssFkz8pmW1pPdzG7QT9Zf1sbBgRgreykBwB0OyNwZfh1mUFdRuBcjqoVJw0MS35gSmZKgUwFhq3ASCkwUwqMlKTlD/7r7b+k33z2s9EGadvSHXdI3/pWtOPQHV77WimTiXzY17b+YvSrTwF0BIEFXIHp12X6ZZl+VUbgSJIsUxrJSUM5qZiRMraUsiXLkGxLcj3J8aSGJ1Ubnip1T+WGo0pDqjsvfnZDvizJTCswM/KNtHwzo+aE8lOj1+vZkWt17cKz0Qa9fbt0zTXS4cOx/BmgQ3bskPbujXzYVGEbO7cDXYzAApoCX5ZfkuUtyQgcWYY0MSJtGZM2Dkujecl80cSTYRgyTFOmEYaR7/sKFCjw/Vc8tRdIi1VpoSLNVwItVFzNV10tVSuXTygGRkq+kVFg5XTP9n+k//TUIRlBxNONr3uddP68tLjY4h8COiqblV7/+pYO/cqO9ylYYSYUQLIILCDwZftLsrxFKfC0vijt3SjtXC+lrDCk0pms7FRa6XRGpmXLsmyZK1y55/ueXMdREPhyXVee5yqfc7R+yJHnuZcf53jSxSVppiTNLDmaWXJUd0o6lzJ134ab9OpLTyrrecoGq/woTaWkN75Ruvde6Qqhhy5iGNKb3iTlcpEPfXr0Oj0zEv1ehQA6h8DCQLO8kmxvXgpcbR2XrtsiTQxJhmkqk8kpmysoncmuGFNXYpqW0hlLkvTylTVBEMhzHTUadblOQ7lsXVvGHAVBoEDSbEk6Ny/9NP8WbX/shDJuVWYQKO/7Kvq+skEgrTSzNTkZblb50EPR/jDQWa96lbRtW+TDXMPWX+z8x20YEIA4EVgYSEbgynZnZfpVrS9Kt+4Kw8qybOWLw8oXhmS06dJ3wzBkp9KyUy/cNy4IAjmNuhqNmjKZmtYXa9LWnKrXfkyZk8/IP31apTNnVHJdWZLynqei5ymzXGjdcIM0PS2dPNmW3wPWaPNm6dZbWzr0G1vepfO5yZgHBCBuBBYGjulXZDszSlm+btklXbNJsixLxaFR5QtDiYypeRoynclKQ+F6rka9qkZ9SL7lytyxQ/I86exZeadOaWlqSkuep3QQaMjzVPC8V15L9qY3hWuxLl1K4reE5QwPS299a+Tb4UjSheyEvrHlXW0YFIC4EVgYHEEg25uX5S1oXVF6435pKGsomy9qeGS8bTNWrTBNU9lcQdlcQamhosYWp1StVVXeuVPe9u1SoyGdOKHGkSOanZvTnG2r4Hka8TzZzVmtVEp65zulr35VKpeT/Q2tUWAYqqfTctJpOamUXNuWb1nyTPNyqJi+L8vzZLmubMdRttFQql6XGfVCgXZKpaSf+7lwcXtEgQx9Yc/H5JipNgwMQNyMj9/dTd99gHYJZDsXZfkV7ZuUbtslpSxLY+smlEpH33+o00acBY025hUEgWqNhkrVqir1uoIgkGZmwq0ZTp6U4XnK+76GPU+Z5iL3mRnp61+XHGflF+kyjVRK1UJB1WxW9Uzmhd3KMxlp3bpwY9Vi8YWZIMcJZ+sWFqSlpfDngkC5el25SkX5clm25yXzm5EkywqDd1NrN2X+1uZ36Ms73h/zoAC0C4GF/hf4SjkXZAU13bwjXMieyeY0MrpepmUlPbpVm6ydV8arX/7fnu+rXK2qVK2q4bpStSodOiQdOSLV68r4vsY8T1nfl86dk/7u7yTXXeEVkudZlkrFosqFghrpdBhPW7aEt5HZvz/88fj41e+9uLgonTghHT0qPfFEuHVFEKhQrWpocVHZWq0zv6EmwwhPC+7a1dLh53Kb9H/e+L8zewX0EAIL/e1FcfW6vdKeCSlfGNLw6LqkRxaZHbjaVD0nM3jl9gvVel0L5bJqjUY4k3P0qPTMM1Klopzva9R1lTl9Wvr2t7ty+4ZGJqPFoSGVCwUFphmGyG23hbcAGh2VFM44pixLacuSbVmyDEP284HsP/9tzPU8ub6vhuuq4XlymjNW09PS/feHX5WKMrWaxubmlK3XrzieWBmG9OY3S3v2tHS4Y6b0O9f/R00Vol9xCCA5BBb6liHJakzLDqq6c5+0a4NUHB5VcWg06aG1LO9VtKF2cdlfbziOFisVlarVcLbqZz+Tnn5aqteV9zyNnjih9H33hQvmE+YbhsqFgpaGhtTIZMJTf697XRgjmzbJkJRLp5VPp5VNpWRH3CpDklzfV7XRUKleV911w/i8//5wn7DFRRUqFY3PzsqK6c9jZsLS//U76/TjN+Y0PO/rf/2vC3rf6Zulfftafs7/sfuj+uHGN8QyPgCdQ2Chb9nurCxvSbfvkvZvkoaGx1QYGkl6WGs21pjTsLPyTu2u52m+VFK5VlPQaISzWc88I8N1lX/uOY1+85tKVasdGvFLOamUloaGVCoW5ZtmuCbpTW8K4yqbVca2VcxkVMhkZMZ44UHDdbVUr2upVpPqdem++6R775XZaGj80iUVS6U1Pf/MhKWPfm2Tju5Pv+Tn/9W3dusT397Z0nM+uOEO/fHef7KmcQFIhnXLe3/7t5MeBBC35gai122RbtgqFYZGVBzu3ZmrF6tbWWX9muxg+VkX0zSVz2ZVyGblSXLWr788i+I4jpZ27FB9fl6m68p23bbfcKWRTmtpaEhz4+OaGxtTvVBQcOut0oc+JP3Kr8jYtUvFQkHrikWN5vPK2HbsV3Vapql8Oq1iNivPMOTs2SO9+tUKzpxRpVaTm0opW6229GexXFxJ0kN75mTI0O3Ho73/pgrb9Af7/6V8o3fWCQJ4AYGFvmMGjlLORU2OBLpzn5TLFbpuG4a1MVSx8ip4lSuux3oxyzRVyOWUy2TkGobcjRvD0BoakjsyovLiokrZrFzblgxDtudFv//hFbiWpXoup6WhIc2uW6eFkRHVcjl5+/ZJb3mL9Gu/Jt1xh+wNGzSSy2l9sahiJtPSacCoTMNQIZNRJpVSPZOR/9rXSqapxsmTqubzytVqMiOsU7swaelX/3azjl/zyrhqemjPnMxg9ZG1kBrR7x38lMqp4qrHAaC7cIoQfcVQoFTjOeVtR++5SRrKpbRuYnMfxdULUoGjyer5q0bWi9UaDS2Wy6o2Ggo8T5qaCq8ufOCB8LRZECjtOMrU60o7jmzHke26snxfhue9ZHbHN00FpinHsuTbthqplOrptBqZjLzm1Zm2LR08KN14Y3hrmOFhSQpnkjIZ5VKpRP9uAkkzS0sqNxrSs89Kf/RHMhcWtPHCBWVWsQB+pZmrK1nN6cK6ldH/fd2/06nCjlU9J4DuRGChr6TcGVleSW+/Tto0amjdxGbZdv9e2p71apqoXZChaP+MHdfVUqWiSr0u1/PCjUifeirc5uHEifAWO1G3MjCM8D6I27eHXzt2hP/NZF6yYD2fTse6tioOS7WaLpXLCqanpc9+VubMjDZcuKDcCuvULkxa+sjXNuvEvmjvr9/8u936l/ftvOKv+YapP7zmN/TY+M2RnhNA9yGw0DdMv6KUc0E3bpNetU0aHl2X2K1vOulqVxauJAgC1R1H1Xpd1XJZjcXFF24kPTcnXbwYbt5ZLodfzX20TFPK5aR8XhoZkcbGpImJ8EpAhafhmlsq5DMZZduwpipuddfV9OKi/IUF6bOflTE1pYllIivqzNXLXWkmKzAMfWH3x/TAxJ0tPSeA7kJgoT8EvtLOcxrLunrPTVKhUNTI2PqkR9UxBbes9fWZNT+P57pqzM2pXq3K9X05nifP9+X5/ivmyAw9f+Nq05RlmmFQ2bYytq1UD23g+mKN5yPLK5elz3xGxsmTmpieVu5Fs3mrmbm6Nn2dTrunVPaXvzLx5TNZX97xfn1r8zti+X0ASB73IkRfsLwFmYGr2/dItm1peGQ86SF1VNkuyJSv8frabuxs2bZyGzaEszaVyguzWc9rbujZjKt+k7ZtTY6M6Lwk75OfVPBf/osuBIE2nT+vdKOhmQlLv/Y3m1aMqxvSN+nn8u/UvD+nL5W+qLK/dMXHffbnjyswpE98e6fu2f7LxBXQZ7iKEL3Pd5R2Z7Rrg3RwszQ0Mq50JvrNdHtdw8zINVPKe5W1P1kqFd6Q2PdfsimpYRiXv/qVZZoqZDKqSPJvukl69FFVDUOVYl2/9jcbVzwt2IwrQ4ZyRk57Unt12DksJ2hc8fEP7ZnT06PX67A+2abfDYCktP+aaKDNbPeSbCvQLTukVDqjXH5wL20v2wVdzG5QEMfOVqYpDQ2FV/716Cm/VtmmqYmhIZmjo9InP6mL2wv66P/csuq4ahozx/XB4l0qmMuvBfzu7X+rUwd+P9bxA0gegYWeZgYNWUFV12+RChmjz/YxVAIwAAAR0ElEQVS7ak3FyscXWZKUToeL2AuFq99kuY+kbVsbhoY0t6Oof//nwzq5wn2arxRXTauJrJMHP0NkAX1mcL5boi9Z7rxSlrR/UkpnckqlM0kPqStUrZzO5yblxbkLeC4XhlY+PxihZRgqjwf6jzd8TqeGlr+AYKW4aiKygMEzAN8l0a+MwJXpV3Vgk5S21Te3wolLw0zrXG6TGmZrWwlckWGEgdXPM1qmKeXzmllv6KPr/zcdt6eWfehq4qqJyAIGSx9+d8SgsPySDAXat1FKZ7JKpWIMiT7hGZbO5yZVtgvxPrFhhDNa4+PhGq10H/zZp1LhmrPxcc0U6/po8VM6ap5a9uFR4qqJyAIGB4GF3hQEsrySNo9JhYxUKA4nPaKuFcjQTGa9LmXG41uX9WLpdBhZzdOHvbQg3rJemJEbGZEyGc2Yc/po4bdij6smIgsYDAQWepIR1KXA1c71kmlZSmdySQ+p6y3ZQ5rObZRrtGn7uxfHyuho+GO7C7fas+1wbKOjr4jCdsdVE5EF9D8CCz3J8quyDGnbuJTJ5Ab+ysHVqpsZnctvUinV5q0sXhwx4+PhqbdsNpnZLcsKX/v503/LxV+n4qqJyAL6Wxf+30vg6ky/qg3DUsqSMrl80sPpKb5MzabXqWLlta4+Kyvwrn7QWphmeI/C5+9TqCCQHCe8r6Hrhj+O445dphnGVPPLtsOvVcR3p+OqqRlZK+34fvLgZyRJOw6xGSnQSwgs9CBfRuBoYjjcWTydHrxd2+NQtXJ6Lr9Zo415DTlX/nBvC8MI1229eGF8vR7eTNr3w8Xmtn3lKxSbsWQY4ZdpvvS/LUgqrpqILKA/EVjoOabfkBRow5Bk2SmZ/bhVQIf4MnUpPa6yXdB4/ZLS/pVv6dJ2mUwYVkHQ0dOIScdVE5EF9B8+mdBzjMCRJI3mJdte/qa7WL26mdG53CbNZtbFuzlpFM1TfB3SLXHVxJosoL8QWOg5RuDItqR8msCKW8ku6mx+i+bTo/KN/v320G1x1URkAf2jf7+Dom8Zgafc88t3rG7cBqDHBTK0kBrR2fwWLaRH+i60ujWumogsoD/013dODARDvrLPd5XRZx/+3cSXqfnUqM7kt2ouPZbcqcMYdXtcNRFZQO/j0wk9KJD1/DuXBe7tF8jQYmpYZ/NbdDG7QTWrN6/a7JW4aiKygN7GpxN6ThC05YYvuIpAhipWXtPZjXouv1mLqeGemdXqtbhqIrKA3kVgoQcZ8vzwR0EcG1QiMsdIaS49pjP5rZrObVTJLnZtbPVqXDURWUBvIrDQe0xLDTf8oe+3eRdyXFXNzGo2s05n8lt1PjephdSIGmb66gd2QK/HVRORBfQeAgs9J5Cp6vP7YQa+n+xg8BJ1M6P59KjO5TZpKr9NF7ITWkwNq25mtNKJ3UDGir/ein6JqyYiC+gtXOOOnhPIVt2T6q7kOAntPI6r8g1TVSunqpWTJBkKlPYbSvsNZby6rMBTIEN1K6OSXVQqcLSuPivbd1t+zUCGXNPWtLWoj+f+rY4b/RFXTez4DvQOAgu9x0xLnjRflYp5J+nRYJUCGaqbGdXNjJbsV87CeIals7ktynlVpf2GzODKs5O+YYYzXoYhX6Z8w5RnWJe/5owZ/TvrN3VKJ5YdSy/GVRORBfQGAgs9xzfC9T0zi9LkcCO8qrDFG/2i+7x41iuqMK4+rFM6uuxjejmumogsoPuxBgs9JzAs+bJ1YSm8irBRryU9JHSBQYmrJtZkAd2NwEJPCqyczs9LXiDV69Wkh4OEDVpcNRFZQPcisNCTfDMv15fOzUu1Spn9sAbYoMZVE5EFdCcCCz3JN7MKZOrExXAvLE4TDqZBj6smIgvoPgQWepQhzyxoajbcrqFaKSU9IHQYcfVSRBbQXQgs9CzfHpIXSEempXqtIs9rff8k9Bbi6sqILKB7EFjoWYGRlm9kdeic5PqBSovzSQ8JHUBcrYzIAroDgYWe5qVGVW1IR8+Hpwldl41H+xlxtTpEFpA8Ags9zTey8o2MHj8jOZ60tDCX9JDQJsRVNEQWkCwCCz3Ps8dVd6Snz4Zrseq1ZPfFqqqiY8YzqosrG+Myq2n9lvmhFePqxvTNxNXLjJnj+kDhQyqYxWUfE0bW5zo4KmAwEFjoeb6ZkW8V9fRZab4iLczNJLYv1j3mH+sD9u36DesX9EH7tfq2cU8i4+gns5rWv7V+VWeM48s+5sb0zXp7/ueJqysYt9bpA4W7rhJZnyaygJhZt7z3t3876UEAaxUYGZl+WXPlQLsnAvmep2wu39ExfMn8vD5v/o5chVczOmroQfM+jQRj2q9XdXQs/WLOmNG/tz+iKePYso/htODV5cy89qT26bBzWE7QuOJj5jf8WEZganTmNR0eHdCfCCz0B8OUZKlWq8g0pPFcQ3YqJTuV7sjL/6n5Of2x+f9c8dd+Yv5AY8F6XaMbOjKWfjGraX3K+vCKccVpwdXLGTnttvfoiPuzq0SWpdGZ2zs8OqD/EFjoG4GZlhk4ujDvaHJUslVTJpuTZVltfd0vmZ9fNq6a/sH8PjNZETBz1R7MZAGdQ2Chr/hWTqZf0XNzvnauC+Q3KsrlizLM9iw3XGnm6uWYyVodZq7ai5ksoDMILPQZQ4GZk1cvaXpR2rUhUKNeVS5XiD2yVjNz9XLMZK2MmavOYCYLaD8CC30nMCzJzKheq2h2Sdq+zpfr1JXNFWQY8Xwof8n8vP7I/M8tHfsT8wdE1hWwz1Vn5Yyc9qT2EllAmxBY6EuBkZIMW5VqVfMVaeuoJ6dRUzabX/NM1tVOCxbMon4u905NuacuX1H4cpwufClOCyaD04VA+xBY6FuBmZYMU6VyVZfK0pZRT069qnQ2J9NsbeH71U4LFoyC3l+8S9tTO7UztVuHnUPLRhanC0OcFkwWpwuB9iCw0NcCMyMZlsqVmi4sSltGfbmNilKpjCzbjvRcVzst2Iyrddb68H+bRe1M7Voxsgb9dCGnBbsDpwuB+BFY6HuBmVFgpFSrVnV6Vto4HChwSjIMQ+lMdlXPETWuLv88kbUs4qq7EFlAvAgsDITATCuwcnLqVZ24GGgkL2XNmhynrkwmt+K6rFbj6vKvE1mvQFx1JyILiA+BhYERGLZ8qyD5dZ2+6KnmSBuKrmrVkizLUuoKu76vNa4uP47Iuoy46m5EFhAPAguDxTDlWUVJgS4t1TU1K40XAll+RY7bUCqVvrwAPq64uvx4Iou46hFEFrB2BBYGkCHfzCkw0mo0ajp2IZDjSWM5R/XKknzf01/n/ofutn532WeIGleXjxvgyCKueguRBawNgYWBFZgpefaQFHiaXWzoyLQUSLp/4k/0p/nfX/a4VuPq8vEDGFnEVW8isoDWEVgYcIZ8K6/AystzHf1485/phzs/v+yj1xpXl59ngCKLuOptRBbQGgILUHh7nVPXflHHbvyvyz4mrri6/HwDEFnEVX8gsoDoCCxA0tQ1n9fx6+Nb0L5a/RxZxFV/IbKAaAgsDLyk4ury8/dhZBFX/YnIAlaPwMJASzquLr9OH0UWcdXfiCxgdQgsDKxuiavLr9cHkUVcDQYiC7g6AgsDqdvi6vLrrjKyhoNRHeiyyCKuBguRBayMwMLA6da4uvz6q4qsv++qyCKuBhORBSyPwMJA6fa4ujyOHoos4mqwEVnAlRFYGBi9EldNvRBZxBUkIgu4EgILA6HX4qpptZFV9IZ0QDfJMDoXMcQVXozIAl6KwELf69W4alpNZD1s/VDGQqDNc1tVr1XUqNfkug15nivPdRUokBTINM1YxkRc4UqILOAFBBb6Wq/HVdNqIuuJ3E9UnStq3dxeOU5DvltTo1ZRrVpWtbykSmlR5dKCKuUlVSvlyyHWaNTkOPXwGM+V53kKfF++7ysIfCkIb4LdnB0jrrASIgsIGR+/OwiSHgTQDv0SVy92wZvWl0t/rlpQXeYRhq59+BPaduQfyZBUyEj5tJRNSbm0lE2/8L+bP5e2pdQqJ7YWrDn9zuSndNY+texjiCtI0px/SV8qfVFlf2nZx+x85l9rx6FPdnBUQOcQWOhL/RhXTauJrGse+w/aduR9MuRJvhv+N/BkyL/yEYaUsaWULWWsMLrSz/9vS5JlSfXcnP7y+k9pJkdcYXWILAwyAgt9p5/jqmk1kbXv8f9Dm4999GU/H8gIPClwZcgPfyxfRuBL8sMIC3wZRiAFfvilQI3sJT3ytt9SaZi4QjREFgYVa7DQVwYhrqTVrcm6NPn3SjdGNTT34i0cDMkwJcNWYKQUmBkFZla+mZNv5uVbBflWUZ41JM8almePqFp09Ohb/rnKwyeWHQ9xheWwJguDisBC3xiUuGpqPbJWr5Gd0eNv+LAqQyxoR+uILAwiAgt9YdDiqqmdkUVcIU5EFgYNgYWeN6hx1dSOyCKu0A5EFgYJgYWeNuhx1RRnZBFXaCciC4OCwELPIq5eKo7IIq7QCUQWBgGBhZ5EXF3ZWiKLuEInEVnodwQWeg5xtbJWIou4QhKILPQzAgs9hbhanSiRlaluIa6QGCIL/Yqd3NEzTh34nE4e/PSyv14wi/pA4S6NW+s6OKruNu2d01dKf6FaUFvmEYbStQk1stPLPseN6Zv19vzPE1doq0verP6y/EWV/dKyj9n5zL/RjkOf6OCogNat8havQLKmrvn8ynFlFPT+woeIq5fZaG3S+4t3KWvklnlEsGJc3ZC+ibhCR4xb6/TB4odVMIeWfczJg5/WqQO/38FRAa0jsND1Th343MqnBc2iPlD88MCfFlzOhLVR7yt+UFkjG+m4G9M3c1oQHTVmjusDhQ+pYBaXfczJg5/RqQOf6+CogNYQWOhqzFzF4+ozWS/FzBWSwkwW+gWBha7FzFW8VjuTxcwVksZMFvoBgYWuxMxVe1xtJouZK3QLZrLQ6wgsdB1mrtrrhZmsl0bWTZlbmLlCV2EmC72MbRrQVdiKoXOW/CU92fipqkFVO+xd2pval/SQgCtiCwf0IgILXYNNRAEsZ86/pC+Vvqiyv7TsY3Y+86+149AnOzgqYHmcIkRXIK4ArGTMHNcHi3ddZU3WZ1iTha5BYCFxxBWA1SCy0EsILCSKuAIQBZGFXkFgITHEFYBWEFnoBQQWEkFcAVgLIgvdjsBCxxFXAOJAZKGbEVjoKOIKQJyILHQrAgsdQ1wBaAciC92IwEJHEFcA2onIQrchsNB2xBWATiCy0E0ILLQVcQWgk4gsdAsCC21DXAFIApGFbkBgoS2IKwBJIrKQNAILsSOuAHQDIgtJIrAQK+IKQDchspAUAguxIa4AdCMiC0kgsBAL4gpANyOy0GkEFtaMuALQC4gsdBKBhTUhrgD0EiILnUJgoWXEFYBeRGShEwgstIS4AtDLiCy0G4GFyIgrAP2AyEI7EViIhLgC0E+ILLQLgYVVI64A9CMiC+1AYGFViCsA/YzIQtwILFwVcQVgEBBZiBOBhRURVwAGCZGFuBBYWBZxBWAQEVmIA4GFKyKuAAwyIgtrRWDhFYgrACCysDYEFl6CuAKAFxBZaBWBhcuIKwB4JSILrSCwIIm4AoCVEFmIisACcQUAq0BkIQoCa8ARVwCwekQWVstOegBIzqkDn9PJg59e8TFFc1g/qt3foREBQG8oGkWVtbTsr588+BlJhnYc+kTnBoWuQmANqOd2/dlV40qSpr1zmvbOdWBEANBfTh78tFL1MW0+8eGkh4IEcIpwAAWmp5PX/V7SwwCAvnfyut9TYHpJDwMJILAGkJtalJNeSHoYAND3nPSC3NRi0sNAAgisAZSqjypX2pH0MACg7+VKO5SqjyY9DCSAwBpIhvY/8ruyneGkBwIAfct2hrX/kd+VZCQ9FCTA+PjdQZD0IJAMNz2vSxM/lJcqJz0UAOgrllPQ+IU3yG4wezWouIpwgNmNUU2c+YWkhwEAQN/hFCEAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMz+f70FRvmTmo4QAAAAAElFTkSuQmCC\";\n\nvar img$1 = \"data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3csvg version='1.1' width='14.022916mm' height='14.022916mm' viewBox='0 0 28.045832 28.045832' id='svg4' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg'%3e %3cdefs id='defs4' /%3e %3cg id='g4' transform='matrix(0.11400745%2c0%2c0%2c0.11400745%2c-12.540819%2c-10.7167)'%3e %3cg id='rect' style='display:none'%3e %3cpath d='m 120%2c340 q 10%2c0 113%2c0 103%2c0 113%2c0 10%2c0 10%2c-10 0%2c-10 0%2c-113 0%2c-103 0%2c-113 0%2c-10 -10%2c-10 -10%2c0 -113%2c0 -103%2c0 -113%2c0 -10%2c0 -10%2c10 0%2c10 0%2c113 0%2c103 0%2c113 0%2c10 10%2c10 z' fill-opacity='1' fill='%23649dff' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='0' stroke='black' id='path1' /%3e %3c/g%3e %3cg id='sun'%3e %3cpath d='m 230%2c240 q 0%2c0 2.5%2c0 2.5%2c0 4.9863%2c-0.26132 2.48631%2c-0.26132 4.93168%2c-0.7811 2.44537%2c-0.51978 4.82301%2c-1.29232 2.37764%2c-0.77255 4.6615%2c-1.78939 2.28387%2c-1.01684 4.44893%2c-2.26684 2.16506%2c-1.25 4.18761%2c-2.71946 2.02254%2c-1.46947 3.8804%2c-3.14229 1.85786%2c-1.67283 3.53069%2c-3.53069 1.67283%2c-1.85786 3.14229%2c-3.8804 1.46946%2c-2.02255 2.71946%2c-4.18761 1.25%2c-2.16506 2.26684%2c-4.44893 1.01685%2c-2.28386 1.78939%2c-4.6615 0.77254%2c-2.37764 1.29232%2c-4.82301 0.51978%2c-2.44537 0.7811%2c-4.93168 0.26132%2c-2.4863 0.26132%2c-4.9863 0%2c-2.5 -0.26132%2c-4.98631 -0.26132%2c-2.4863 -0.7811%2c-4.93167 -0.51978%2c-2.44537 -1.29232%2c-4.82301 -0.77254%2c-2.37764 -1.78939%2c-4.66151 -1.01684%2c-2.28386 -2.26684%2c-4.44892 -1.25%2c-2.16507 -2.71946%2c-4.18761 -1.46946%2c-2.02254 -3.14229%2c-3.8804 -1.67283%2c-1.85787 -3.53069%2c-3.53069 -1.85786%2c-1.67283 -3.8804%2c-3.14229 -2.02255%2c-1.46946 -4.18761%2c-2.71946 -2.16506%2c-1.25 -4.44893%2c-2.26685 -2.28386%2c-1.01684 -4.6615%2c-1.78938 -2.37764%2c-0.77254 -4.82301%2c-1.29232 -2.44537%2c-0.51978 -4.93168%2c-0.7811 -2.4863%2c-0.26132 -4.9863%2c-0.26132 -2.5%2c0 -4.9863%2c0.26132 -2.48631%2c0.26132 -4.93168%2c0.7811 -2.44537%2c0.51978 -4.82301%2c1.29232 -2.37764%2c0.77254 -4.6615%2c1.78938 -2.28387%2c1.01685 -4.44893%2c2.26685 -2.16506%2c1.25 -4.18761%2c2.71946 -2.02254%2c1.46946 -3.8804%2c3.14229 -1.85786%2c1.67282 -3.53069%2c3.53069 -1.67283%2c1.85786 -3.14229%2c3.8804 -1.46946%2c2.02254 -2.71946%2c4.18761 -1.25%2c2.16506 -2.26684%2c4.44892 -1.01685%2c2.28387 -1.78939%2c4.66151 -0.77254%2c2.37764 -1.29232%2c4.82301 -0.51978%2c2.44537 -0.7811%2c4.93167 -0.26132%2c2.48631 -0.26132%2c4.98631 0%2c2.5 0.26132%2c4.9863 0.26132%2c2.48631 0.7811%2c4.93168 0.51978%2c2.44537 1.29232%2c4.82301 0.77254%2c2.37764 1.78939%2c4.6615 1.01684%2c2.28387 2.26684%2c4.44893 1.25%2c2.16506 2.71946%2c4.18761 1.46946%2c2.02254 3.14229%2c3.8804 1.67283%2c1.85786 3.53069%2c3.53069 1.85786%2c1.67282 3.8804%2c3.14229 2.02255%2c1.46946 4.18761%2c2.71946 2.16506%2c1.25 4.44893%2c2.26684 2.28386%2c1.01684 4.6615%2c1.78939 2.37764%2c0.77254 4.82301%2c1.29232 2.44537%2c0.51978 2.44537%2c0.51978' fill-opacity='1' fill='red' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='8' stroke='%23ff6464' id='path2' /%3e %3c/g%3e %3cg id='cloud'%3e %3cpath d='m 219.24084%2c271.8692 q 20.24083%2c-0.13079 32.801%2c-13.80309 12.56017%2c-13.67229 1.37931%2c-27.38375 -11.18086%2c-13.71146 -26.10309%2c-6.8054 -14.92222%2c6.90606 -26.43448%2c0.5 -11.51227%2c-6.40607 -24.86381%2c-7.53504 -13.35153%2c-1.12898 -21.4001%2c10.78438 -8.04857%2c11.91335 -1.1315%2c23.6516 6.91708%2c11.73825 26.21446%2c16.23017 Q 199%2c272 219.24084%2c271.8692 Z' fill-opacity='0.8' fill='white' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='0.25' stroke-width='2' stroke='grey' id='path3' /%3e %3c/g%3e %3cg id='mountain'%3e %3cpath d='m 120%2c310 56.56854%2c-56.56854 28.28427%2c28.28427 56.56855%2c-56.56854 L 346.27417%2c310 Z' fill-opacity='1' fill='%2398ff9b' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='4' stroke='%2325ef22' id='path4' /%3e %3c/g%3e %3c/g%3e%3c/svg%3e\";\n\nvar en$1 = {\n\t\"xcxVPen.entry.name\": \"Vector Pen\",\n\t\"xcxVPen.entry.description\": \"Draw SVG paths like the pen extension\"\n};\nvar ja$1 = {\n\t\"xcxVPen.entry.name\": \"ベクター ペン\",\n\t\"xcxVPen.entry.description\": \"ペン拡張機能のようにSVGパスを描く\"\n};\nvar translations$1 = {\n\ten: en$1,\n\tja: ja$1,\n\t\"ja-Hira\": {\n\t\"xcxVPen.entry.name\": \"ベクター ペン\",\n\t\"xcxVPen.entry.description\": \"ペン ブロック の ように SVG パス を えがく\"\n}\n};\n\n/**\n * This is an extension for Xcratch.\n */\n\n\n/**\n * Formatter to translate the messages in this extension.\n * This will be replaced which is used in the React component.\n * @param {object} messageData - data for format-message\n * @returns {string} - translated message for the current locale\n */\nvar formatMessage$1 = function formatMessage(messageData) {\n  return messageData.defaultMessage;\n};\nvar entry = {\n  get name() {\n    return formatMessage$1({\n      id: 'xcxVPen.entry.name',\n      defaultMessage: 'Vector Pen',\n      description: 'name of the extension'\n    });\n  },\n  extensionId: 'xcxVPen',\n  extensionURL: 'https://yokobond.github.io/xcx-vpen/dist/xcxVPen.mjs',\n  collaborator: 'yokobond',\n  iconURL: img$2,\n  insetIconURL: img$1,\n  get description() {\n    return formatMessage$1({\n      defaultMessage: 'Draw SVG paths like the pen extension',\n      description: 'Description for this extension',\n      id: 'xcxVPen.entry.description'\n    });\n  },\n  tags: ['image', 'vector', 'pen', 'svg'],\n  featured: true,\n  disabled: false,\n  bluetoothRequired: false,\n  internetConnectionRequired: false,\n  helpLink: 'https://yokobond.github.io/xcx-vpen/',\n  setFormatMessage: function setFormatMessage(formatter) {\n    formatMessage$1 = formatter;\n  },\n  translationMap: translations$1\n};\n\nfunction _arrayLikeToArray$6(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray$6(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _unsupportedIterableToArray$6(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray$6(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$6(r) || _nonIterableSpread();\n}\n\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$6(r, e) || _nonIterableRest();\n}\n\nfunction _classCallCheck$1(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _typeof$1(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof$1 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof$1(o);\n}\n\nfunction toPrimitive$1(t, r) {\n  if (\"object\" != _typeof$1(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof$1(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey$1(t) {\n  var i = toPrimitive$1(t, \"string\");\n  return \"symbol\" == _typeof$1(i) ? i : i + \"\";\n}\n\nfunction _defineProperties$1(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey$1(o.key), o);\n  }\n}\nfunction _createClass$1(e, r, t) {\n  return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\n/**\n * Types of block\n * @enum {string}\n */\nvar BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  BOOLEAN: 'Boolean',\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  BUTTON: 'button',\n  /**\n   * Command block\n   */\n  COMMAND: 'command',\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  CONDITIONAL: 'conditional',\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  EVENT: 'event',\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  HAT: 'hat',\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  LOOP: 'loop',\n  /**\n   * General reporter with numeric or string value\n   */\n  REPORTER: 'reporter'\n};\nvar blockType = BlockType;\nvar BlockType$1 = /*@__PURE__*/getDefaultExportFromCjs(blockType);\n\n/**\n * Block argument types\n * @enum {string}\n */\nvar ArgumentType = {\n  /**\n   * Numeric value with angle picker\n   */\n  ANGLE: 'angle',\n  /**\n   * Boolean value with hexagonal placeholder\n   */\n  BOOLEAN: 'Boolean',\n  /**\n   * Numeric value with color picker\n   */\n  COLOR: 'color',\n  /**\n   * Numeric value with text field\n   */\n  NUMBER: 'number',\n  /**\n   * String value with text field\n   */\n  STRING: 'string',\n  /**\n   * String value with matrix field\n   */\n  MATRIX: 'matrix',\n  /**\n   * MIDI note number with note picker (piano) field\n   */\n  NOTE: 'note',\n  /**\n   * Inline image on block (as part of the label)\n   */\n  IMAGE: 'image'\n};\nvar argumentType = ArgumentType;\nvar ArgumentType$1 = /*@__PURE__*/getDefaultExportFromCjs(argumentType);\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r );\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (String )(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nvar Color$2 = /*#__PURE__*/function () {\n  function Color() {\n    _classCallCheck(this, Color);\n  }\n  return _createClass(Color, null, [{\n    key: \"RGB_BLACK\",\n    get:\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    function get() {\n      return {\n        r: 0,\n        g: 0,\n        b: 0\n      };\n    }\n\n    /** @type {RGBObject} */\n  }, {\n    key: \"RGB_WHITE\",\n    get: function get() {\n      return {\n        r: 255,\n        g: 255,\n        b: 255\n      };\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n  }, {\n    key: \"decimalToHex\",\n    value: function decimalToHex(decimal) {\n      if (decimal < 0) {\n        decimal += 0xFFFFFF + 1;\n      }\n      var hex = Number(decimal).toString(16);\n      hex = \"#\".concat('000000'.substr(0, 6 - hex.length)).concat(hex);\n      return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n  }, {\n    key: \"decimalToRgb\",\n    value: function decimalToRgb(decimal) {\n      var a = decimal >> 24 & 0xFF;\n      var r = decimal >> 16 & 0xFF;\n      var g = decimal >> 8 & 0xFF;\n      var b = decimal & 0xFF;\n      return {\n        r: r,\n        g: g,\n        b: b,\n        a: a > 0 ? a : 255\n      };\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n  }, {\n    key: \"hexToRgb\",\n    value: function hexToRgb(hex) {\n      var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n      hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n  }, {\n    key: \"rgbToHex\",\n    value: function rgbToHex(rgb) {\n      return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n  }, {\n    key: \"rgbToDecimal\",\n    value: function rgbToDecimal(rgb) {\n      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n  }, {\n    key: \"hexToDecimal\",\n    value: function hexToDecimal(hex) {\n      return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n  }, {\n    key: \"hsvToRgb\",\n    value: function hsvToRgb(hsv) {\n      var h = hsv.h % 360;\n      if (h < 0) h += 360;\n      var s = Math.max(0, Math.min(hsv.s, 1));\n      var v = Math.max(0, Math.min(hsv.v, 1));\n      var i = Math.floor(h / 60);\n      var f = h / 60 - i;\n      var p = v * (1 - s);\n      var q = v * (1 - s * f);\n      var t = v * (1 - s * (1 - f));\n      var r;\n      var g;\n      var b;\n      switch (i) {\n        default:\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n      return {\n        r: Math.floor(r * 255),\n        g: Math.floor(g * 255),\n        b: Math.floor(b * 255)\n      };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n  }, {\n    key: \"rgbToHsv\",\n    value: function rgbToHsv(rgb) {\n      var r = rgb.r / 255;\n      var g = rgb.g / 255;\n      var b = rgb.b / 255;\n      var x = Math.min(Math.min(r, g), b);\n      var v = Math.max(Math.max(r, g), b);\n\n      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n      var h = 0;\n      var s = 0;\n      if (x !== v) {\n        var f = r === x ? g - b : g === x ? b - r : r - g;\n        var i = r === x ? 3 : g === x ? 5 : 1;\n        h = (i - f / (v - x)) * 60 % 360;\n        s = (v - x) / v;\n      }\n      return {\n        h: h,\n        s: s,\n        v: v\n      };\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n  }, {\n    key: \"mixRgb\",\n    value: function mixRgb(rgb0, rgb1, fraction1) {\n      if (fraction1 <= 0) return rgb0;\n      if (fraction1 >= 1) return rgb1;\n      var fraction0 = 1 - fraction1;\n      return {\n        r: fraction0 * rgb0.r + fraction1 * rgb1.r,\n        g: fraction0 * rgb0.g + fraction1 * rgb1.g,\n        b: fraction0 * rgb0.b + fraction1 * rgb1.b\n      };\n    }\n  }]);\n}();\nvar color$3 = Color$2;\n\nvar Color$1 = color$3;\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\nvar Cast$1 = /*#__PURE__*/function () {\n  function Cast() {\n    _classCallCheck(this, Cast);\n  }\n  return _createClass(Cast, null, [{\n    key: \"toNumber\",\n    value:\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    function toNumber(value) {\n      // If value is already a number we don't need to coerce it with\n      // Number().\n      if (typeof value === 'number') {\n        // Scratch treats NaN as 0, when needed as a number.\n        // E.g., 0 + NaN -> 0.\n        if (Number.isNaN(value)) {\n          return 0;\n        }\n        return value;\n      }\n      if (typeof value === 'string') {\n        // Replace full-width numbers with half-width ones.\n        value = value.replace(/[０-９＋．ｅ]/g, function (s) {\n          return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);\n        });\n        value = value.replace(/[-－﹣−‐⁃‑‒–—﹘―⎯⏤ーｰ─━]/g, '-');\n      }\n      var n = Number(value);\n      if (Number.isNaN(n)) {\n        // Scratch treats NaN as 0, when needed as a number.\n        // E.g., 0 + NaN -> 0.\n        return 0;\n      }\n      return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n  }, {\n    key: \"toBoolean\",\n    value: function toBoolean(value) {\n      // Already a boolean?\n      if (typeof value === 'boolean') {\n        return value;\n      }\n      if (typeof value === 'string') {\n        // These specific strings are treated as false in Scratch.\n        if (value === '' || value === '0' || value.toLowerCase() === 'false') {\n          return false;\n        }\n        // All other strings treated as true.\n        return true;\n      }\n      // Coerce other values and numbers.\n      return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString(value) {\n      return String(value).replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t');\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n  }, {\n    key: \"toRgbColorList\",\n    value: function toRgbColorList(value) {\n      var color = Cast.toRgbColorObject(value);\n      return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {RGBOject} [r,g,b], values between 0-255.\n     */\n  }, {\n    key: \"toRgbColorObject\",\n    value: function toRgbColorObject(value) {\n      var color;\n      if (typeof value === 'string' && value.substring(0, 1) === '#') {\n        color = Color$1.hexToRgb(value);\n\n        // If the color wasn't *actually* a hex color, cast to black\n        if (!color) color = {\n          r: 0,\n          g: 0,\n          b: 0,\n          a: 255\n        };\n      } else {\n        color = Color$1.decimalToRgb(Cast.toNumber(value));\n      }\n      return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n  }, {\n    key: \"isWhiteSpace\",\n    value: function isWhiteSpace(val) {\n      return val === null || typeof val === 'string' && val.trim().length === 0;\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n  }, {\n    key: \"compare\",\n    value: function compare(v1, v2) {\n      var n1 = Number(v1);\n      var n2 = Number(v2);\n      if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n        n1 = NaN;\n      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n        n2 = NaN;\n      }\n      if (isNaN(n1) || isNaN(n2)) {\n        // At least one argument can't be converted to a number.\n        // Scratch compares strings as case insensitive.\n        var s1 = Cast.toString(v1).toLowerCase();\n        var s2 = Cast.toString(v2).toLowerCase();\n        if (s1 < s2) {\n          return -1;\n        } else if (s1 > s2) {\n          return 1;\n        }\n        return 0;\n      }\n      // Handle the special case of Infinity\n      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {\n        return 0;\n      }\n      // Compare as numbers.\n      return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n  }, {\n    key: \"isInt\",\n    value: function isInt(val) {\n      // Values that are already numbers.\n      if (typeof val === 'number') {\n        if (isNaN(val)) {\n          // NaN is considered an integer.\n          return true;\n        }\n        // True if it's \"round\" (e.g., 2.0 and 2).\n        return val === parseInt(val, 10);\n      } else if (typeof val === 'boolean') {\n        // `True` and `false` always represent integer after Scratch cast.\n        return true;\n      } else if (typeof val === 'string') {\n        // If it contains a decimal point, don't consider it an int.\n        return val.indexOf('.') < 0;\n      }\n      return false;\n    }\n  }, {\n    key: \"LIST_INVALID\",\n    get: function get() {\n      return 'INVALID';\n    }\n  }, {\n    key: \"LIST_ALL\",\n    get: function get() {\n      return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n  }, {\n    key: \"toListIndex\",\n    value: function toListIndex(index, length, acceptAll) {\n      if (typeof index !== 'number') {\n        if (index === 'all') {\n          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n        }\n        if (index === 'last') {\n          if (length > 0) {\n            return length;\n          }\n          return Cast.LIST_INVALID;\n        } else if (index === 'random' || index === 'any') {\n          if (length > 0) {\n            return 1 + Math.floor(Math.random() * length);\n          }\n          return Cast.LIST_INVALID;\n        }\n      }\n      index = Math.floor(Cast.toNumber(index));\n      if (index < 1 || index > length) {\n        return Cast.LIST_INVALID;\n      }\n      return index;\n    }\n  }]);\n}();\nvar cast = Cast$1;\nvar Cast$2 = /*@__PURE__*/getDefaultExportFromCjs(cast);\n\n/**\n * Default types of Target supported by the VM\n * @enum {string}\n */\nvar TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  SPRITE: 'sprite',\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  STAGE: 'stage'\n};\nvar targetType = TargetType;\nvar TargetType$1 = /*@__PURE__*/getDefaultExportFromCjs(targetType);\n\nfunction _assertThisInitialized$1(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn$1(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized$1(t);\n}\n\nfunction _getPrototypeOf$1(t) {\n  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf$1(t);\n}\n\nfunction _setPrototypeOf$1(t, e) {\n  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf$1(t, e);\n}\n\nfunction _inherits$1(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf$1(t, e);\n}\n\nvar MathUtil$1 = /*#__PURE__*/function () {\n  function MathUtil() {\n    _classCallCheck(this, MathUtil);\n  }\n  return _createClass(MathUtil, null, [{\n    key: \"degToRad\",\n    value:\n    /**\n     * Convert a value from degrees to radians.\n     * @param {!number} deg Value in degrees.\n     * @return {!number} Equivalent value in radians.\n     */\n    function degToRad(deg) {\n      return deg * Math.PI / 180;\n    }\n\n    /**\n     * Convert a value from radians to degrees.\n     * @param {!number} rad Value in radians.\n     * @return {!number} Equivalent value in degrees.\n     */\n  }, {\n    key: \"radToDeg\",\n    value: function radToDeg(rad) {\n      return rad * 180 / Math.PI;\n    }\n\n    /**\n     * Clamp a number between two limits.\n     * If n < min, return min. If n > max, return max. Else, return n.\n     * @param {!number} n Number to clamp.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n clamped to min and max.\n     */\n  }, {\n    key: \"clamp\",\n    value: function clamp(n, min, max) {\n      return Math.min(Math.max(n, min), max);\n    }\n\n    /**\n     * Keep a number between two limits, wrapping \"extra\" into the range.\n     * e.g., wrapClamp(7, 1, 5) == 2\n     * wrapClamp(0, 1, 5) == 5\n     * wrapClamp(-11, -10, 6) == 6, etc.\n     * @param {!number} n Number to wrap.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n wrapped between min and max.\n     */\n  }, {\n    key: \"wrapClamp\",\n    value: function wrapClamp(n, min, max) {\n      var range = max - min + 1;\n      return n - Math.floor((n - min) / range) * range;\n    }\n\n    /**\n     * Convert a value from tan function in degrees.\n     * @param {!number} angle in degrees\n     * @return {!number} Correct tan value\n     */\n  }, {\n    key: \"tan\",\n    value: function tan(angle) {\n      angle = angle % 360;\n      switch (angle) {\n        case -270:\n        case 90:\n          return Infinity;\n        case -90:\n        case 270:\n          return -Infinity;\n        default:\n          return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));\n      }\n    }\n\n    /**\n     * Given an array of unique numbers,\n     * returns a reduced array such that each element of the reduced array\n     * represents the position of that element in a sorted version of the\n     * original array.\n     * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]\n     * @param {Array<number>} elts The elements to sort and reduce\n     * @return {Array<number>} The array of reduced orderings\n     */\n  }, {\n    key: \"reducedSortOrdering\",\n    value: function reducedSortOrdering(elts) {\n      var sorted = elts.slice(0).sort(function (a, b) {\n        return a - b;\n      });\n      return elts.map(function (e) {\n        return sorted.indexOf(e);\n      });\n    }\n\n    /**\n     * Return a random number given an inclusive range and a number in that\n     * range that should be excluded.\n     *\n     * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal\n     * probability)\n     *\n     * @param {number} lower - The lower bound (inlcusive)\n     * @param {number} upper - The upper bound (inclusive), such that lower <= upper\n     * @param {number} excluded - The number to exclude (MUST be in the range)\n     * @return {number} A random integer in the range [lower, upper] that is not \"excluded\"\n     */\n  }, {\n    key: \"inclusiveRandIntWithout\",\n    value: function inclusiveRandIntWithout(lower, upper, excluded) {\n      // Note that subtraction is the number of items in the\n      // inclusive range [lower, upper] minus 1 already\n      // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).\n      var possibleOptions = upper - lower;\n      var randInt = lower + Math.floor(Math.random() * possibleOptions);\n      if (randInt >= excluded) {\n        return randInt + 1;\n      }\n      return randInt;\n    }\n\n    /**\n     * Scales a number from one range to another.\n     * @param {number} i number to be scaled\n     * @param {number} iMin input range minimum\n     * @param {number} iMax input range maximum\n     * @param {number} oMin output range minimum\n     * @param {number} oMax output range maximum\n     * @return {number} scaled number\n     */\n  }, {\n    key: \"scale\",\n    value: function scale(i, iMin, iMax, oMin, oMax) {\n      var p = (i - iMin) / (iMax - iMin);\n      return p * (oMax - oMin) + oMin;\n    }\n  }]);\n}();\nvar mathUtil = MathUtil$1;\n\nvar web = {exports: {}};\n\nvar minilog$2 = {exports: {}};\n\nfunction M() {\n  this._events = {};\n}\nM.prototype = {\n  on: function on(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function removeListener(ev, cb) {\n    var e = this._events[ev] || [],\n      i;\n    for (i = e.length - 1; i >= 0 && e[i]; i--) {\n      if (e[i] === cb || e[i].cb === cb) {\n        e.splice(i, 1);\n      }\n    }\n  },\n  removeAllListeners: function removeAllListeners(ev) {\n    if (!ev) {\n      this._events = {};\n    } else {\n      this._events[ev] && (this._events[ev] = []);\n    }\n  },\n  listeners: function listeners(ev) {\n    return this._events ? this._events[ev] || [] : [];\n  },\n  emit: function emit(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1),\n      i,\n      e = this._events[ev] || [];\n    for (i = e.length - 1; i >= 0 && e[i]; i--) {\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function when(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function once(ev, cb, when) {\n    if (!cb) return this;\n    function c() {\n      if (!when) this.removeListener(ev, c);\n      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function (dest) {\n  var o = M.prototype,\n    k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nvar microee$1 = M;\n\nvar microee = microee$1;\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform$4() {}\nmicroee.mixin(Transform$4);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform$4.prototype.write = function (name, level, args) {\n  this.emit('item', name, level, args);\n};\nTransform$4.prototype.end = function () {\n  this.emit('end');\n  this.removeAllListeners();\n};\nTransform$4.prototype.pipe = function (dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() {\n    !dest._isStdio && dest.end();\n  }\n  s.on('item', onItem);\n  s.on('end', onEnd);\n  s.when('unpipe', function (from) {\n    var match = from === dest || typeof from == 'undefined';\n    if (match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n  return dest;\n};\nTransform$4.prototype.unpipe = function (from) {\n  this.emit('unpipe', from);\n  return this;\n};\nTransform$4.prototype.format = function (dest) {\n  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\\'minilog\\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\nTransform$4.mixin = function (dest) {\n  var o = Transform$4.prototype,\n    k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nvar transform$1 = Transform$4;\n\n// default filter\nvar Transform$3 = transform$1;\nvar levelMap = {\n  debug: 1,\n  info: 2,\n  warn: 3,\n  error: 4\n};\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\nTransform$3.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function (name, level) {\n  this._white.push({\n    n: name,\n    l: levelMap[level]\n  });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function (name, level) {\n  this._black.push({\n    n: name,\n    l: levelMap[level]\n  });\n  return this;\n};\nFilter.prototype.clear = function () {\n  this._white = [];\n  this._black = [];\n  return this;\n};\nfunction test(rule, name) {\n  // use .test for RegExps\n  return rule.n.test ? rule.n.test(name) : rule.n == name;\n}\nFilter.prototype.test = function (name, level) {\n  var i,\n    len = Math.max(this._white.length, this._black.length);\n  for (i = 0; i < len; i++) {\n    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\nFilter.prototype.write = function (name, level, args) {\n  if (!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\nvar filter$1 = Filter;\n\n(function (module, exports) {\n  var Transform = transform$1,\n    Filter = filter$1;\n  var log = new Transform(),\n    slice = Array.prototype.slice;\n  exports = module.exports = function create(name) {\n    var o = function o() {\n      log.write(name, undefined, slice.call(arguments));\n      return o;\n    };\n    o.debug = function () {\n      log.write(name, 'debug', slice.call(arguments));\n      return o;\n    };\n    o.info = function () {\n      log.write(name, 'info', slice.call(arguments));\n      return o;\n    };\n    o.warn = function () {\n      log.write(name, 'warn', slice.call(arguments));\n      return o;\n    };\n    o.error = function () {\n      log.write(name, 'error', slice.call(arguments));\n      return o;\n    };\n    o.log = o.debug; // for interface compliance with Node and browser consoles\n    o.suggest = exports.suggest;\n    o.format = log.format;\n    return o;\n  };\n\n  // filled in separately\n  exports.defaultBackend = exports.defaultFormatter = null;\n  exports.pipe = function (dest) {\n    return log.pipe(dest);\n  };\n  exports.end = exports.unpipe = exports.disable = function (from) {\n    return log.unpipe(from);\n  };\n  exports.Transform = Transform;\n  exports.Filter = Filter;\n  // this is the default filter that's applied when .enable() is called normally\n  // you can bypass it completely and set up your own pipes\n  exports.suggest = new Filter();\n  exports.enable = function () {\n    if (exports.defaultFormatter) {\n      return log.pipe(exports.suggest) // filter\n      .pipe(exports.defaultFormatter) // formatter\n      .pipe(exports.defaultBackend); // backend\n    }\n    return log.pipe(exports.suggest) // filter\n    .pipe(exports.defaultBackend); // formatter\n  };\n})(minilog$2, minilog$2.exports);\nvar minilogExports = minilog$2.exports;\n\nvar hex$1 = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue: '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color$2(fg, isInverse) {\n  if (isInverse) {\n    return 'color: #fff; background: ' + hex$1[fg] + ';';\n  } else {\n    return 'color: ' + hex$1[fg] + ';';\n  }\n}\nvar util = color$2;\n\nvar Transform$2 = transform$1,\n  color$1 = util;\nvar colors$1 = {\n    debug: ['cyan'],\n    info: ['purple'],\n    warn: ['yellow', true],\n    error: ['red', true]\n  },\n  logger$2 = new Transform$2();\nlogger$2.write = function (name, level, args) {\n  var fn = console.log;\n  if (console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger$2.pipe = function () {};\nvar color_1 = logger$2;\n\nvar Transform$1 = transform$1,\n  color = util,\n  colors = {\n    debug: ['gray'],\n    info: ['purple'],\n    warn: ['yellow', true],\n    error: ['red', true]\n  },\n  logger$1 = new Transform$1();\nlogger$1.write = function (name, level, args) {\n  var fn = console.log;\n  if (level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n  var i = 0;\n  if (level != 'info') {\n    for (; i < args.length; i++) {\n      if (typeof args[i] != 'string') break;\n    }\n    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));\n  } else {\n    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger$1.pipe = function () {};\nvar minilog$1 = logger$1;\n\nvar Transform = transform$1;\nvar newlines = /\\n+$/,\n  logger = new Transform();\nlogger.write = function (name, level, args) {\n  var i = args.length - 1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if (console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if (JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if (args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for (i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch (e) {}\n    console.log(args.join(' '));\n  }\n};\nlogger.formatters = ['color', 'minilog'];\nlogger.color = color_1;\nlogger.minilog = minilog$1;\nvar console_1 = logger;\n\nvar array$1;\nvar hasRequiredArray;\nfunction requireArray() {\n  if (hasRequiredArray) return array$1;\n  hasRequiredArray = 1;\n  var Transform = transform$1,\n    cache = [];\n  var logger = new Transform();\n  logger.write = function (name, level, args) {\n    cache.push([name, level, args]);\n  };\n\n  // utility functions\n  logger.get = function () {\n    return cache;\n  };\n  logger.empty = function () {\n    cache = [];\n  };\n  array$1 = logger;\n  return array$1;\n}\n\nvar localstorage;\nvar hasRequiredLocalstorage;\nfunction requireLocalstorage() {\n  if (hasRequiredLocalstorage) return localstorage;\n  hasRequiredLocalstorage = 1;\n  var Transform = transform$1,\n    cache = false;\n  var logger = new Transform();\n  logger.write = function (name, level, args) {\n    if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;\n    try {\n      if (!cache) {\n        cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];\n      }\n      cache.push([new Date().toString(), name, level, args]);\n      window.localStorage.minilog = JSON.stringify(cache);\n    } catch (e) {}\n  };\n  localstorage = logger;\n  return localstorage;\n}\n\nvar jquery_simple;\nvar hasRequiredJquery_simple;\nfunction requireJquery_simple() {\n  if (hasRequiredJquery_simple) return jquery_simple;\n  hasRequiredJquery_simple = 1;\n  var Transform = transform$1;\n  var cid = new Date().valueOf().toString(36);\n  function AjaxLogger(options) {\n    this.url = options.url || '';\n    this.cache = [];\n    this.timer = null;\n    this.interval = options.interval || 30 * 1000;\n    this.enabled = true;\n    this.jQuery = window.jQuery;\n    this.extras = {};\n  }\n  Transform.mixin(AjaxLogger);\n  AjaxLogger.prototype.write = function (name, level, args) {\n    if (!this.timer) {\n      this.init();\n    }\n    this.cache.push([name, level].concat(args));\n  };\n  AjaxLogger.prototype.init = function () {\n    if (!this.enabled || !this.jQuery) return;\n    var self = this;\n    this.timer = setTimeout(function () {\n      var i,\n        logs = [],\n        ajaxData,\n        url = self.url;\n      if (self.cache.length == 0) return self.init();\n      // Test each log line and only log the ones that are valid (e.g. don't have circular references).\n      // Slight performance hit but benefit is we log all valid lines.\n      for (i = 0; i < self.cache.length; i++) {\n        try {\n          JSON.stringify(self.cache[i]);\n          logs.push(self.cache[i]);\n        } catch (e) {}\n      }\n      if (self.jQuery.isEmptyObject(self.extras)) {\n        ajaxData = JSON.stringify({\n          logs: logs\n        });\n        url = self.url + '?client_id=' + cid;\n      } else {\n        ajaxData = JSON.stringify(self.jQuery.extend({\n          logs: logs\n        }, self.extras));\n      }\n      self.jQuery.ajax(url, {\n        type: 'POST',\n        cache: false,\n        processData: false,\n        data: ajaxData,\n        contentType: 'application/json',\n        timeout: 10000\n      }).success(function (data, status, jqxhr) {\n        if (data.interval) {\n          self.interval = Math.max(1000, data.interval);\n        }\n      }).error(function () {\n        self.interval = 30000;\n      }).always(function () {\n        self.init();\n      });\n      self.cache = [];\n    }, this.interval);\n  };\n  AjaxLogger.prototype.end = function () {};\n\n  // wait until jQuery is defined. Useful if you don't control the load order.\n  AjaxLogger.jQueryWait = function (onDone) {\n    if (typeof window !== 'undefined' && (window.jQuery || window.$)) {\n      return onDone(window.jQuery || window.$);\n    } else if (typeof window !== 'undefined') {\n      setTimeout(function () {\n        AjaxLogger.jQueryWait(onDone);\n      }, 200);\n    }\n  };\n  jquery_simple = AjaxLogger;\n  return jquery_simple;\n}\n\n(function (module, exports) {\n  var Minilog = minilogExports;\n  var oldEnable = Minilog.enable,\n    oldDisable = Minilog.disable,\n    isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),\n    console = console_1;\n\n  // Use a more capable logging backend if on Chrome\n  Minilog.defaultBackend = isChrome ? console.minilog : console;\n\n  // apply enable inputs from localStorage and from the URL\n  if (typeof window != 'undefined') {\n    try {\n      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));\n    } catch (e) {}\n    if (window.location && window.location.search) {\n      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);\n      match && Minilog.enable(decodeURIComponent(match[1]));\n    }\n  }\n\n  // Make enable also add to localStorage\n  Minilog.enable = function () {\n    oldEnable.call(Minilog, true);\n    try {\n      window.localStorage['minilogSettings'] = JSON.stringify(true);\n    } catch (e) {}\n    return this;\n  };\n  Minilog.disable = function () {\n    oldDisable.call(Minilog);\n    try {\n      delete window.localStorage.minilogSettings;\n    } catch (e) {}\n    return this;\n  };\n  exports = module.exports = Minilog;\n  exports.backends = {\n    array: requireArray(),\n    browser: Minilog.defaultBackend,\n    localStorage: requireLocalstorage(),\n    jQuery: requireJquery_simple()\n  };\n})(web, web.exports);\nvar webExports = web.exports;\n\nvar minilog = webExports;\nminilog.enable();\nvar log$3 = minilog('vm');\n\nvar log$2 = log$3;\nvar StringUtil$2 = /*#__PURE__*/function () {\n  function StringUtil() {\n    _classCallCheck(this, StringUtil);\n  }\n  return _createClass(StringUtil, null, [{\n    key: \"withoutTrailingDigits\",\n    value: function withoutTrailingDigits(s) {\n      var i = s.length - 1;\n      while (i >= 0 && '0123456789'.indexOf(s.charAt(i)) > -1) i--;\n      return s.slice(0, i + 1);\n    }\n  }, {\n    key: \"unusedName\",\n    value: function unusedName(name, existingNames) {\n      if (existingNames.indexOf(name) < 0) return name;\n      name = StringUtil.withoutTrailingDigits(name);\n      var i = 2;\n      while (existingNames.indexOf(name + i) >= 0) i++;\n      return name + i;\n    }\n\n    /**\n     * Split a string on the first occurrence of a split character.\n     * @param {string} text - the string to split.\n     * @param {string} separator - split the text on this character.\n     * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.\n     * @example\n     * // returns ['foo', 'tar.gz']\n     * splitFirst('foo.tar.gz', '.');\n     * @example\n     * // returns ['foo', null]\n     * splitFirst('foo', '.');\n     * @example\n     * // returns ['foo', '']\n     * splitFirst('foo.', '.');\n     */\n  }, {\n    key: \"splitFirst\",\n    value: function splitFirst(text, separator) {\n      var index = text.indexOf(separator);\n      if (index >= 0) {\n        return [text.substring(0, index), text.substring(index + 1)];\n      }\n      return [text, null];\n    }\n\n    /**\n     * A customized version of JSON.stringify that sets Infinity/NaN to 0,\n     * instead of the default (null).\n     * Needed because null is not of type number, but Infinity/NaN are, which\n     * can lead to serialization producing JSON that isn't valid based on the parser schema.\n     * It is also consistent with the behavior of saving 2.0 projects.\n     * This is only needed when stringifying an object for saving.\n     *\n     * @param {!object} obj - The object to serialize\n     * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0\n     */\n  }, {\n    key: \"stringify\",\n    value: function stringify(obj) {\n      return JSON.stringify(obj, function (_key, value) {\n        if (typeof value === 'number' && (value === Infinity || value === -Infinity || isNaN(value))) {\n          return 0;\n        }\n        return value;\n      });\n    }\n    /**\n     * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used\n     * in cases where we're replacing non-user facing strings (e.g. variable IDs).\n     * When replacing user facing strings, the xmlEscape utility function should be used\n     * instead so that the user facing string does not change how it displays.\n     * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.\n     * In some cases this argument may be an array (e.g. hacked inputs from 2.0)\n     * @return {string} String with control characters replaced.\n     */\n  }, {\n    key: \"replaceUnsafeChars\",\n    value: function replaceUnsafeChars(unsafe) {\n      if (typeof unsafe !== 'string') {\n        if (Array.isArray(unsafe)) {\n          // This happens when we have hacked blocks from 2.0\n          // See #1030\n          unsafe = String(unsafe);\n        } else {\n          log$2.error('Unexpected input recieved in replaceUnsafeChars');\n          return unsafe;\n        }\n      }\n      return unsafe.replace(/[<>&'\"]/g, function (c) {\n        switch (c) {\n          case '<':\n            return 'lt';\n          case '>':\n            return 'gt';\n          case '&':\n            return 'amp';\n          case '\\'':\n            return 'apos';\n          case '\"':\n            return 'quot';\n        }\n      });\n    }\n  }]);\n}();\nvar stringUtil = StringUtil$2;\n\nvar Clone$1 = /*#__PURE__*/function () {\n  function Clone() {\n    _classCallCheck(this, Clone);\n  }\n  return _createClass(Clone, null, [{\n    key: \"simple\",\n    value:\n    /**\n     * Deep-clone a \"simple\" object: one which can be fully expressed with JSON.\n     * Non-JSON values, such as functions, will be stripped from the clone.\n     * @param {object} original - the object to be cloned.\n     * @returns {object} a deep clone of the original object.\n     */\n    function simple(original) {\n      return JSON.parse(JSON.stringify(original));\n    }\n  }]);\n}();\nvar clone = Clone$1;\nvar Clone$2 = /*@__PURE__*/getDefaultExportFromCjs(clone);\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter$1() {\n  EventEmitter$1.init.call(this);\n}\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter$1.EventEmitter = EventEmitter$1;\n\nEventEmitter$1.usingDomains = false;\n\nEventEmitter$1.prototype.domain = undefined;\nEventEmitter$1.prototype._events = undefined;\nEventEmitter$1.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter$1.defaultMaxListeners = 10;\n\nEventEmitter$1.init = function() {\n  this.domain = null;\n  if (EventEmitter$1.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active ) ;\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter$1.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter$1.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter$1.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;\n\nEventEmitter$1.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter$1.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter$1.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter$1.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n    \n// Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\nEventEmitter$1.prototype.off = function(type, listener){\n    return this.removeListener(type, listener);\n};\n\nEventEmitter$1.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter$1.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter$1.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter$1.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter$1.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nvar _polyfillNode_events = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  EventEmitter: EventEmitter$1,\n  default: EventEmitter$1\n});\n\nvar require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);\n\nvar lib$2 = {exports: {}};\n\nvar require$$0$2 = {\n\t\"0\": 65533,\n\t\"128\": 8364,\n\t\"130\": 8218,\n\t\"131\": 402,\n\t\"132\": 8222,\n\t\"133\": 8230,\n\t\"134\": 8224,\n\t\"135\": 8225,\n\t\"136\": 710,\n\t\"137\": 8240,\n\t\"138\": 352,\n\t\"139\": 8249,\n\t\"140\": 338,\n\t\"142\": 381,\n\t\"145\": 8216,\n\t\"146\": 8217,\n\t\"147\": 8220,\n\t\"148\": 8221,\n\t\"149\": 8226,\n\t\"150\": 8211,\n\t\"151\": 8212,\n\t\"152\": 732,\n\t\"153\": 8482,\n\t\"154\": 353,\n\t\"155\": 8250,\n\t\"156\": 339,\n\t\"158\": 382,\n\t\"159\": 376\n};\n\nvar decodeMap = require$$0$2;\nvar decode_codepoint$1 = decodeCodePoint$1;\n\n// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nfunction decodeCodePoint$1(codePoint) {\n  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {\n    return \"\\uFFFD\";\n  }\n  if (codePoint in decodeMap) {\n    codePoint = decodeMap[codePoint];\n  }\n  var output = \"\";\n  if (codePoint > 0xffff) {\n    codePoint -= 0x10000;\n    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);\n    codePoint = 0xdc00 | codePoint & 0x3ff;\n  }\n  output += String.fromCharCode(codePoint);\n  return output;\n}\n\nvar Aacute$3 = \"Á\";\nvar aacute$3 = \"á\";\nvar Abreve$1 = \"Ă\";\nvar abreve$1 = \"ă\";\nvar ac$1 = \"∾\";\nvar acd$1 = \"∿\";\nvar acE$1 = \"∾̳\";\nvar Acirc$3 = \"Â\";\nvar acirc$3 = \"â\";\nvar acute$3 = \"´\";\nvar Acy$1 = \"А\";\nvar acy$1 = \"а\";\nvar AElig$3 = \"Æ\";\nvar aelig$3 = \"æ\";\nvar af$1 = \"⁡\";\nvar Afr$1 = \"𝔄\";\nvar afr$1 = \"𝔞\";\nvar Agrave$3 = \"À\";\nvar agrave$3 = \"à\";\nvar alefsym$1 = \"ℵ\";\nvar aleph$1 = \"ℵ\";\nvar Alpha$1 = \"Α\";\nvar alpha$1 = \"α\";\nvar Amacr$1 = \"Ā\";\nvar amacr$1 = \"ā\";\nvar amalg$1 = \"⨿\";\nvar amp$5 = \"&\";\nvar AMP$3 = \"&\";\nvar andand$1 = \"⩕\";\nvar And$1 = \"⩓\";\nvar and$1 = \"∧\";\nvar andd$1 = \"⩜\";\nvar andslope$1 = \"⩘\";\nvar andv$1 = \"⩚\";\nvar ang$1 = \"∠\";\nvar ange$1 = \"⦤\";\nvar angle$1 = \"∠\";\nvar angmsdaa$1 = \"⦨\";\nvar angmsdab$1 = \"⦩\";\nvar angmsdac$1 = \"⦪\";\nvar angmsdad$1 = \"⦫\";\nvar angmsdae$1 = \"⦬\";\nvar angmsdaf$1 = \"⦭\";\nvar angmsdag$1 = \"⦮\";\nvar angmsdah$1 = \"⦯\";\nvar angmsd$1 = \"∡\";\nvar angrt$1 = \"∟\";\nvar angrtvb$1 = \"⊾\";\nvar angrtvbd$1 = \"⦝\";\nvar angsph$1 = \"∢\";\nvar angst$1 = \"Å\";\nvar angzarr$1 = \"⍼\";\nvar Aogon$1 = \"Ą\";\nvar aogon$1 = \"ą\";\nvar Aopf$1 = \"𝔸\";\nvar aopf$1 = \"𝕒\";\nvar apacir$1 = \"⩯\";\nvar ap$1 = \"≈\";\nvar apE$1 = \"⩰\";\nvar ape$1 = \"≊\";\nvar apid$1 = \"≋\";\nvar apos$3 = \"'\";\nvar ApplyFunction$1 = \"⁡\";\nvar approx$1 = \"≈\";\nvar approxeq$1 = \"≊\";\nvar Aring$3 = \"Å\";\nvar aring$3 = \"å\";\nvar Ascr$1 = \"𝒜\";\nvar ascr$1 = \"𝒶\";\nvar Assign$1 = \"≔\";\nvar ast$1 = \"*\";\nvar asymp$1 = \"≈\";\nvar asympeq$1 = \"≍\";\nvar Atilde$3 = \"Ã\";\nvar atilde$3 = \"ã\";\nvar Auml$3 = \"Ä\";\nvar auml$3 = \"ä\";\nvar awconint$1 = \"∳\";\nvar awint$1 = \"⨑\";\nvar backcong$1 = \"≌\";\nvar backepsilon$1 = \"϶\";\nvar backprime$1 = \"‵\";\nvar backsim$1 = \"∽\";\nvar backsimeq$1 = \"⋍\";\nvar Backslash$1 = \"∖\";\nvar Barv$1 = \"⫧\";\nvar barvee$1 = \"⊽\";\nvar barwed$1 = \"⌅\";\nvar Barwed$1 = \"⌆\";\nvar barwedge$1 = \"⌅\";\nvar bbrk$1 = \"⎵\";\nvar bbrktbrk$1 = \"⎶\";\nvar bcong$1 = \"≌\";\nvar Bcy$1 = \"Б\";\nvar bcy$1 = \"б\";\nvar bdquo$1 = \"„\";\nvar becaus$1 = \"∵\";\nvar because$1 = \"∵\";\nvar Because$1 = \"∵\";\nvar bemptyv$1 = \"⦰\";\nvar bepsi$1 = \"϶\";\nvar bernou$1 = \"ℬ\";\nvar Bernoullis$1 = \"ℬ\";\nvar Beta$1 = \"Β\";\nvar beta$1 = \"β\";\nvar beth$1 = \"ℶ\";\nvar between$1 = \"≬\";\nvar Bfr$1 = \"𝔅\";\nvar bfr$1 = \"𝔟\";\nvar bigcap$1 = \"⋂\";\nvar bigcirc$1 = \"◯\";\nvar bigcup$1 = \"⋃\";\nvar bigodot$1 = \"⨀\";\nvar bigoplus$1 = \"⨁\";\nvar bigotimes$1 = \"⨂\";\nvar bigsqcup$1 = \"⨆\";\nvar bigstar$1 = \"★\";\nvar bigtriangledown$1 = \"▽\";\nvar bigtriangleup$1 = \"△\";\nvar biguplus$1 = \"⨄\";\nvar bigvee$1 = \"⋁\";\nvar bigwedge$1 = \"⋀\";\nvar bkarow$1 = \"⤍\";\nvar blacklozenge$1 = \"⧫\";\nvar blacksquare$1 = \"▪\";\nvar blacktriangle$1 = \"▴\";\nvar blacktriangledown$1 = \"▾\";\nvar blacktriangleleft$1 = \"◂\";\nvar blacktriangleright$1 = \"▸\";\nvar blank$1 = \"␣\";\nvar blk12$1 = \"▒\";\nvar blk14$1 = \"░\";\nvar blk34$1 = \"▓\";\nvar block$1 = \"█\";\nvar bne$1 = \"=⃥\";\nvar bnequiv$1 = \"≡⃥\";\nvar bNot$1 = \"⫭\";\nvar bnot$1 = \"⌐\";\nvar Bopf$1 = \"𝔹\";\nvar bopf$1 = \"𝕓\";\nvar bot$1 = \"⊥\";\nvar bottom$1 = \"⊥\";\nvar bowtie$1 = \"⋈\";\nvar boxbox$1 = \"⧉\";\nvar boxdl$1 = \"┐\";\nvar boxdL$1 = \"╕\";\nvar boxDl$1 = \"╖\";\nvar boxDL$1 = \"╗\";\nvar boxdr$1 = \"┌\";\nvar boxdR$1 = \"╒\";\nvar boxDr$1 = \"╓\";\nvar boxDR$1 = \"╔\";\nvar boxh$1 = \"─\";\nvar boxH$1 = \"═\";\nvar boxhd$1 = \"┬\";\nvar boxHd$1 = \"╤\";\nvar boxhD$1 = \"╥\";\nvar boxHD$1 = \"╦\";\nvar boxhu$1 = \"┴\";\nvar boxHu$1 = \"╧\";\nvar boxhU$1 = \"╨\";\nvar boxHU$1 = \"╩\";\nvar boxminus$1 = \"⊟\";\nvar boxplus$1 = \"⊞\";\nvar boxtimes$1 = \"⊠\";\nvar boxul$1 = \"┘\";\nvar boxuL$1 = \"╛\";\nvar boxUl$1 = \"╜\";\nvar boxUL$1 = \"╝\";\nvar boxur$1 = \"└\";\nvar boxuR$1 = \"╘\";\nvar boxUr$1 = \"╙\";\nvar boxUR$1 = \"╚\";\nvar boxv$1 = \"│\";\nvar boxV$1 = \"║\";\nvar boxvh$1 = \"┼\";\nvar boxvH$1 = \"╪\";\nvar boxVh$1 = \"╫\";\nvar boxVH$1 = \"╬\";\nvar boxvl$1 = \"┤\";\nvar boxvL$1 = \"╡\";\nvar boxVl$1 = \"╢\";\nvar boxVL$1 = \"╣\";\nvar boxvr$1 = \"├\";\nvar boxvR$1 = \"╞\";\nvar boxVr$1 = \"╟\";\nvar boxVR$1 = \"╠\";\nvar bprime$1 = \"‵\";\nvar breve$1 = \"˘\";\nvar Breve$1 = \"˘\";\nvar brvbar$3 = \"¦\";\nvar bscr$1 = \"𝒷\";\nvar Bscr$1 = \"ℬ\";\nvar bsemi$1 = \"⁏\";\nvar bsim$1 = \"∽\";\nvar bsime$1 = \"⋍\";\nvar bsolb$1 = \"⧅\";\nvar bsol$1 = \"\\\\\";\nvar bsolhsub$1 = \"⟈\";\nvar bull$1 = \"•\";\nvar bullet$1 = \"•\";\nvar bump$1 = \"≎\";\nvar bumpE$1 = \"⪮\";\nvar bumpe$1 = \"≏\";\nvar Bumpeq$1 = \"≎\";\nvar bumpeq$1 = \"≏\";\nvar Cacute$1 = \"Ć\";\nvar cacute$1 = \"ć\";\nvar capand$1 = \"⩄\";\nvar capbrcup$1 = \"⩉\";\nvar capcap$1 = \"⩋\";\nvar cap$1 = \"∩\";\nvar Cap$1 = \"⋒\";\nvar capcup$1 = \"⩇\";\nvar capdot$1 = \"⩀\";\nvar CapitalDifferentialD$1 = \"ⅅ\";\nvar caps$1 = \"∩︀\";\nvar caret$1 = \"⁁\";\nvar caron$1 = \"ˇ\";\nvar Cayleys$1 = \"ℭ\";\nvar ccaps$1 = \"⩍\";\nvar Ccaron$1 = \"Č\";\nvar ccaron$1 = \"č\";\nvar Ccedil$3 = \"Ç\";\nvar ccedil$3 = \"ç\";\nvar Ccirc$1 = \"Ĉ\";\nvar ccirc$1 = \"ĉ\";\nvar Cconint$1 = \"∰\";\nvar ccups$1 = \"⩌\";\nvar ccupssm$1 = \"⩐\";\nvar Cdot$1 = \"Ċ\";\nvar cdot$1 = \"ċ\";\nvar cedil$3 = \"¸\";\nvar Cedilla$1 = \"¸\";\nvar cemptyv$1 = \"⦲\";\nvar cent$3 = \"¢\";\nvar centerdot$1 = \"·\";\nvar CenterDot$1 = \"·\";\nvar cfr$1 = \"𝔠\";\nvar Cfr$1 = \"ℭ\";\nvar CHcy$1 = \"Ч\";\nvar chcy$1 = \"ч\";\nvar check$1 = \"✓\";\nvar checkmark$1 = \"✓\";\nvar Chi$1 = \"Χ\";\nvar chi$1 = \"χ\";\nvar circ$1 = \"ˆ\";\nvar circeq$1 = \"≗\";\nvar circlearrowleft$1 = \"↺\";\nvar circlearrowright$1 = \"↻\";\nvar circledast$1 = \"⊛\";\nvar circledcirc$1 = \"⊚\";\nvar circleddash$1 = \"⊝\";\nvar CircleDot$1 = \"⊙\";\nvar circledR$1 = \"®\";\nvar circledS$1 = \"Ⓢ\";\nvar CircleMinus$1 = \"⊖\";\nvar CirclePlus$1 = \"⊕\";\nvar CircleTimes$1 = \"⊗\";\nvar cir$1 = \"○\";\nvar cirE$1 = \"⧃\";\nvar cire$1 = \"≗\";\nvar cirfnint$1 = \"⨐\";\nvar cirmid$1 = \"⫯\";\nvar cirscir$1 = \"⧂\";\nvar ClockwiseContourIntegral$1 = \"∲\";\nvar CloseCurlyDoubleQuote$1 = \"”\";\nvar CloseCurlyQuote$1 = \"’\";\nvar clubs$1 = \"♣\";\nvar clubsuit$1 = \"♣\";\nvar colon$1 = \":\";\nvar Colon$1 = \"∷\";\nvar Colone$1 = \"⩴\";\nvar colone$1 = \"≔\";\nvar coloneq$1 = \"≔\";\nvar comma$1 = \",\";\nvar commat$1 = \"@\";\nvar comp$1 = \"∁\";\nvar compfn$1 = \"∘\";\nvar complement$1 = \"∁\";\nvar complexes$1 = \"ℂ\";\nvar cong$1 = \"≅\";\nvar congdot$1 = \"⩭\";\nvar Congruent$1 = \"≡\";\nvar conint$1 = \"∮\";\nvar Conint$1 = \"∯\";\nvar ContourIntegral$1 = \"∮\";\nvar copf$1 = \"𝕔\";\nvar Copf$1 = \"ℂ\";\nvar coprod$1 = \"∐\";\nvar Coproduct$1 = \"∐\";\nvar copy$3 = \"©\";\nvar COPY$3 = \"©\";\nvar copysr$1 = \"℗\";\nvar CounterClockwiseContourIntegral$1 = \"∳\";\nvar crarr$1 = \"↵\";\nvar cross$1 = \"✗\";\nvar Cross$1 = \"⨯\";\nvar Cscr$1 = \"𝒞\";\nvar cscr$1 = \"𝒸\";\nvar csub$1 = \"⫏\";\nvar csube$1 = \"⫑\";\nvar csup$1 = \"⫐\";\nvar csupe$1 = \"⫒\";\nvar ctdot$1 = \"⋯\";\nvar cudarrl$1 = \"⤸\";\nvar cudarrr$1 = \"⤵\";\nvar cuepr$1 = \"⋞\";\nvar cuesc$1 = \"⋟\";\nvar cularr$1 = \"↶\";\nvar cularrp$1 = \"⤽\";\nvar cupbrcap$1 = \"⩈\";\nvar cupcap$1 = \"⩆\";\nvar CupCap$1 = \"≍\";\nvar cup$1 = \"∪\";\nvar Cup$1 = \"⋓\";\nvar cupcup$1 = \"⩊\";\nvar cupdot$1 = \"⊍\";\nvar cupor$1 = \"⩅\";\nvar cups$1 = \"∪︀\";\nvar curarr$1 = \"↷\";\nvar curarrm$1 = \"⤼\";\nvar curlyeqprec$1 = \"⋞\";\nvar curlyeqsucc$1 = \"⋟\";\nvar curlyvee$1 = \"⋎\";\nvar curlywedge$1 = \"⋏\";\nvar curren$3 = \"¤\";\nvar curvearrowleft$1 = \"↶\";\nvar curvearrowright$1 = \"↷\";\nvar cuvee$1 = \"⋎\";\nvar cuwed$1 = \"⋏\";\nvar cwconint$1 = \"∲\";\nvar cwint$1 = \"∱\";\nvar cylcty$1 = \"⌭\";\nvar dagger$1 = \"†\";\nvar Dagger$1 = \"‡\";\nvar daleth$1 = \"ℸ\";\nvar darr$1 = \"↓\";\nvar Darr$1 = \"↡\";\nvar dArr$1 = \"⇓\";\nvar dash$1 = \"‐\";\nvar Dashv$1 = \"⫤\";\nvar dashv$1 = \"⊣\";\nvar dbkarow$1 = \"⤏\";\nvar dblac$1 = \"˝\";\nvar Dcaron$1 = \"Ď\";\nvar dcaron$1 = \"ď\";\nvar Dcy$1 = \"Д\";\nvar dcy$1 = \"д\";\nvar ddagger$1 = \"‡\";\nvar ddarr$1 = \"⇊\";\nvar DD$1 = \"ⅅ\";\nvar dd$1 = \"ⅆ\";\nvar DDotrahd$1 = \"⤑\";\nvar ddotseq$1 = \"⩷\";\nvar deg$3 = \"°\";\nvar Del$1 = \"∇\";\nvar Delta$1 = \"Δ\";\nvar delta$1 = \"δ\";\nvar demptyv$1 = \"⦱\";\nvar dfisht$1 = \"⥿\";\nvar Dfr$1 = \"𝔇\";\nvar dfr$1 = \"𝔡\";\nvar dHar$1 = \"⥥\";\nvar dharl$1 = \"⇃\";\nvar dharr$1 = \"⇂\";\nvar DiacriticalAcute$1 = \"´\";\nvar DiacriticalDot$1 = \"˙\";\nvar DiacriticalDoubleAcute$1 = \"˝\";\nvar DiacriticalGrave$1 = \"`\";\nvar DiacriticalTilde$1 = \"˜\";\nvar diam$1 = \"⋄\";\nvar diamond$1 = \"⋄\";\nvar Diamond$1 = \"⋄\";\nvar diamondsuit$1 = \"♦\";\nvar diams$1 = \"♦\";\nvar die$1 = \"¨\";\nvar DifferentialD$1 = \"ⅆ\";\nvar digamma$1 = \"ϝ\";\nvar disin$1 = \"⋲\";\nvar div$1 = \"÷\";\nvar divide$3 = \"÷\";\nvar divideontimes$1 = \"⋇\";\nvar divonx$1 = \"⋇\";\nvar DJcy$1 = \"Ђ\";\nvar djcy$1 = \"ђ\";\nvar dlcorn$1 = \"⌞\";\nvar dlcrop$1 = \"⌍\";\nvar dollar$1 = \"$\";\nvar Dopf$1 = \"𝔻\";\nvar dopf$1 = \"𝕕\";\nvar Dot$1 = \"¨\";\nvar dot$1 = \"˙\";\nvar DotDot$1 = \"⃜\";\nvar doteq$1 = \"≐\";\nvar doteqdot$1 = \"≑\";\nvar DotEqual$1 = \"≐\";\nvar dotminus$1 = \"∸\";\nvar dotplus$1 = \"∔\";\nvar dotsquare$1 = \"⊡\";\nvar doublebarwedge$1 = \"⌆\";\nvar DoubleContourIntegral$1 = \"∯\";\nvar DoubleDot$1 = \"¨\";\nvar DoubleDownArrow$1 = \"⇓\";\nvar DoubleLeftArrow$1 = \"⇐\";\nvar DoubleLeftRightArrow$1 = \"⇔\";\nvar DoubleLeftTee$1 = \"⫤\";\nvar DoubleLongLeftArrow$1 = \"⟸\";\nvar DoubleLongLeftRightArrow$1 = \"⟺\";\nvar DoubleLongRightArrow$1 = \"⟹\";\nvar DoubleRightArrow$1 = \"⇒\";\nvar DoubleRightTee$1 = \"⊨\";\nvar DoubleUpArrow$1 = \"⇑\";\nvar DoubleUpDownArrow$1 = \"⇕\";\nvar DoubleVerticalBar$1 = \"∥\";\nvar DownArrowBar$1 = \"⤓\";\nvar downarrow$1 = \"↓\";\nvar DownArrow$1 = \"↓\";\nvar Downarrow$1 = \"⇓\";\nvar DownArrowUpArrow$1 = \"⇵\";\nvar DownBreve$1 = \"̑\";\nvar downdownarrows$1 = \"⇊\";\nvar downharpoonleft$1 = \"⇃\";\nvar downharpoonright$1 = \"⇂\";\nvar DownLeftRightVector$1 = \"⥐\";\nvar DownLeftTeeVector$1 = \"⥞\";\nvar DownLeftVectorBar$1 = \"⥖\";\nvar DownLeftVector$1 = \"↽\";\nvar DownRightTeeVector$1 = \"⥟\";\nvar DownRightVectorBar$1 = \"⥗\";\nvar DownRightVector$1 = \"⇁\";\nvar DownTeeArrow$1 = \"↧\";\nvar DownTee$1 = \"⊤\";\nvar drbkarow$1 = \"⤐\";\nvar drcorn$1 = \"⌟\";\nvar drcrop$1 = \"⌌\";\nvar Dscr$1 = \"𝒟\";\nvar dscr$1 = \"𝒹\";\nvar DScy$1 = \"Ѕ\";\nvar dscy$1 = \"ѕ\";\nvar dsol$1 = \"⧶\";\nvar Dstrok$1 = \"Đ\";\nvar dstrok$1 = \"đ\";\nvar dtdot$1 = \"⋱\";\nvar dtri$1 = \"▿\";\nvar dtrif$1 = \"▾\";\nvar duarr$1 = \"⇵\";\nvar duhar$1 = \"⥯\";\nvar dwangle$1 = \"⦦\";\nvar DZcy$1 = \"Џ\";\nvar dzcy$1 = \"џ\";\nvar dzigrarr$1 = \"⟿\";\nvar Eacute$3 = \"É\";\nvar eacute$3 = \"é\";\nvar easter$1 = \"⩮\";\nvar Ecaron$1 = \"Ě\";\nvar ecaron$1 = \"ě\";\nvar Ecirc$3 = \"Ê\";\nvar ecirc$3 = \"ê\";\nvar ecir$1 = \"≖\";\nvar ecolon$1 = \"≕\";\nvar Ecy$1 = \"Э\";\nvar ecy$1 = \"э\";\nvar eDDot$1 = \"⩷\";\nvar Edot$1 = \"Ė\";\nvar edot$1 = \"ė\";\nvar eDot$1 = \"≑\";\nvar ee$1 = \"ⅇ\";\nvar efDot$1 = \"≒\";\nvar Efr$1 = \"𝔈\";\nvar efr$1 = \"𝔢\";\nvar eg$1 = \"⪚\";\nvar Egrave$3 = \"È\";\nvar egrave$3 = \"è\";\nvar egs$1 = \"⪖\";\nvar egsdot$1 = \"⪘\";\nvar el$1 = \"⪙\";\nvar Element$2 = \"∈\";\nvar elinters$1 = \"⏧\";\nvar ell$1 = \"ℓ\";\nvar els$1 = \"⪕\";\nvar elsdot$1 = \"⪗\";\nvar Emacr$1 = \"Ē\";\nvar emacr$1 = \"ē\";\nvar empty$1 = \"∅\";\nvar emptyset$1 = \"∅\";\nvar EmptySmallSquare$1 = \"◻\";\nvar emptyv$1 = \"∅\";\nvar EmptyVerySmallSquare$1 = \"▫\";\nvar emsp13$1 = \" \";\nvar emsp14$1 = \" \";\nvar emsp$1 = \" \";\nvar ENG$1 = \"Ŋ\";\nvar eng$1 = \"ŋ\";\nvar ensp$1 = \" \";\nvar Eogon$1 = \"Ę\";\nvar eogon$1 = \"ę\";\nvar Eopf$1 = \"𝔼\";\nvar eopf$1 = \"𝕖\";\nvar epar$1 = \"⋕\";\nvar eparsl$1 = \"⧣\";\nvar eplus$1 = \"⩱\";\nvar epsi$1 = \"ε\";\nvar Epsilon$1 = \"Ε\";\nvar epsilon$1 = \"ε\";\nvar epsiv$1 = \"ϵ\";\nvar eqcirc$1 = \"≖\";\nvar eqcolon$1 = \"≕\";\nvar eqsim$1 = \"≂\";\nvar eqslantgtr$1 = \"⪖\";\nvar eqslantless$1 = \"⪕\";\nvar Equal$1 = \"⩵\";\nvar equals$1 = \"=\";\nvar EqualTilde$1 = \"≂\";\nvar equest$1 = \"≟\";\nvar Equilibrium$1 = \"⇌\";\nvar equiv$1 = \"≡\";\nvar equivDD$1 = \"⩸\";\nvar eqvparsl$1 = \"⧥\";\nvar erarr$1 = \"⥱\";\nvar erDot$1 = \"≓\";\nvar escr$1 = \"ℯ\";\nvar Escr$1 = \"ℰ\";\nvar esdot$1 = \"≐\";\nvar Esim$1 = \"⩳\";\nvar esim$1 = \"≂\";\nvar Eta$1 = \"Η\";\nvar eta$1 = \"η\";\nvar ETH$3 = \"Ð\";\nvar eth$3 = \"ð\";\nvar Euml$3 = \"Ë\";\nvar euml$3 = \"ë\";\nvar euro$1 = \"€\";\nvar excl$1 = \"!\";\nvar exist$1 = \"∃\";\nvar Exists$1 = \"∃\";\nvar expectation$1 = \"ℰ\";\nvar exponentiale$1 = \"ⅇ\";\nvar ExponentialE$1 = \"ⅇ\";\nvar fallingdotseq$1 = \"≒\";\nvar Fcy$1 = \"Ф\";\nvar fcy$1 = \"ф\";\nvar female$1 = \"♀\";\nvar ffilig$1 = \"ﬃ\";\nvar fflig$1 = \"ﬀ\";\nvar ffllig$1 = \"ﬄ\";\nvar Ffr$1 = \"𝔉\";\nvar ffr$1 = \"𝔣\";\nvar filig$1 = \"ﬁ\";\nvar FilledSmallSquare$1 = \"◼\";\nvar FilledVerySmallSquare$1 = \"▪\";\nvar fjlig$1 = \"fj\";\nvar flat$1 = \"♭\";\nvar fllig$1 = \"ﬂ\";\nvar fltns$1 = \"▱\";\nvar fnof$1 = \"ƒ\";\nvar Fopf$1 = \"𝔽\";\nvar fopf$1 = \"𝕗\";\nvar forall$1 = \"∀\";\nvar ForAll$1 = \"∀\";\nvar fork$1 = \"⋔\";\nvar forkv$1 = \"⫙\";\nvar Fouriertrf$1 = \"ℱ\";\nvar fpartint$1 = \"⨍\";\nvar frac12$3 = \"½\";\nvar frac13$1 = \"⅓\";\nvar frac14$3 = \"¼\";\nvar frac15$1 = \"⅕\";\nvar frac16$1 = \"⅙\";\nvar frac18$1 = \"⅛\";\nvar frac23$1 = \"⅔\";\nvar frac25$1 = \"⅖\";\nvar frac34$3 = \"¾\";\nvar frac35$1 = \"⅗\";\nvar frac38$1 = \"⅜\";\nvar frac45$1 = \"⅘\";\nvar frac56$1 = \"⅚\";\nvar frac58$1 = \"⅝\";\nvar frac78$1 = \"⅞\";\nvar frasl$1 = \"⁄\";\nvar frown$1 = \"⌢\";\nvar fscr$1 = \"𝒻\";\nvar Fscr$1 = \"ℱ\";\nvar gacute$1 = \"ǵ\";\nvar Gamma$1 = \"Γ\";\nvar gamma$1 = \"γ\";\nvar Gammad$1 = \"Ϝ\";\nvar gammad$1 = \"ϝ\";\nvar gap$1 = \"⪆\";\nvar Gbreve$1 = \"Ğ\";\nvar gbreve$1 = \"ğ\";\nvar Gcedil$1 = \"Ģ\";\nvar Gcirc$1 = \"Ĝ\";\nvar gcirc$1 = \"ĝ\";\nvar Gcy$1 = \"Г\";\nvar gcy$1 = \"г\";\nvar Gdot$1 = \"Ġ\";\nvar gdot$1 = \"ġ\";\nvar ge$1 = \"≥\";\nvar gE$1 = \"≧\";\nvar gEl$1 = \"⪌\";\nvar gel$1 = \"⋛\";\nvar geq$1 = \"≥\";\nvar geqq$1 = \"≧\";\nvar geqslant$1 = \"⩾\";\nvar gescc$1 = \"⪩\";\nvar ges$1 = \"⩾\";\nvar gesdot$1 = \"⪀\";\nvar gesdoto$1 = \"⪂\";\nvar gesdotol$1 = \"⪄\";\nvar gesl$1 = \"⋛︀\";\nvar gesles$1 = \"⪔\";\nvar Gfr$1 = \"𝔊\";\nvar gfr$1 = \"𝔤\";\nvar gg$1 = \"≫\";\nvar Gg$1 = \"⋙\";\nvar ggg$1 = \"⋙\";\nvar gimel$1 = \"ℷ\";\nvar GJcy$1 = \"Ѓ\";\nvar gjcy$1 = \"ѓ\";\nvar gla$1 = \"⪥\";\nvar gl$1 = \"≷\";\nvar glE$1 = \"⪒\";\nvar glj$1 = \"⪤\";\nvar gnap$1 = \"⪊\";\nvar gnapprox$1 = \"⪊\";\nvar gne$1 = \"⪈\";\nvar gnE$1 = \"≩\";\nvar gneq$1 = \"⪈\";\nvar gneqq$1 = \"≩\";\nvar gnsim$1 = \"⋧\";\nvar Gopf$1 = \"𝔾\";\nvar gopf$1 = \"𝕘\";\nvar grave$1 = \"`\";\nvar GreaterEqual$1 = \"≥\";\nvar GreaterEqualLess$1 = \"⋛\";\nvar GreaterFullEqual$1 = \"≧\";\nvar GreaterGreater$1 = \"⪢\";\nvar GreaterLess$1 = \"≷\";\nvar GreaterSlantEqual$1 = \"⩾\";\nvar GreaterTilde$1 = \"≳\";\nvar Gscr$1 = \"𝒢\";\nvar gscr$1 = \"ℊ\";\nvar gsim$1 = \"≳\";\nvar gsime$1 = \"⪎\";\nvar gsiml$1 = \"⪐\";\nvar gtcc$1 = \"⪧\";\nvar gtcir$1 = \"⩺\";\nvar gt$5 = \">\";\nvar GT$3 = \">\";\nvar Gt$1 = \"≫\";\nvar gtdot$1 = \"⋗\";\nvar gtlPar$1 = \"⦕\";\nvar gtquest$1 = \"⩼\";\nvar gtrapprox$1 = \"⪆\";\nvar gtrarr$1 = \"⥸\";\nvar gtrdot$1 = \"⋗\";\nvar gtreqless$1 = \"⋛\";\nvar gtreqqless$1 = \"⪌\";\nvar gtrless$1 = \"≷\";\nvar gtrsim$1 = \"≳\";\nvar gvertneqq$1 = \"≩︀\";\nvar gvnE$1 = \"≩︀\";\nvar Hacek$1 = \"ˇ\";\nvar hairsp$1 = \" \";\nvar half$1 = \"½\";\nvar hamilt$1 = \"ℋ\";\nvar HARDcy$1 = \"Ъ\";\nvar hardcy$1 = \"ъ\";\nvar harrcir$1 = \"⥈\";\nvar harr$1 = \"↔\";\nvar hArr$1 = \"⇔\";\nvar harrw$1 = \"↭\";\nvar Hat$1 = \"^\";\nvar hbar$1 = \"ℏ\";\nvar Hcirc$1 = \"Ĥ\";\nvar hcirc$1 = \"ĥ\";\nvar hearts$1 = \"♥\";\nvar heartsuit$1 = \"♥\";\nvar hellip$1 = \"…\";\nvar hercon$1 = \"⊹\";\nvar hfr$1 = \"𝔥\";\nvar Hfr$1 = \"ℌ\";\nvar HilbertSpace$1 = \"ℋ\";\nvar hksearow$1 = \"⤥\";\nvar hkswarow$1 = \"⤦\";\nvar hoarr$1 = \"⇿\";\nvar homtht$1 = \"∻\";\nvar hookleftarrow$1 = \"↩\";\nvar hookrightarrow$1 = \"↪\";\nvar hopf$1 = \"𝕙\";\nvar Hopf$1 = \"ℍ\";\nvar horbar$1 = \"―\";\nvar HorizontalLine$1 = \"─\";\nvar hscr$1 = \"𝒽\";\nvar Hscr$1 = \"ℋ\";\nvar hslash$1 = \"ℏ\";\nvar Hstrok$1 = \"Ħ\";\nvar hstrok$1 = \"ħ\";\nvar HumpDownHump$1 = \"≎\";\nvar HumpEqual$1 = \"≏\";\nvar hybull$1 = \"⁃\";\nvar hyphen$1 = \"‐\";\nvar Iacute$3 = \"Í\";\nvar iacute$3 = \"í\";\nvar ic$1 = \"⁣\";\nvar Icirc$3 = \"Î\";\nvar icirc$3 = \"î\";\nvar Icy$1 = \"И\";\nvar icy$1 = \"и\";\nvar Idot$1 = \"İ\";\nvar IEcy$1 = \"Е\";\nvar iecy$1 = \"е\";\nvar iexcl$3 = \"¡\";\nvar iff$1 = \"⇔\";\nvar ifr$1 = \"𝔦\";\nvar Ifr$1 = \"ℑ\";\nvar Igrave$3 = \"Ì\";\nvar igrave$3 = \"ì\";\nvar ii$1 = \"ⅈ\";\nvar iiiint$1 = \"⨌\";\nvar iiint$1 = \"∭\";\nvar iinfin$1 = \"⧜\";\nvar iiota$1 = \"℩\";\nvar IJlig$1 = \"Ĳ\";\nvar ijlig$1 = \"ĳ\";\nvar Imacr$1 = \"Ī\";\nvar imacr$1 = \"ī\";\nvar image$1 = \"ℑ\";\nvar ImaginaryI$1 = \"ⅈ\";\nvar imagline$1 = \"ℐ\";\nvar imagpart$1 = \"ℑ\";\nvar imath$1 = \"ı\";\nvar Im$1 = \"ℑ\";\nvar imof$1 = \"⊷\";\nvar imped$1 = \"Ƶ\";\nvar Implies$1 = \"⇒\";\nvar incare$1 = \"℅\";\nvar infin$1 = \"∞\";\nvar infintie$1 = \"⧝\";\nvar inodot$1 = \"ı\";\nvar intcal$1 = \"⊺\";\nvar int$1 = \"∫\";\nvar Int$1 = \"∬\";\nvar integers$1 = \"ℤ\";\nvar Integral$1 = \"∫\";\nvar intercal$1 = \"⊺\";\nvar Intersection$1 = \"⋂\";\nvar intlarhk$1 = \"⨗\";\nvar intprod$1 = \"⨼\";\nvar InvisibleComma$1 = \"⁣\";\nvar InvisibleTimes$1 = \"⁢\";\nvar IOcy$1 = \"Ё\";\nvar iocy$1 = \"ё\";\nvar Iogon$1 = \"Į\";\nvar iogon$1 = \"į\";\nvar Iopf$1 = \"𝕀\";\nvar iopf$1 = \"𝕚\";\nvar Iota$1 = \"Ι\";\nvar iota$1 = \"ι\";\nvar iprod$1 = \"⨼\";\nvar iquest$3 = \"¿\";\nvar iscr$1 = \"𝒾\";\nvar Iscr$1 = \"ℐ\";\nvar isin$1 = \"∈\";\nvar isindot$1 = \"⋵\";\nvar isinE$1 = \"⋹\";\nvar isins$1 = \"⋴\";\nvar isinsv$1 = \"⋳\";\nvar isinv$1 = \"∈\";\nvar it$1 = \"⁢\";\nvar Itilde$1 = \"Ĩ\";\nvar itilde$1 = \"ĩ\";\nvar Iukcy$1 = \"І\";\nvar iukcy$1 = \"і\";\nvar Iuml$3 = \"Ï\";\nvar iuml$3 = \"ï\";\nvar Jcirc$1 = \"Ĵ\";\nvar jcirc$1 = \"ĵ\";\nvar Jcy$1 = \"Й\";\nvar jcy$1 = \"й\";\nvar Jfr$1 = \"𝔍\";\nvar jfr$1 = \"𝔧\";\nvar jmath$1 = \"ȷ\";\nvar Jopf$1 = \"𝕁\";\nvar jopf$1 = \"𝕛\";\nvar Jscr$1 = \"𝒥\";\nvar jscr$1 = \"𝒿\";\nvar Jsercy$1 = \"Ј\";\nvar jsercy$1 = \"ј\";\nvar Jukcy$1 = \"Є\";\nvar jukcy$1 = \"є\";\nvar Kappa$1 = \"Κ\";\nvar kappa$1 = \"κ\";\nvar kappav$1 = \"ϰ\";\nvar Kcedil$1 = \"Ķ\";\nvar kcedil$1 = \"ķ\";\nvar Kcy$1 = \"К\";\nvar kcy$1 = \"к\";\nvar Kfr$1 = \"𝔎\";\nvar kfr$1 = \"𝔨\";\nvar kgreen$1 = \"ĸ\";\nvar KHcy$1 = \"Х\";\nvar khcy$1 = \"х\";\nvar KJcy$1 = \"Ќ\";\nvar kjcy$1 = \"ќ\";\nvar Kopf$1 = \"𝕂\";\nvar kopf$1 = \"𝕜\";\nvar Kscr$1 = \"𝒦\";\nvar kscr$1 = \"𝓀\";\nvar lAarr$1 = \"⇚\";\nvar Lacute$1 = \"Ĺ\";\nvar lacute$1 = \"ĺ\";\nvar laemptyv$1 = \"⦴\";\nvar lagran$1 = \"ℒ\";\nvar Lambda$1 = \"Λ\";\nvar lambda$1 = \"λ\";\nvar lang$1 = \"⟨\";\nvar Lang$1 = \"⟪\";\nvar langd$1 = \"⦑\";\nvar langle$1 = \"⟨\";\nvar lap$1 = \"⪅\";\nvar Laplacetrf$1 = \"ℒ\";\nvar laquo$3 = \"«\";\nvar larrb$1 = \"⇤\";\nvar larrbfs$1 = \"⤟\";\nvar larr$1 = \"←\";\nvar Larr$1 = \"↞\";\nvar lArr$1 = \"⇐\";\nvar larrfs$1 = \"⤝\";\nvar larrhk$1 = \"↩\";\nvar larrlp$1 = \"↫\";\nvar larrpl$1 = \"⤹\";\nvar larrsim$1 = \"⥳\";\nvar larrtl$1 = \"↢\";\nvar latail$1 = \"⤙\";\nvar lAtail$1 = \"⤛\";\nvar lat$1 = \"⪫\";\nvar late$1 = \"⪭\";\nvar lates$1 = \"⪭︀\";\nvar lbarr$1 = \"⤌\";\nvar lBarr$1 = \"⤎\";\nvar lbbrk$1 = \"❲\";\nvar lbrace$1 = \"{\";\nvar lbrack$1 = \"[\";\nvar lbrke$1 = \"⦋\";\nvar lbrksld$1 = \"⦏\";\nvar lbrkslu$1 = \"⦍\";\nvar Lcaron$1 = \"Ľ\";\nvar lcaron$1 = \"ľ\";\nvar Lcedil$1 = \"Ļ\";\nvar lcedil$1 = \"ļ\";\nvar lceil$1 = \"⌈\";\nvar lcub$1 = \"{\";\nvar Lcy$1 = \"Л\";\nvar lcy$1 = \"л\";\nvar ldca$1 = \"⤶\";\nvar ldquo$1 = \"“\";\nvar ldquor$1 = \"„\";\nvar ldrdhar$1 = \"⥧\";\nvar ldrushar$1 = \"⥋\";\nvar ldsh$1 = \"↲\";\nvar le$1 = \"≤\";\nvar lE$1 = \"≦\";\nvar LeftAngleBracket$1 = \"⟨\";\nvar LeftArrowBar$1 = \"⇤\";\nvar leftarrow$1 = \"←\";\nvar LeftArrow$1 = \"←\";\nvar Leftarrow$1 = \"⇐\";\nvar LeftArrowRightArrow$1 = \"⇆\";\nvar leftarrowtail$1 = \"↢\";\nvar LeftCeiling$1 = \"⌈\";\nvar LeftDoubleBracket$1 = \"⟦\";\nvar LeftDownTeeVector$1 = \"⥡\";\nvar LeftDownVectorBar$1 = \"⥙\";\nvar LeftDownVector$1 = \"⇃\";\nvar LeftFloor$1 = \"⌊\";\nvar leftharpoondown$1 = \"↽\";\nvar leftharpoonup$1 = \"↼\";\nvar leftleftarrows$1 = \"⇇\";\nvar leftrightarrow$1 = \"↔\";\nvar LeftRightArrow$1 = \"↔\";\nvar Leftrightarrow$1 = \"⇔\";\nvar leftrightarrows$1 = \"⇆\";\nvar leftrightharpoons$1 = \"⇋\";\nvar leftrightsquigarrow$1 = \"↭\";\nvar LeftRightVector$1 = \"⥎\";\nvar LeftTeeArrow$1 = \"↤\";\nvar LeftTee$1 = \"⊣\";\nvar LeftTeeVector$1 = \"⥚\";\nvar leftthreetimes$1 = \"⋋\";\nvar LeftTriangleBar$1 = \"⧏\";\nvar LeftTriangle$1 = \"⊲\";\nvar LeftTriangleEqual$1 = \"⊴\";\nvar LeftUpDownVector$1 = \"⥑\";\nvar LeftUpTeeVector$1 = \"⥠\";\nvar LeftUpVectorBar$1 = \"⥘\";\nvar LeftUpVector$1 = \"↿\";\nvar LeftVectorBar$1 = \"⥒\";\nvar LeftVector$1 = \"↼\";\nvar lEg$1 = \"⪋\";\nvar leg$1 = \"⋚\";\nvar leq$1 = \"≤\";\nvar leqq$1 = \"≦\";\nvar leqslant$1 = \"⩽\";\nvar lescc$1 = \"⪨\";\nvar les$1 = \"⩽\";\nvar lesdot$1 = \"⩿\";\nvar lesdoto$1 = \"⪁\";\nvar lesdotor$1 = \"⪃\";\nvar lesg$1 = \"⋚︀\";\nvar lesges$1 = \"⪓\";\nvar lessapprox$1 = \"⪅\";\nvar lessdot$1 = \"⋖\";\nvar lesseqgtr$1 = \"⋚\";\nvar lesseqqgtr$1 = \"⪋\";\nvar LessEqualGreater$1 = \"⋚\";\nvar LessFullEqual$1 = \"≦\";\nvar LessGreater$1 = \"≶\";\nvar lessgtr$1 = \"≶\";\nvar LessLess$1 = \"⪡\";\nvar lesssim$1 = \"≲\";\nvar LessSlantEqual$1 = \"⩽\";\nvar LessTilde$1 = \"≲\";\nvar lfisht$1 = \"⥼\";\nvar lfloor$1 = \"⌊\";\nvar Lfr$1 = \"𝔏\";\nvar lfr$1 = \"𝔩\";\nvar lg$1 = \"≶\";\nvar lgE$1 = \"⪑\";\nvar lHar$1 = \"⥢\";\nvar lhard$1 = \"↽\";\nvar lharu$1 = \"↼\";\nvar lharul$1 = \"⥪\";\nvar lhblk$1 = \"▄\";\nvar LJcy$1 = \"Љ\";\nvar ljcy$1 = \"љ\";\nvar llarr$1 = \"⇇\";\nvar ll$1 = \"≪\";\nvar Ll$1 = \"⋘\";\nvar llcorner$1 = \"⌞\";\nvar Lleftarrow$1 = \"⇚\";\nvar llhard$1 = \"⥫\";\nvar lltri$1 = \"◺\";\nvar Lmidot$1 = \"Ŀ\";\nvar lmidot$1 = \"ŀ\";\nvar lmoustache$1 = \"⎰\";\nvar lmoust$1 = \"⎰\";\nvar lnap$1 = \"⪉\";\nvar lnapprox$1 = \"⪉\";\nvar lne$1 = \"⪇\";\nvar lnE$1 = \"≨\";\nvar lneq$1 = \"⪇\";\nvar lneqq$1 = \"≨\";\nvar lnsim$1 = \"⋦\";\nvar loang$1 = \"⟬\";\nvar loarr$1 = \"⇽\";\nvar lobrk$1 = \"⟦\";\nvar longleftarrow$1 = \"⟵\";\nvar LongLeftArrow$1 = \"⟵\";\nvar Longleftarrow$1 = \"⟸\";\nvar longleftrightarrow$1 = \"⟷\";\nvar LongLeftRightArrow$1 = \"⟷\";\nvar Longleftrightarrow$1 = \"⟺\";\nvar longmapsto$1 = \"⟼\";\nvar longrightarrow$1 = \"⟶\";\nvar LongRightArrow$1 = \"⟶\";\nvar Longrightarrow$1 = \"⟹\";\nvar looparrowleft$1 = \"↫\";\nvar looparrowright$1 = \"↬\";\nvar lopar$1 = \"⦅\";\nvar Lopf$1 = \"𝕃\";\nvar lopf$1 = \"𝕝\";\nvar loplus$1 = \"⨭\";\nvar lotimes$1 = \"⨴\";\nvar lowast$1 = \"∗\";\nvar lowbar$1 = \"_\";\nvar LowerLeftArrow$1 = \"↙\";\nvar LowerRightArrow$1 = \"↘\";\nvar loz$1 = \"◊\";\nvar lozenge$1 = \"◊\";\nvar lozf$1 = \"⧫\";\nvar lpar$1 = \"(\";\nvar lparlt$1 = \"⦓\";\nvar lrarr$1 = \"⇆\";\nvar lrcorner$1 = \"⌟\";\nvar lrhar$1 = \"⇋\";\nvar lrhard$1 = \"⥭\";\nvar lrm$1 = \"‎\";\nvar lrtri$1 = \"⊿\";\nvar lsaquo$1 = \"‹\";\nvar lscr$1 = \"𝓁\";\nvar Lscr$1 = \"ℒ\";\nvar lsh$1 = \"↰\";\nvar Lsh$1 = \"↰\";\nvar lsim$1 = \"≲\";\nvar lsime$1 = \"⪍\";\nvar lsimg$1 = \"⪏\";\nvar lsqb$1 = \"[\";\nvar lsquo$1 = \"‘\";\nvar lsquor$1 = \"‚\";\nvar Lstrok$1 = \"Ł\";\nvar lstrok$1 = \"ł\";\nvar ltcc$1 = \"⪦\";\nvar ltcir$1 = \"⩹\";\nvar lt$5 = \"<\";\nvar LT$3 = \"<\";\nvar Lt$1 = \"≪\";\nvar ltdot$1 = \"⋖\";\nvar lthree$1 = \"⋋\";\nvar ltimes$1 = \"⋉\";\nvar ltlarr$1 = \"⥶\";\nvar ltquest$1 = \"⩻\";\nvar ltri$1 = \"◃\";\nvar ltrie$1 = \"⊴\";\nvar ltrif$1 = \"◂\";\nvar ltrPar$1 = \"⦖\";\nvar lurdshar$1 = \"⥊\";\nvar luruhar$1 = \"⥦\";\nvar lvertneqq$1 = \"≨︀\";\nvar lvnE$1 = \"≨︀\";\nvar macr$3 = \"¯\";\nvar male$1 = \"♂\";\nvar malt$1 = \"✠\";\nvar maltese$1 = \"✠\";\nvar map$2 = \"↦\";\nvar mapsto$1 = \"↦\";\nvar mapstodown$1 = \"↧\";\nvar mapstoleft$1 = \"↤\";\nvar mapstoup$1 = \"↥\";\nvar marker$1 = \"▮\";\nvar mcomma$1 = \"⨩\";\nvar Mcy$1 = \"М\";\nvar mcy$1 = \"м\";\nvar mdash$1 = \"—\";\nvar mDDot$1 = \"∺\";\nvar measuredangle$1 = \"∡\";\nvar MediumSpace$1 = \" \";\nvar Mellintrf$1 = \"ℳ\";\nvar Mfr$1 = \"𝔐\";\nvar mfr$1 = \"𝔪\";\nvar mho$1 = \"℧\";\nvar micro$3 = \"µ\";\nvar midast$1 = \"*\";\nvar midcir$1 = \"⫰\";\nvar mid$1 = \"∣\";\nvar middot$3 = \"·\";\nvar minusb$1 = \"⊟\";\nvar minus$1 = \"−\";\nvar minusd$1 = \"∸\";\nvar minusdu$1 = \"⨪\";\nvar MinusPlus$1 = \"∓\";\nvar mlcp$1 = \"⫛\";\nvar mldr$1 = \"…\";\nvar mnplus$1 = \"∓\";\nvar models$1 = \"⊧\";\nvar Mopf$1 = \"𝕄\";\nvar mopf$1 = \"𝕞\";\nvar mp$1 = \"∓\";\nvar mscr$1 = \"𝓂\";\nvar Mscr$1 = \"ℳ\";\nvar mstpos$1 = \"∾\";\nvar Mu$1 = \"Μ\";\nvar mu$1 = \"μ\";\nvar multimap$1 = \"⊸\";\nvar mumap$1 = \"⊸\";\nvar nabla$1 = \"∇\";\nvar Nacute$1 = \"Ń\";\nvar nacute$1 = \"ń\";\nvar nang$1 = \"∠⃒\";\nvar nap$1 = \"≉\";\nvar napE$1 = \"⩰̸\";\nvar napid$1 = \"≋̸\";\nvar napos$1 = \"ŉ\";\nvar napprox$1 = \"≉\";\nvar natural$1 = \"♮\";\nvar naturals$1 = \"ℕ\";\nvar natur$1 = \"♮\";\nvar nbsp$3 = \" \";\nvar nbump$1 = \"≎̸\";\nvar nbumpe$1 = \"≏̸\";\nvar ncap$1 = \"⩃\";\nvar Ncaron$1 = \"Ň\";\nvar ncaron$1 = \"ň\";\nvar Ncedil$1 = \"Ņ\";\nvar ncedil$1 = \"ņ\";\nvar ncong$1 = \"≇\";\nvar ncongdot$1 = \"⩭̸\";\nvar ncup$1 = \"⩂\";\nvar Ncy$1 = \"Н\";\nvar ncy$1 = \"н\";\nvar ndash$1 = \"–\";\nvar nearhk$1 = \"⤤\";\nvar nearr$1 = \"↗\";\nvar neArr$1 = \"⇗\";\nvar nearrow$1 = \"↗\";\nvar ne$1 = \"≠\";\nvar nedot$1 = \"≐̸\";\nvar NegativeMediumSpace$1 = \"​\";\nvar NegativeThickSpace$1 = \"​\";\nvar NegativeThinSpace$1 = \"​\";\nvar NegativeVeryThinSpace$1 = \"​\";\nvar nequiv$1 = \"≢\";\nvar nesear$1 = \"⤨\";\nvar nesim$1 = \"≂̸\";\nvar NestedGreaterGreater$1 = \"≫\";\nvar NestedLessLess$1 = \"≪\";\nvar NewLine$1 = \"\\n\";\nvar nexist$1 = \"∄\";\nvar nexists$1 = \"∄\";\nvar Nfr$1 = \"𝔑\";\nvar nfr$1 = \"𝔫\";\nvar ngE$1 = \"≧̸\";\nvar nge$1 = \"≱\";\nvar ngeq$1 = \"≱\";\nvar ngeqq$1 = \"≧̸\";\nvar ngeqslant$1 = \"⩾̸\";\nvar nges$1 = \"⩾̸\";\nvar nGg$1 = \"⋙̸\";\nvar ngsim$1 = \"≵\";\nvar nGt$1 = \"≫⃒\";\nvar ngt$1 = \"≯\";\nvar ngtr$1 = \"≯\";\nvar nGtv$1 = \"≫̸\";\nvar nharr$1 = \"↮\";\nvar nhArr$1 = \"⇎\";\nvar nhpar$1 = \"⫲\";\nvar ni$1 = \"∋\";\nvar nis$1 = \"⋼\";\nvar nisd$1 = \"⋺\";\nvar niv$1 = \"∋\";\nvar NJcy$1 = \"Њ\";\nvar njcy$1 = \"њ\";\nvar nlarr$1 = \"↚\";\nvar nlArr$1 = \"⇍\";\nvar nldr$1 = \"‥\";\nvar nlE$1 = \"≦̸\";\nvar nle$1 = \"≰\";\nvar nleftarrow$1 = \"↚\";\nvar nLeftarrow$1 = \"⇍\";\nvar nleftrightarrow$1 = \"↮\";\nvar nLeftrightarrow$1 = \"⇎\";\nvar nleq$1 = \"≰\";\nvar nleqq$1 = \"≦̸\";\nvar nleqslant$1 = \"⩽̸\";\nvar nles$1 = \"⩽̸\";\nvar nless$1 = \"≮\";\nvar nLl$1 = \"⋘̸\";\nvar nlsim$1 = \"≴\";\nvar nLt$1 = \"≪⃒\";\nvar nlt$1 = \"≮\";\nvar nltri$1 = \"⋪\";\nvar nltrie$1 = \"⋬\";\nvar nLtv$1 = \"≪̸\";\nvar nmid$1 = \"∤\";\nvar NoBreak$1 = \"⁠\";\nvar NonBreakingSpace$1 = \" \";\nvar nopf$1 = \"𝕟\";\nvar Nopf$1 = \"ℕ\";\nvar Not$1 = \"⫬\";\nvar not$3 = \"¬\";\nvar NotCongruent$1 = \"≢\";\nvar NotCupCap$1 = \"≭\";\nvar NotDoubleVerticalBar$1 = \"∦\";\nvar NotElement$1 = \"∉\";\nvar NotEqual$1 = \"≠\";\nvar NotEqualTilde$1 = \"≂̸\";\nvar NotExists$1 = \"∄\";\nvar NotGreater$1 = \"≯\";\nvar NotGreaterEqual$1 = \"≱\";\nvar NotGreaterFullEqual$1 = \"≧̸\";\nvar NotGreaterGreater$1 = \"≫̸\";\nvar NotGreaterLess$1 = \"≹\";\nvar NotGreaterSlantEqual$1 = \"⩾̸\";\nvar NotGreaterTilde$1 = \"≵\";\nvar NotHumpDownHump$1 = \"≎̸\";\nvar NotHumpEqual$1 = \"≏̸\";\nvar notin$1 = \"∉\";\nvar notindot$1 = \"⋵̸\";\nvar notinE$1 = \"⋹̸\";\nvar notinva$1 = \"∉\";\nvar notinvb$1 = \"⋷\";\nvar notinvc$1 = \"⋶\";\nvar NotLeftTriangleBar$1 = \"⧏̸\";\nvar NotLeftTriangle$1 = \"⋪\";\nvar NotLeftTriangleEqual$1 = \"⋬\";\nvar NotLess$1 = \"≮\";\nvar NotLessEqual$1 = \"≰\";\nvar NotLessGreater$1 = \"≸\";\nvar NotLessLess$1 = \"≪̸\";\nvar NotLessSlantEqual$1 = \"⩽̸\";\nvar NotLessTilde$1 = \"≴\";\nvar NotNestedGreaterGreater$1 = \"⪢̸\";\nvar NotNestedLessLess$1 = \"⪡̸\";\nvar notni$1 = \"∌\";\nvar notniva$1 = \"∌\";\nvar notnivb$1 = \"⋾\";\nvar notnivc$1 = \"⋽\";\nvar NotPrecedes$1 = \"⊀\";\nvar NotPrecedesEqual$1 = \"⪯̸\";\nvar NotPrecedesSlantEqual$1 = \"⋠\";\nvar NotReverseElement$1 = \"∌\";\nvar NotRightTriangleBar$1 = \"⧐̸\";\nvar NotRightTriangle$1 = \"⋫\";\nvar NotRightTriangleEqual$1 = \"⋭\";\nvar NotSquareSubset$1 = \"⊏̸\";\nvar NotSquareSubsetEqual$1 = \"⋢\";\nvar NotSquareSuperset$1 = \"⊐̸\";\nvar NotSquareSupersetEqual$1 = \"⋣\";\nvar NotSubset$1 = \"⊂⃒\";\nvar NotSubsetEqual$1 = \"⊈\";\nvar NotSucceeds$1 = \"⊁\";\nvar NotSucceedsEqual$1 = \"⪰̸\";\nvar NotSucceedsSlantEqual$1 = \"⋡\";\nvar NotSucceedsTilde$1 = \"≿̸\";\nvar NotSuperset$1 = \"⊃⃒\";\nvar NotSupersetEqual$1 = \"⊉\";\nvar NotTilde$1 = \"≁\";\nvar NotTildeEqual$1 = \"≄\";\nvar NotTildeFullEqual$1 = \"≇\";\nvar NotTildeTilde$1 = \"≉\";\nvar NotVerticalBar$1 = \"∤\";\nvar nparallel$1 = \"∦\";\nvar npar$1 = \"∦\";\nvar nparsl$1 = \"⫽⃥\";\nvar npart$1 = \"∂̸\";\nvar npolint$1 = \"⨔\";\nvar npr$1 = \"⊀\";\nvar nprcue$1 = \"⋠\";\nvar nprec$1 = \"⊀\";\nvar npreceq$1 = \"⪯̸\";\nvar npre$1 = \"⪯̸\";\nvar nrarrc$1 = \"⤳̸\";\nvar nrarr$1 = \"↛\";\nvar nrArr$1 = \"⇏\";\nvar nrarrw$1 = \"↝̸\";\nvar nrightarrow$1 = \"↛\";\nvar nRightarrow$1 = \"⇏\";\nvar nrtri$1 = \"⋫\";\nvar nrtrie$1 = \"⋭\";\nvar nsc$1 = \"⊁\";\nvar nsccue$1 = \"⋡\";\nvar nsce$1 = \"⪰̸\";\nvar Nscr$1 = \"𝒩\";\nvar nscr$1 = \"𝓃\";\nvar nshortmid$1 = \"∤\";\nvar nshortparallel$1 = \"∦\";\nvar nsim$1 = \"≁\";\nvar nsime$1 = \"≄\";\nvar nsimeq$1 = \"≄\";\nvar nsmid$1 = \"∤\";\nvar nspar$1 = \"∦\";\nvar nsqsube$1 = \"⋢\";\nvar nsqsupe$1 = \"⋣\";\nvar nsub$1 = \"⊄\";\nvar nsubE$1 = \"⫅̸\";\nvar nsube$1 = \"⊈\";\nvar nsubset$1 = \"⊂⃒\";\nvar nsubseteq$1 = \"⊈\";\nvar nsubseteqq$1 = \"⫅̸\";\nvar nsucc$1 = \"⊁\";\nvar nsucceq$1 = \"⪰̸\";\nvar nsup$1 = \"⊅\";\nvar nsupE$1 = \"⫆̸\";\nvar nsupe$1 = \"⊉\";\nvar nsupset$1 = \"⊃⃒\";\nvar nsupseteq$1 = \"⊉\";\nvar nsupseteqq$1 = \"⫆̸\";\nvar ntgl$1 = \"≹\";\nvar Ntilde$3 = \"Ñ\";\nvar ntilde$3 = \"ñ\";\nvar ntlg$1 = \"≸\";\nvar ntriangleleft$1 = \"⋪\";\nvar ntrianglelefteq$1 = \"⋬\";\nvar ntriangleright$1 = \"⋫\";\nvar ntrianglerighteq$1 = \"⋭\";\nvar Nu$1 = \"Ν\";\nvar nu$1 = \"ν\";\nvar num$1 = \"#\";\nvar numero$1 = \"№\";\nvar numsp$1 = \" \";\nvar nvap$1 = \"≍⃒\";\nvar nvdash$1 = \"⊬\";\nvar nvDash$1 = \"⊭\";\nvar nVdash$1 = \"⊮\";\nvar nVDash$1 = \"⊯\";\nvar nvge$1 = \"≥⃒\";\nvar nvgt$1 = \">⃒\";\nvar nvHarr$1 = \"⤄\";\nvar nvinfin$1 = \"⧞\";\nvar nvlArr$1 = \"⤂\";\nvar nvle$1 = \"≤⃒\";\nvar nvlt$1 = \"<⃒\";\nvar nvltrie$1 = \"⊴⃒\";\nvar nvrArr$1 = \"⤃\";\nvar nvrtrie$1 = \"⊵⃒\";\nvar nvsim$1 = \"∼⃒\";\nvar nwarhk$1 = \"⤣\";\nvar nwarr$1 = \"↖\";\nvar nwArr$1 = \"⇖\";\nvar nwarrow$1 = \"↖\";\nvar nwnear$1 = \"⤧\";\nvar Oacute$3 = \"Ó\";\nvar oacute$3 = \"ó\";\nvar oast$1 = \"⊛\";\nvar Ocirc$3 = \"Ô\";\nvar ocirc$3 = \"ô\";\nvar ocir$1 = \"⊚\";\nvar Ocy$1 = \"О\";\nvar ocy$1 = \"о\";\nvar odash$1 = \"⊝\";\nvar Odblac$1 = \"Ő\";\nvar odblac$1 = \"ő\";\nvar odiv$1 = \"⨸\";\nvar odot$1 = \"⊙\";\nvar odsold$1 = \"⦼\";\nvar OElig$1 = \"Œ\";\nvar oelig$1 = \"œ\";\nvar ofcir$1 = \"⦿\";\nvar Ofr$1 = \"𝔒\";\nvar ofr$1 = \"𝔬\";\nvar ogon$1 = \"˛\";\nvar Ograve$3 = \"Ò\";\nvar ograve$3 = \"ò\";\nvar ogt$1 = \"⧁\";\nvar ohbar$1 = \"⦵\";\nvar ohm$1 = \"Ω\";\nvar oint$1 = \"∮\";\nvar olarr$1 = \"↺\";\nvar olcir$1 = \"⦾\";\nvar olcross$1 = \"⦻\";\nvar oline$1 = \"‾\";\nvar olt$1 = \"⧀\";\nvar Omacr$1 = \"Ō\";\nvar omacr$1 = \"ō\";\nvar Omega$1 = \"Ω\";\nvar omega$1 = \"ω\";\nvar Omicron$1 = \"Ο\";\nvar omicron$1 = \"ο\";\nvar omid$1 = \"⦶\";\nvar ominus$1 = \"⊖\";\nvar Oopf$1 = \"𝕆\";\nvar oopf$1 = \"𝕠\";\nvar opar$1 = \"⦷\";\nvar OpenCurlyDoubleQuote$1 = \"“\";\nvar OpenCurlyQuote$1 = \"‘\";\nvar operp$1 = \"⦹\";\nvar oplus$1 = \"⊕\";\nvar orarr$1 = \"↻\";\nvar Or$1 = \"⩔\";\nvar or$1 = \"∨\";\nvar ord$1 = \"⩝\";\nvar order$1 = \"ℴ\";\nvar orderof$1 = \"ℴ\";\nvar ordf$3 = \"ª\";\nvar ordm$3 = \"º\";\nvar origof$1 = \"⊶\";\nvar oror$1 = \"⩖\";\nvar orslope$1 = \"⩗\";\nvar orv$1 = \"⩛\";\nvar oS$1 = \"Ⓢ\";\nvar Oscr$1 = \"𝒪\";\nvar oscr$1 = \"ℴ\";\nvar Oslash$3 = \"Ø\";\nvar oslash$3 = \"ø\";\nvar osol$1 = \"⊘\";\nvar Otilde$3 = \"Õ\";\nvar otilde$3 = \"õ\";\nvar otimesas$1 = \"⨶\";\nvar Otimes$1 = \"⨷\";\nvar otimes$1 = \"⊗\";\nvar Ouml$3 = \"Ö\";\nvar ouml$3 = \"ö\";\nvar ovbar$1 = \"⌽\";\nvar OverBar$1 = \"‾\";\nvar OverBrace$1 = \"⏞\";\nvar OverBracket$1 = \"⎴\";\nvar OverParenthesis$1 = \"⏜\";\nvar para$3 = \"¶\";\nvar parallel$1 = \"∥\";\nvar par$1 = \"∥\";\nvar parsim$1 = \"⫳\";\nvar parsl$1 = \"⫽\";\nvar part$1 = \"∂\";\nvar PartialD$1 = \"∂\";\nvar Pcy$1 = \"П\";\nvar pcy$1 = \"п\";\nvar percnt$1 = \"%\";\nvar period$1 = \".\";\nvar permil$1 = \"‰\";\nvar perp$1 = \"⊥\";\nvar pertenk$1 = \"‱\";\nvar Pfr$1 = \"𝔓\";\nvar pfr$1 = \"𝔭\";\nvar Phi$1 = \"Φ\";\nvar phi$1 = \"φ\";\nvar phiv$1 = \"ϕ\";\nvar phmmat$1 = \"ℳ\";\nvar phone$1 = \"☎\";\nvar Pi$1 = \"Π\";\nvar pi$1 = \"π\";\nvar pitchfork$1 = \"⋔\";\nvar piv$1 = \"ϖ\";\nvar planck$1 = \"ℏ\";\nvar planckh$1 = \"ℎ\";\nvar plankv$1 = \"ℏ\";\nvar plusacir$1 = \"⨣\";\nvar plusb$1 = \"⊞\";\nvar pluscir$1 = \"⨢\";\nvar plus$1 = \"+\";\nvar plusdo$1 = \"∔\";\nvar plusdu$1 = \"⨥\";\nvar pluse$1 = \"⩲\";\nvar PlusMinus$1 = \"±\";\nvar plusmn$3 = \"±\";\nvar plussim$1 = \"⨦\";\nvar plustwo$1 = \"⨧\";\nvar pm$1 = \"±\";\nvar Poincareplane$1 = \"ℌ\";\nvar pointint$1 = \"⨕\";\nvar popf$1 = \"𝕡\";\nvar Popf$1 = \"ℙ\";\nvar pound$3 = \"£\";\nvar prap$1 = \"⪷\";\nvar Pr$1 = \"⪻\";\nvar pr$1 = \"≺\";\nvar prcue$1 = \"≼\";\nvar precapprox$1 = \"⪷\";\nvar prec$1 = \"≺\";\nvar preccurlyeq$1 = \"≼\";\nvar Precedes$1 = \"≺\";\nvar PrecedesEqual$1 = \"⪯\";\nvar PrecedesSlantEqual$1 = \"≼\";\nvar PrecedesTilde$1 = \"≾\";\nvar preceq$1 = \"⪯\";\nvar precnapprox$1 = \"⪹\";\nvar precneqq$1 = \"⪵\";\nvar precnsim$1 = \"⋨\";\nvar pre$1 = \"⪯\";\nvar prE$1 = \"⪳\";\nvar precsim$1 = \"≾\";\nvar prime$1 = \"′\";\nvar Prime$1 = \"″\";\nvar primes$1 = \"ℙ\";\nvar prnap$1 = \"⪹\";\nvar prnE$1 = \"⪵\";\nvar prnsim$1 = \"⋨\";\nvar prod$1 = \"∏\";\nvar Product$1 = \"∏\";\nvar profalar$1 = \"⌮\";\nvar profline$1 = \"⌒\";\nvar profsurf$1 = \"⌓\";\nvar prop$1 = \"∝\";\nvar Proportional$1 = \"∝\";\nvar Proportion$1 = \"∷\";\nvar propto$1 = \"∝\";\nvar prsim$1 = \"≾\";\nvar prurel$1 = \"⊰\";\nvar Pscr$1 = \"𝒫\";\nvar pscr$1 = \"𝓅\";\nvar Psi$1 = \"Ψ\";\nvar psi$1 = \"ψ\";\nvar puncsp$1 = \" \";\nvar Qfr$1 = \"𝔔\";\nvar qfr$1 = \"𝔮\";\nvar qint$1 = \"⨌\";\nvar qopf$1 = \"𝕢\";\nvar Qopf$1 = \"ℚ\";\nvar qprime$1 = \"⁗\";\nvar Qscr$1 = \"𝒬\";\nvar qscr$1 = \"𝓆\";\nvar quaternions$1 = \"ℍ\";\nvar quatint$1 = \"⨖\";\nvar quest$1 = \"?\";\nvar questeq$1 = \"≟\";\nvar quot$5 = \"\\\"\";\nvar QUOT$3 = \"\\\"\";\nvar rAarr$1 = \"⇛\";\nvar race$1 = \"∽̱\";\nvar Racute$1 = \"Ŕ\";\nvar racute$1 = \"ŕ\";\nvar radic$1 = \"√\";\nvar raemptyv$1 = \"⦳\";\nvar rang$1 = \"⟩\";\nvar Rang$1 = \"⟫\";\nvar rangd$1 = \"⦒\";\nvar range$1 = \"⦥\";\nvar rangle$1 = \"⟩\";\nvar raquo$3 = \"»\";\nvar rarrap$1 = \"⥵\";\nvar rarrb$1 = \"⇥\";\nvar rarrbfs$1 = \"⤠\";\nvar rarrc$1 = \"⤳\";\nvar rarr$1 = \"→\";\nvar Rarr$1 = \"↠\";\nvar rArr$1 = \"⇒\";\nvar rarrfs$1 = \"⤞\";\nvar rarrhk$1 = \"↪\";\nvar rarrlp$1 = \"↬\";\nvar rarrpl$1 = \"⥅\";\nvar rarrsim$1 = \"⥴\";\nvar Rarrtl$1 = \"⤖\";\nvar rarrtl$1 = \"↣\";\nvar rarrw$1 = \"↝\";\nvar ratail$1 = \"⤚\";\nvar rAtail$1 = \"⤜\";\nvar ratio$1 = \"∶\";\nvar rationals$1 = \"ℚ\";\nvar rbarr$1 = \"⤍\";\nvar rBarr$1 = \"⤏\";\nvar RBarr$1 = \"⤐\";\nvar rbbrk$1 = \"❳\";\nvar rbrace$1 = \"}\";\nvar rbrack$1 = \"]\";\nvar rbrke$1 = \"⦌\";\nvar rbrksld$1 = \"⦎\";\nvar rbrkslu$1 = \"⦐\";\nvar Rcaron$1 = \"Ř\";\nvar rcaron$1 = \"ř\";\nvar Rcedil$1 = \"Ŗ\";\nvar rcedil$1 = \"ŗ\";\nvar rceil$1 = \"⌉\";\nvar rcub$1 = \"}\";\nvar Rcy$1 = \"Р\";\nvar rcy$1 = \"р\";\nvar rdca$1 = \"⤷\";\nvar rdldhar$1 = \"⥩\";\nvar rdquo$1 = \"”\";\nvar rdquor$1 = \"”\";\nvar rdsh$1 = \"↳\";\nvar real$1 = \"ℜ\";\nvar realine$1 = \"ℛ\";\nvar realpart$1 = \"ℜ\";\nvar reals$1 = \"ℝ\";\nvar Re$1 = \"ℜ\";\nvar rect$1 = \"▭\";\nvar reg$3 = \"®\";\nvar REG$3 = \"®\";\nvar ReverseElement$1 = \"∋\";\nvar ReverseEquilibrium$1 = \"⇋\";\nvar ReverseUpEquilibrium$1 = \"⥯\";\nvar rfisht$1 = \"⥽\";\nvar rfloor$1 = \"⌋\";\nvar rfr$1 = \"𝔯\";\nvar Rfr$1 = \"ℜ\";\nvar rHar$1 = \"⥤\";\nvar rhard$1 = \"⇁\";\nvar rharu$1 = \"⇀\";\nvar rharul$1 = \"⥬\";\nvar Rho$1 = \"Ρ\";\nvar rho$1 = \"ρ\";\nvar rhov$1 = \"ϱ\";\nvar RightAngleBracket$1 = \"⟩\";\nvar RightArrowBar$1 = \"⇥\";\nvar rightarrow$1 = \"→\";\nvar RightArrow$1 = \"→\";\nvar Rightarrow$1 = \"⇒\";\nvar RightArrowLeftArrow$1 = \"⇄\";\nvar rightarrowtail$1 = \"↣\";\nvar RightCeiling$1 = \"⌉\";\nvar RightDoubleBracket$1 = \"⟧\";\nvar RightDownTeeVector$1 = \"⥝\";\nvar RightDownVectorBar$1 = \"⥕\";\nvar RightDownVector$1 = \"⇂\";\nvar RightFloor$1 = \"⌋\";\nvar rightharpoondown$1 = \"⇁\";\nvar rightharpoonup$1 = \"⇀\";\nvar rightleftarrows$1 = \"⇄\";\nvar rightleftharpoons$1 = \"⇌\";\nvar rightrightarrows$1 = \"⇉\";\nvar rightsquigarrow$1 = \"↝\";\nvar RightTeeArrow$1 = \"↦\";\nvar RightTee$1 = \"⊢\";\nvar RightTeeVector$1 = \"⥛\";\nvar rightthreetimes$1 = \"⋌\";\nvar RightTriangleBar$1 = \"⧐\";\nvar RightTriangle$1 = \"⊳\";\nvar RightTriangleEqual$1 = \"⊵\";\nvar RightUpDownVector$1 = \"⥏\";\nvar RightUpTeeVector$1 = \"⥜\";\nvar RightUpVectorBar$1 = \"⥔\";\nvar RightUpVector$1 = \"↾\";\nvar RightVectorBar$1 = \"⥓\";\nvar RightVector$1 = \"⇀\";\nvar ring$1 = \"˚\";\nvar risingdotseq$1 = \"≓\";\nvar rlarr$1 = \"⇄\";\nvar rlhar$1 = \"⇌\";\nvar rlm$1 = \"‏\";\nvar rmoustache$1 = \"⎱\";\nvar rmoust$1 = \"⎱\";\nvar rnmid$1 = \"⫮\";\nvar roang$1 = \"⟭\";\nvar roarr$1 = \"⇾\";\nvar robrk$1 = \"⟧\";\nvar ropar$1 = \"⦆\";\nvar ropf$1 = \"𝕣\";\nvar Ropf$1 = \"ℝ\";\nvar roplus$1 = \"⨮\";\nvar rotimes$1 = \"⨵\";\nvar RoundImplies$1 = \"⥰\";\nvar rpar$1 = \")\";\nvar rpargt$1 = \"⦔\";\nvar rppolint$1 = \"⨒\";\nvar rrarr$1 = \"⇉\";\nvar Rrightarrow$1 = \"⇛\";\nvar rsaquo$1 = \"›\";\nvar rscr$1 = \"𝓇\";\nvar Rscr$1 = \"ℛ\";\nvar rsh$1 = \"↱\";\nvar Rsh$1 = \"↱\";\nvar rsqb$1 = \"]\";\nvar rsquo$1 = \"’\";\nvar rsquor$1 = \"’\";\nvar rthree$1 = \"⋌\";\nvar rtimes$1 = \"⋊\";\nvar rtri$1 = \"▹\";\nvar rtrie$1 = \"⊵\";\nvar rtrif$1 = \"▸\";\nvar rtriltri$1 = \"⧎\";\nvar RuleDelayed$1 = \"⧴\";\nvar ruluhar$1 = \"⥨\";\nvar rx$2 = \"℞\";\nvar Sacute$1 = \"Ś\";\nvar sacute$1 = \"ś\";\nvar sbquo$1 = \"‚\";\nvar scap$1 = \"⪸\";\nvar Scaron$1 = \"Š\";\nvar scaron$1 = \"š\";\nvar Sc$1 = \"⪼\";\nvar sc$1 = \"≻\";\nvar sccue$1 = \"≽\";\nvar sce$1 = \"⪰\";\nvar scE$1 = \"⪴\";\nvar Scedil$1 = \"Ş\";\nvar scedil$1 = \"ş\";\nvar Scirc$1 = \"Ŝ\";\nvar scirc$1 = \"ŝ\";\nvar scnap$1 = \"⪺\";\nvar scnE$1 = \"⪶\";\nvar scnsim$1 = \"⋩\";\nvar scpolint$1 = \"⨓\";\nvar scsim$1 = \"≿\";\nvar Scy$1 = \"С\";\nvar scy$1 = \"с\";\nvar sdotb$1 = \"⊡\";\nvar sdot$1 = \"⋅\";\nvar sdote$1 = \"⩦\";\nvar searhk$1 = \"⤥\";\nvar searr$1 = \"↘\";\nvar seArr$1 = \"⇘\";\nvar searrow$1 = \"↘\";\nvar sect$3 = \"§\";\nvar semi$1 = \";\";\nvar seswar$1 = \"⤩\";\nvar setminus$1 = \"∖\";\nvar setmn$1 = \"∖\";\nvar sext$1 = \"✶\";\nvar Sfr$1 = \"𝔖\";\nvar sfr$1 = \"𝔰\";\nvar sfrown$1 = \"⌢\";\nvar sharp$1 = \"♯\";\nvar SHCHcy$1 = \"Щ\";\nvar shchcy$1 = \"щ\";\nvar SHcy$1 = \"Ш\";\nvar shcy$1 = \"ш\";\nvar ShortDownArrow$1 = \"↓\";\nvar ShortLeftArrow$1 = \"←\";\nvar shortmid$1 = \"∣\";\nvar shortparallel$1 = \"∥\";\nvar ShortRightArrow$1 = \"→\";\nvar ShortUpArrow$1 = \"↑\";\nvar shy$3 = \"­\";\nvar Sigma$1 = \"Σ\";\nvar sigma$1 = \"σ\";\nvar sigmaf$1 = \"ς\";\nvar sigmav$1 = \"ς\";\nvar sim$1 = \"∼\";\nvar simdot$1 = \"⩪\";\nvar sime$1 = \"≃\";\nvar simeq$1 = \"≃\";\nvar simg$1 = \"⪞\";\nvar simgE$1 = \"⪠\";\nvar siml$1 = \"⪝\";\nvar simlE$1 = \"⪟\";\nvar simne$1 = \"≆\";\nvar simplus$1 = \"⨤\";\nvar simrarr$1 = \"⥲\";\nvar slarr$1 = \"←\";\nvar SmallCircle$1 = \"∘\";\nvar smallsetminus$1 = \"∖\";\nvar smashp$1 = \"⨳\";\nvar smeparsl$1 = \"⧤\";\nvar smid$1 = \"∣\";\nvar smile$1 = \"⌣\";\nvar smt$1 = \"⪪\";\nvar smte$1 = \"⪬\";\nvar smtes$1 = \"⪬︀\";\nvar SOFTcy$1 = \"Ь\";\nvar softcy$1 = \"ь\";\nvar solbar$1 = \"⌿\";\nvar solb$1 = \"⧄\";\nvar sol$1 = \"/\";\nvar Sopf$1 = \"𝕊\";\nvar sopf$1 = \"𝕤\";\nvar spades$1 = \"♠\";\nvar spadesuit$1 = \"♠\";\nvar spar$1 = \"∥\";\nvar sqcap$1 = \"⊓\";\nvar sqcaps$1 = \"⊓︀\";\nvar sqcup$1 = \"⊔\";\nvar sqcups$1 = \"⊔︀\";\nvar Sqrt$1 = \"√\";\nvar sqsub$1 = \"⊏\";\nvar sqsube$1 = \"⊑\";\nvar sqsubset$1 = \"⊏\";\nvar sqsubseteq$1 = \"⊑\";\nvar sqsup$1 = \"⊐\";\nvar sqsupe$1 = \"⊒\";\nvar sqsupset$1 = \"⊐\";\nvar sqsupseteq$1 = \"⊒\";\nvar square$1 = \"□\";\nvar Square$1 = \"□\";\nvar SquareIntersection$1 = \"⊓\";\nvar SquareSubset$1 = \"⊏\";\nvar SquareSubsetEqual$1 = \"⊑\";\nvar SquareSuperset$1 = \"⊐\";\nvar SquareSupersetEqual$1 = \"⊒\";\nvar SquareUnion$1 = \"⊔\";\nvar squarf$1 = \"▪\";\nvar squ$1 = \"□\";\nvar squf$1 = \"▪\";\nvar srarr$1 = \"→\";\nvar Sscr$1 = \"𝒮\";\nvar sscr$1 = \"𝓈\";\nvar ssetmn$1 = \"∖\";\nvar ssmile$1 = \"⌣\";\nvar sstarf$1 = \"⋆\";\nvar Star$1 = \"⋆\";\nvar star$1 = \"☆\";\nvar starf$1 = \"★\";\nvar straightepsilon$1 = \"ϵ\";\nvar straightphi$1 = \"ϕ\";\nvar strns$1 = \"¯\";\nvar sub$1 = \"⊂\";\nvar Sub$1 = \"⋐\";\nvar subdot$1 = \"⪽\";\nvar subE$1 = \"⫅\";\nvar sube$1 = \"⊆\";\nvar subedot$1 = \"⫃\";\nvar submult$1 = \"⫁\";\nvar subnE$1 = \"⫋\";\nvar subne$1 = \"⊊\";\nvar subplus$1 = \"⪿\";\nvar subrarr$1 = \"⥹\";\nvar subset$1 = \"⊂\";\nvar Subset$1 = \"⋐\";\nvar subseteq$1 = \"⊆\";\nvar subseteqq$1 = \"⫅\";\nvar SubsetEqual$1 = \"⊆\";\nvar subsetneq$1 = \"⊊\";\nvar subsetneqq$1 = \"⫋\";\nvar subsim$1 = \"⫇\";\nvar subsub$1 = \"⫕\";\nvar subsup$1 = \"⫓\";\nvar succapprox$1 = \"⪸\";\nvar succ$1 = \"≻\";\nvar succcurlyeq$1 = \"≽\";\nvar Succeeds$1 = \"≻\";\nvar SucceedsEqual$1 = \"⪰\";\nvar SucceedsSlantEqual$1 = \"≽\";\nvar SucceedsTilde$1 = \"≿\";\nvar succeq$1 = \"⪰\";\nvar succnapprox$1 = \"⪺\";\nvar succneqq$1 = \"⪶\";\nvar succnsim$1 = \"⋩\";\nvar succsim$1 = \"≿\";\nvar SuchThat$1 = \"∋\";\nvar sum$1 = \"∑\";\nvar Sum$1 = \"∑\";\nvar sung$1 = \"♪\";\nvar sup1$3 = \"¹\";\nvar sup2$3 = \"²\";\nvar sup3$3 = \"³\";\nvar sup$1 = \"⊃\";\nvar Sup$1 = \"⋑\";\nvar supdot$1 = \"⪾\";\nvar supdsub$1 = \"⫘\";\nvar supE$1 = \"⫆\";\nvar supe$1 = \"⊇\";\nvar supedot$1 = \"⫄\";\nvar Superset$1 = \"⊃\";\nvar SupersetEqual$1 = \"⊇\";\nvar suphsol$1 = \"⟉\";\nvar suphsub$1 = \"⫗\";\nvar suplarr$1 = \"⥻\";\nvar supmult$1 = \"⫂\";\nvar supnE$1 = \"⫌\";\nvar supne$1 = \"⊋\";\nvar supplus$1 = \"⫀\";\nvar supset$1 = \"⊃\";\nvar Supset$1 = \"⋑\";\nvar supseteq$1 = \"⊇\";\nvar supseteqq$1 = \"⫆\";\nvar supsetneq$1 = \"⊋\";\nvar supsetneqq$1 = \"⫌\";\nvar supsim$1 = \"⫈\";\nvar supsub$1 = \"⫔\";\nvar supsup$1 = \"⫖\";\nvar swarhk$1 = \"⤦\";\nvar swarr$1 = \"↙\";\nvar swArr$1 = \"⇙\";\nvar swarrow$1 = \"↙\";\nvar swnwar$1 = \"⤪\";\nvar szlig$3 = \"ß\";\nvar Tab$1 = \"\\t\";\nvar target$2 = \"⌖\";\nvar Tau$1 = \"Τ\";\nvar tau$1 = \"τ\";\nvar tbrk$1 = \"⎴\";\nvar Tcaron$1 = \"Ť\";\nvar tcaron$1 = \"ť\";\nvar Tcedil$1 = \"Ţ\";\nvar tcedil$1 = \"ţ\";\nvar Tcy$1 = \"Т\";\nvar tcy$1 = \"т\";\nvar tdot$1 = \"⃛\";\nvar telrec$1 = \"⌕\";\nvar Tfr$1 = \"𝔗\";\nvar tfr$1 = \"𝔱\";\nvar there4$1 = \"∴\";\nvar therefore$1 = \"∴\";\nvar Therefore$1 = \"∴\";\nvar Theta$1 = \"Θ\";\nvar theta$1 = \"θ\";\nvar thetasym$1 = \"ϑ\";\nvar thetav$1 = \"ϑ\";\nvar thickapprox$1 = \"≈\";\nvar thicksim$1 = \"∼\";\nvar ThickSpace$1 = \"  \";\nvar ThinSpace$1 = \" \";\nvar thinsp$1 = \" \";\nvar thkap$1 = \"≈\";\nvar thksim$1 = \"∼\";\nvar THORN$3 = \"Þ\";\nvar thorn$3 = \"þ\";\nvar tilde$1 = \"˜\";\nvar Tilde$1 = \"∼\";\nvar TildeEqual$1 = \"≃\";\nvar TildeFullEqual$1 = \"≅\";\nvar TildeTilde$1 = \"≈\";\nvar timesbar$1 = \"⨱\";\nvar timesb$1 = \"⊠\";\nvar times$3 = \"×\";\nvar timesd$1 = \"⨰\";\nvar tint$1 = \"∭\";\nvar toea$1 = \"⤨\";\nvar topbot$1 = \"⌶\";\nvar topcir$1 = \"⫱\";\nvar top$1 = \"⊤\";\nvar Topf$1 = \"𝕋\";\nvar topf$1 = \"𝕥\";\nvar topfork$1 = \"⫚\";\nvar tosa$1 = \"⤩\";\nvar tprime$1 = \"‴\";\nvar trade$1 = \"™\";\nvar TRADE$1 = \"™\";\nvar triangle$1 = \"▵\";\nvar triangledown$1 = \"▿\";\nvar triangleleft$1 = \"◃\";\nvar trianglelefteq$1 = \"⊴\";\nvar triangleq$1 = \"≜\";\nvar triangleright$1 = \"▹\";\nvar trianglerighteq$1 = \"⊵\";\nvar tridot$1 = \"◬\";\nvar trie$1 = \"≜\";\nvar triminus$1 = \"⨺\";\nvar TripleDot$1 = \"⃛\";\nvar triplus$1 = \"⨹\";\nvar trisb$1 = \"⧍\";\nvar tritime$1 = \"⨻\";\nvar trpezium$1 = \"⏢\";\nvar Tscr$1 = \"𝒯\";\nvar tscr$1 = \"𝓉\";\nvar TScy$1 = \"Ц\";\nvar tscy$1 = \"ц\";\nvar TSHcy$1 = \"Ћ\";\nvar tshcy$1 = \"ћ\";\nvar Tstrok$1 = \"Ŧ\";\nvar tstrok$1 = \"ŧ\";\nvar twixt$1 = \"≬\";\nvar twoheadleftarrow$1 = \"↞\";\nvar twoheadrightarrow$1 = \"↠\";\nvar Uacute$3 = \"Ú\";\nvar uacute$3 = \"ú\";\nvar uarr$1 = \"↑\";\nvar Uarr$1 = \"↟\";\nvar uArr$1 = \"⇑\";\nvar Uarrocir$1 = \"⥉\";\nvar Ubrcy$1 = \"Ў\";\nvar ubrcy$1 = \"ў\";\nvar Ubreve$1 = \"Ŭ\";\nvar ubreve$1 = \"ŭ\";\nvar Ucirc$3 = \"Û\";\nvar ucirc$3 = \"û\";\nvar Ucy$1 = \"У\";\nvar ucy$1 = \"у\";\nvar udarr$1 = \"⇅\";\nvar Udblac$1 = \"Ű\";\nvar udblac$1 = \"ű\";\nvar udhar$1 = \"⥮\";\nvar ufisht$1 = \"⥾\";\nvar Ufr$1 = \"𝔘\";\nvar ufr$1 = \"𝔲\";\nvar Ugrave$3 = \"Ù\";\nvar ugrave$3 = \"ù\";\nvar uHar$1 = \"⥣\";\nvar uharl$1 = \"↿\";\nvar uharr$1 = \"↾\";\nvar uhblk$1 = \"▀\";\nvar ulcorn$1 = \"⌜\";\nvar ulcorner$1 = \"⌜\";\nvar ulcrop$1 = \"⌏\";\nvar ultri$1 = \"◸\";\nvar Umacr$1 = \"Ū\";\nvar umacr$1 = \"ū\";\nvar uml$3 = \"¨\";\nvar UnderBar$1 = \"_\";\nvar UnderBrace$1 = \"⏟\";\nvar UnderBracket$1 = \"⎵\";\nvar UnderParenthesis$1 = \"⏝\";\nvar Union$1 = \"⋃\";\nvar UnionPlus$1 = \"⊎\";\nvar Uogon$1 = \"Ų\";\nvar uogon$1 = \"ų\";\nvar Uopf$1 = \"𝕌\";\nvar uopf$1 = \"𝕦\";\nvar UpArrowBar$1 = \"⤒\";\nvar uparrow$1 = \"↑\";\nvar UpArrow$1 = \"↑\";\nvar Uparrow$1 = \"⇑\";\nvar UpArrowDownArrow$1 = \"⇅\";\nvar updownarrow$1 = \"↕\";\nvar UpDownArrow$1 = \"↕\";\nvar Updownarrow$1 = \"⇕\";\nvar UpEquilibrium$1 = \"⥮\";\nvar upharpoonleft$1 = \"↿\";\nvar upharpoonright$1 = \"↾\";\nvar uplus$1 = \"⊎\";\nvar UpperLeftArrow$1 = \"↖\";\nvar UpperRightArrow$1 = \"↗\";\nvar upsi$1 = \"υ\";\nvar Upsi$1 = \"ϒ\";\nvar upsih$1 = \"ϒ\";\nvar Upsilon$1 = \"Υ\";\nvar upsilon$1 = \"υ\";\nvar UpTeeArrow$1 = \"↥\";\nvar UpTee$1 = \"⊥\";\nvar upuparrows$1 = \"⇈\";\nvar urcorn$1 = \"⌝\";\nvar urcorner$1 = \"⌝\";\nvar urcrop$1 = \"⌎\";\nvar Uring$1 = \"Ů\";\nvar uring$1 = \"ů\";\nvar urtri$1 = \"◹\";\nvar Uscr$1 = \"𝒰\";\nvar uscr$1 = \"𝓊\";\nvar utdot$1 = \"⋰\";\nvar Utilde$1 = \"Ũ\";\nvar utilde$1 = \"ũ\";\nvar utri$1 = \"▵\";\nvar utrif$1 = \"▴\";\nvar uuarr$1 = \"⇈\";\nvar Uuml$3 = \"Ü\";\nvar uuml$3 = \"ü\";\nvar uwangle$1 = \"⦧\";\nvar vangrt$1 = \"⦜\";\nvar varepsilon$1 = \"ϵ\";\nvar varkappa$1 = \"ϰ\";\nvar varnothing$1 = \"∅\";\nvar varphi$1 = \"ϕ\";\nvar varpi$1 = \"ϖ\";\nvar varpropto$1 = \"∝\";\nvar varr$1 = \"↕\";\nvar vArr$1 = \"⇕\";\nvar varrho$1 = \"ϱ\";\nvar varsigma$1 = \"ς\";\nvar varsubsetneq$1 = \"⊊︀\";\nvar varsubsetneqq$1 = \"⫋︀\";\nvar varsupsetneq$1 = \"⊋︀\";\nvar varsupsetneqq$1 = \"⫌︀\";\nvar vartheta$1 = \"ϑ\";\nvar vartriangleleft$1 = \"⊲\";\nvar vartriangleright$1 = \"⊳\";\nvar vBar$1 = \"⫨\";\nvar Vbar$1 = \"⫫\";\nvar vBarv$1 = \"⫩\";\nvar Vcy$1 = \"В\";\nvar vcy$1 = \"в\";\nvar vdash$1 = \"⊢\";\nvar vDash$1 = \"⊨\";\nvar Vdash$1 = \"⊩\";\nvar VDash$1 = \"⊫\";\nvar Vdashl$1 = \"⫦\";\nvar veebar$1 = \"⊻\";\nvar vee$1 = \"∨\";\nvar Vee$1 = \"⋁\";\nvar veeeq$1 = \"≚\";\nvar vellip$1 = \"⋮\";\nvar verbar$1 = \"|\";\nvar Verbar$1 = \"‖\";\nvar vert$1 = \"|\";\nvar Vert$1 = \"‖\";\nvar VerticalBar$1 = \"∣\";\nvar VerticalLine$1 = \"|\";\nvar VerticalSeparator$1 = \"❘\";\nvar VerticalTilde$1 = \"≀\";\nvar VeryThinSpace$1 = \" \";\nvar Vfr$1 = \"𝔙\";\nvar vfr$1 = \"𝔳\";\nvar vltri$1 = \"⊲\";\nvar vnsub$1 = \"⊂⃒\";\nvar vnsup$1 = \"⊃⃒\";\nvar Vopf$1 = \"𝕍\";\nvar vopf$1 = \"𝕧\";\nvar vprop$1 = \"∝\";\nvar vrtri$1 = \"⊳\";\nvar Vscr$1 = \"𝒱\";\nvar vscr$1 = \"𝓋\";\nvar vsubnE$1 = \"⫋︀\";\nvar vsubne$1 = \"⊊︀\";\nvar vsupnE$1 = \"⫌︀\";\nvar vsupne$1 = \"⊋︀\";\nvar Vvdash$1 = \"⊪\";\nvar vzigzag$1 = \"⦚\";\nvar Wcirc$1 = \"Ŵ\";\nvar wcirc$1 = \"ŵ\";\nvar wedbar$1 = \"⩟\";\nvar wedge$1 = \"∧\";\nvar Wedge$1 = \"⋀\";\nvar wedgeq$1 = \"≙\";\nvar weierp$1 = \"℘\";\nvar Wfr$1 = \"𝔚\";\nvar wfr$1 = \"𝔴\";\nvar Wopf$1 = \"𝕎\";\nvar wopf$1 = \"𝕨\";\nvar wp$1 = \"℘\";\nvar wr$1 = \"≀\";\nvar wreath$1 = \"≀\";\nvar Wscr$1 = \"𝒲\";\nvar wscr$1 = \"𝓌\";\nvar xcap$1 = \"⋂\";\nvar xcirc$1 = \"◯\";\nvar xcup$1 = \"⋃\";\nvar xdtri$1 = \"▽\";\nvar Xfr$1 = \"𝔛\";\nvar xfr$1 = \"𝔵\";\nvar xharr$1 = \"⟷\";\nvar xhArr$1 = \"⟺\";\nvar Xi$1 = \"Ξ\";\nvar xi$1 = \"ξ\";\nvar xlarr$1 = \"⟵\";\nvar xlArr$1 = \"⟸\";\nvar xmap$1 = \"⟼\";\nvar xnis$1 = \"⋻\";\nvar xodot$1 = \"⨀\";\nvar Xopf$1 = \"𝕏\";\nvar xopf$1 = \"𝕩\";\nvar xoplus$1 = \"⨁\";\nvar xotime$1 = \"⨂\";\nvar xrarr$1 = \"⟶\";\nvar xrArr$1 = \"⟹\";\nvar Xscr$1 = \"𝒳\";\nvar xscr$1 = \"𝓍\";\nvar xsqcup$1 = \"⨆\";\nvar xuplus$1 = \"⨄\";\nvar xutri$1 = \"△\";\nvar xvee$1 = \"⋁\";\nvar xwedge$1 = \"⋀\";\nvar Yacute$3 = \"Ý\";\nvar yacute$3 = \"ý\";\nvar YAcy$1 = \"Я\";\nvar yacy$1 = \"я\";\nvar Ycirc$1 = \"Ŷ\";\nvar ycirc$1 = \"ŷ\";\nvar Ycy$1 = \"Ы\";\nvar ycy$1 = \"ы\";\nvar yen$3 = \"¥\";\nvar Yfr$1 = \"𝔜\";\nvar yfr$1 = \"𝔶\";\nvar YIcy$1 = \"Ї\";\nvar yicy$1 = \"ї\";\nvar Yopf$1 = \"𝕐\";\nvar yopf$1 = \"𝕪\";\nvar Yscr$1 = \"𝒴\";\nvar yscr$1 = \"𝓎\";\nvar YUcy$1 = \"Ю\";\nvar yucy$1 = \"ю\";\nvar yuml$3 = \"ÿ\";\nvar Yuml$1 = \"Ÿ\";\nvar Zacute$1 = \"Ź\";\nvar zacute$1 = \"ź\";\nvar Zcaron$1 = \"Ž\";\nvar zcaron$1 = \"ž\";\nvar Zcy$1 = \"З\";\nvar zcy$1 = \"з\";\nvar Zdot$1 = \"Ż\";\nvar zdot$1 = \"ż\";\nvar zeetrf$1 = \"ℨ\";\nvar ZeroWidthSpace$1 = \"​\";\nvar Zeta$1 = \"Ζ\";\nvar zeta$1 = \"ζ\";\nvar zfr$1 = \"𝔷\";\nvar Zfr$1 = \"ℨ\";\nvar ZHcy$1 = \"Ж\";\nvar zhcy$1 = \"ж\";\nvar zigrarr$1 = \"⇝\";\nvar zopf$1 = \"𝕫\";\nvar Zopf$1 = \"ℤ\";\nvar Zscr$1 = \"𝒵\";\nvar zscr$1 = \"𝓏\";\nvar zwj$1 = \"‍\";\nvar zwnj$1 = \"‌\";\nvar require$$1$4 = {\n\tAacute: Aacute$3,\n\taacute: aacute$3,\n\tAbreve: Abreve$1,\n\tabreve: abreve$1,\n\tac: ac$1,\n\tacd: acd$1,\n\tacE: acE$1,\n\tAcirc: Acirc$3,\n\tacirc: acirc$3,\n\tacute: acute$3,\n\tAcy: Acy$1,\n\tacy: acy$1,\n\tAElig: AElig$3,\n\taelig: aelig$3,\n\taf: af$1,\n\tAfr: Afr$1,\n\tafr: afr$1,\n\tAgrave: Agrave$3,\n\tagrave: agrave$3,\n\talefsym: alefsym$1,\n\taleph: aleph$1,\n\tAlpha: Alpha$1,\n\talpha: alpha$1,\n\tAmacr: Amacr$1,\n\tamacr: amacr$1,\n\tamalg: amalg$1,\n\tamp: amp$5,\n\tAMP: AMP$3,\n\tandand: andand$1,\n\tAnd: And$1,\n\tand: and$1,\n\tandd: andd$1,\n\tandslope: andslope$1,\n\tandv: andv$1,\n\tang: ang$1,\n\tange: ange$1,\n\tangle: angle$1,\n\tangmsdaa: angmsdaa$1,\n\tangmsdab: angmsdab$1,\n\tangmsdac: angmsdac$1,\n\tangmsdad: angmsdad$1,\n\tangmsdae: angmsdae$1,\n\tangmsdaf: angmsdaf$1,\n\tangmsdag: angmsdag$1,\n\tangmsdah: angmsdah$1,\n\tangmsd: angmsd$1,\n\tangrt: angrt$1,\n\tangrtvb: angrtvb$1,\n\tangrtvbd: angrtvbd$1,\n\tangsph: angsph$1,\n\tangst: angst$1,\n\tangzarr: angzarr$1,\n\tAogon: Aogon$1,\n\taogon: aogon$1,\n\tAopf: Aopf$1,\n\taopf: aopf$1,\n\tapacir: apacir$1,\n\tap: ap$1,\n\tapE: apE$1,\n\tape: ape$1,\n\tapid: apid$1,\n\tapos: apos$3,\n\tApplyFunction: ApplyFunction$1,\n\tapprox: approx$1,\n\tapproxeq: approxeq$1,\n\tAring: Aring$3,\n\taring: aring$3,\n\tAscr: Ascr$1,\n\tascr: ascr$1,\n\tAssign: Assign$1,\n\tast: ast$1,\n\tasymp: asymp$1,\n\tasympeq: asympeq$1,\n\tAtilde: Atilde$3,\n\tatilde: atilde$3,\n\tAuml: Auml$3,\n\tauml: auml$3,\n\tawconint: awconint$1,\n\tawint: awint$1,\n\tbackcong: backcong$1,\n\tbackepsilon: backepsilon$1,\n\tbackprime: backprime$1,\n\tbacksim: backsim$1,\n\tbacksimeq: backsimeq$1,\n\tBackslash: Backslash$1,\n\tBarv: Barv$1,\n\tbarvee: barvee$1,\n\tbarwed: barwed$1,\n\tBarwed: Barwed$1,\n\tbarwedge: barwedge$1,\n\tbbrk: bbrk$1,\n\tbbrktbrk: bbrktbrk$1,\n\tbcong: bcong$1,\n\tBcy: Bcy$1,\n\tbcy: bcy$1,\n\tbdquo: bdquo$1,\n\tbecaus: becaus$1,\n\tbecause: because$1,\n\tBecause: Because$1,\n\tbemptyv: bemptyv$1,\n\tbepsi: bepsi$1,\n\tbernou: bernou$1,\n\tBernoullis: Bernoullis$1,\n\tBeta: Beta$1,\n\tbeta: beta$1,\n\tbeth: beth$1,\n\tbetween: between$1,\n\tBfr: Bfr$1,\n\tbfr: bfr$1,\n\tbigcap: bigcap$1,\n\tbigcirc: bigcirc$1,\n\tbigcup: bigcup$1,\n\tbigodot: bigodot$1,\n\tbigoplus: bigoplus$1,\n\tbigotimes: bigotimes$1,\n\tbigsqcup: bigsqcup$1,\n\tbigstar: bigstar$1,\n\tbigtriangledown: bigtriangledown$1,\n\tbigtriangleup: bigtriangleup$1,\n\tbiguplus: biguplus$1,\n\tbigvee: bigvee$1,\n\tbigwedge: bigwedge$1,\n\tbkarow: bkarow$1,\n\tblacklozenge: blacklozenge$1,\n\tblacksquare: blacksquare$1,\n\tblacktriangle: blacktriangle$1,\n\tblacktriangledown: blacktriangledown$1,\n\tblacktriangleleft: blacktriangleleft$1,\n\tblacktriangleright: blacktriangleright$1,\n\tblank: blank$1,\n\tblk12: blk12$1,\n\tblk14: blk14$1,\n\tblk34: blk34$1,\n\tblock: block$1,\n\tbne: bne$1,\n\tbnequiv: bnequiv$1,\n\tbNot: bNot$1,\n\tbnot: bnot$1,\n\tBopf: Bopf$1,\n\tbopf: bopf$1,\n\tbot: bot$1,\n\tbottom: bottom$1,\n\tbowtie: bowtie$1,\n\tboxbox: boxbox$1,\n\tboxdl: boxdl$1,\n\tboxdL: boxdL$1,\n\tboxDl: boxDl$1,\n\tboxDL: boxDL$1,\n\tboxdr: boxdr$1,\n\tboxdR: boxdR$1,\n\tboxDr: boxDr$1,\n\tboxDR: boxDR$1,\n\tboxh: boxh$1,\n\tboxH: boxH$1,\n\tboxhd: boxhd$1,\n\tboxHd: boxHd$1,\n\tboxhD: boxhD$1,\n\tboxHD: boxHD$1,\n\tboxhu: boxhu$1,\n\tboxHu: boxHu$1,\n\tboxhU: boxhU$1,\n\tboxHU: boxHU$1,\n\tboxminus: boxminus$1,\n\tboxplus: boxplus$1,\n\tboxtimes: boxtimes$1,\n\tboxul: boxul$1,\n\tboxuL: boxuL$1,\n\tboxUl: boxUl$1,\n\tboxUL: boxUL$1,\n\tboxur: boxur$1,\n\tboxuR: boxuR$1,\n\tboxUr: boxUr$1,\n\tboxUR: boxUR$1,\n\tboxv: boxv$1,\n\tboxV: boxV$1,\n\tboxvh: boxvh$1,\n\tboxvH: boxvH$1,\n\tboxVh: boxVh$1,\n\tboxVH: boxVH$1,\n\tboxvl: boxvl$1,\n\tboxvL: boxvL$1,\n\tboxVl: boxVl$1,\n\tboxVL: boxVL$1,\n\tboxvr: boxvr$1,\n\tboxvR: boxvR$1,\n\tboxVr: boxVr$1,\n\tboxVR: boxVR$1,\n\tbprime: bprime$1,\n\tbreve: breve$1,\n\tBreve: Breve$1,\n\tbrvbar: brvbar$3,\n\tbscr: bscr$1,\n\tBscr: Bscr$1,\n\tbsemi: bsemi$1,\n\tbsim: bsim$1,\n\tbsime: bsime$1,\n\tbsolb: bsolb$1,\n\tbsol: bsol$1,\n\tbsolhsub: bsolhsub$1,\n\tbull: bull$1,\n\tbullet: bullet$1,\n\tbump: bump$1,\n\tbumpE: bumpE$1,\n\tbumpe: bumpe$1,\n\tBumpeq: Bumpeq$1,\n\tbumpeq: bumpeq$1,\n\tCacute: Cacute$1,\n\tcacute: cacute$1,\n\tcapand: capand$1,\n\tcapbrcup: capbrcup$1,\n\tcapcap: capcap$1,\n\tcap: cap$1,\n\tCap: Cap$1,\n\tcapcup: capcup$1,\n\tcapdot: capdot$1,\n\tCapitalDifferentialD: CapitalDifferentialD$1,\n\tcaps: caps$1,\n\tcaret: caret$1,\n\tcaron: caron$1,\n\tCayleys: Cayleys$1,\n\tccaps: ccaps$1,\n\tCcaron: Ccaron$1,\n\tccaron: ccaron$1,\n\tCcedil: Ccedil$3,\n\tccedil: ccedil$3,\n\tCcirc: Ccirc$1,\n\tccirc: ccirc$1,\n\tCconint: Cconint$1,\n\tccups: ccups$1,\n\tccupssm: ccupssm$1,\n\tCdot: Cdot$1,\n\tcdot: cdot$1,\n\tcedil: cedil$3,\n\tCedilla: Cedilla$1,\n\tcemptyv: cemptyv$1,\n\tcent: cent$3,\n\tcenterdot: centerdot$1,\n\tCenterDot: CenterDot$1,\n\tcfr: cfr$1,\n\tCfr: Cfr$1,\n\tCHcy: CHcy$1,\n\tchcy: chcy$1,\n\tcheck: check$1,\n\tcheckmark: checkmark$1,\n\tChi: Chi$1,\n\tchi: chi$1,\n\tcirc: circ$1,\n\tcirceq: circeq$1,\n\tcirclearrowleft: circlearrowleft$1,\n\tcirclearrowright: circlearrowright$1,\n\tcircledast: circledast$1,\n\tcircledcirc: circledcirc$1,\n\tcircleddash: circleddash$1,\n\tCircleDot: CircleDot$1,\n\tcircledR: circledR$1,\n\tcircledS: circledS$1,\n\tCircleMinus: CircleMinus$1,\n\tCirclePlus: CirclePlus$1,\n\tCircleTimes: CircleTimes$1,\n\tcir: cir$1,\n\tcirE: cirE$1,\n\tcire: cire$1,\n\tcirfnint: cirfnint$1,\n\tcirmid: cirmid$1,\n\tcirscir: cirscir$1,\n\tClockwiseContourIntegral: ClockwiseContourIntegral$1,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,\n\tCloseCurlyQuote: CloseCurlyQuote$1,\n\tclubs: clubs$1,\n\tclubsuit: clubsuit$1,\n\tcolon: colon$1,\n\tColon: Colon$1,\n\tColone: Colone$1,\n\tcolone: colone$1,\n\tcoloneq: coloneq$1,\n\tcomma: comma$1,\n\tcommat: commat$1,\n\tcomp: comp$1,\n\tcompfn: compfn$1,\n\tcomplement: complement$1,\n\tcomplexes: complexes$1,\n\tcong: cong$1,\n\tcongdot: congdot$1,\n\tCongruent: Congruent$1,\n\tconint: conint$1,\n\tConint: Conint$1,\n\tContourIntegral: ContourIntegral$1,\n\tcopf: copf$1,\n\tCopf: Copf$1,\n\tcoprod: coprod$1,\n\tCoproduct: Coproduct$1,\n\tcopy: copy$3,\n\tCOPY: COPY$3,\n\tcopysr: copysr$1,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,\n\tcrarr: crarr$1,\n\tcross: cross$1,\n\tCross: Cross$1,\n\tCscr: Cscr$1,\n\tcscr: cscr$1,\n\tcsub: csub$1,\n\tcsube: csube$1,\n\tcsup: csup$1,\n\tcsupe: csupe$1,\n\tctdot: ctdot$1,\n\tcudarrl: cudarrl$1,\n\tcudarrr: cudarrr$1,\n\tcuepr: cuepr$1,\n\tcuesc: cuesc$1,\n\tcularr: cularr$1,\n\tcularrp: cularrp$1,\n\tcupbrcap: cupbrcap$1,\n\tcupcap: cupcap$1,\n\tCupCap: CupCap$1,\n\tcup: cup$1,\n\tCup: Cup$1,\n\tcupcup: cupcup$1,\n\tcupdot: cupdot$1,\n\tcupor: cupor$1,\n\tcups: cups$1,\n\tcurarr: curarr$1,\n\tcurarrm: curarrm$1,\n\tcurlyeqprec: curlyeqprec$1,\n\tcurlyeqsucc: curlyeqsucc$1,\n\tcurlyvee: curlyvee$1,\n\tcurlywedge: curlywedge$1,\n\tcurren: curren$3,\n\tcurvearrowleft: curvearrowleft$1,\n\tcurvearrowright: curvearrowright$1,\n\tcuvee: cuvee$1,\n\tcuwed: cuwed$1,\n\tcwconint: cwconint$1,\n\tcwint: cwint$1,\n\tcylcty: cylcty$1,\n\tdagger: dagger$1,\n\tDagger: Dagger$1,\n\tdaleth: daleth$1,\n\tdarr: darr$1,\n\tDarr: Darr$1,\n\tdArr: dArr$1,\n\tdash: dash$1,\n\tDashv: Dashv$1,\n\tdashv: dashv$1,\n\tdbkarow: dbkarow$1,\n\tdblac: dblac$1,\n\tDcaron: Dcaron$1,\n\tdcaron: dcaron$1,\n\tDcy: Dcy$1,\n\tdcy: dcy$1,\n\tddagger: ddagger$1,\n\tddarr: ddarr$1,\n\tDD: DD$1,\n\tdd: dd$1,\n\tDDotrahd: DDotrahd$1,\n\tddotseq: ddotseq$1,\n\tdeg: deg$3,\n\tDel: Del$1,\n\tDelta: Delta$1,\n\tdelta: delta$1,\n\tdemptyv: demptyv$1,\n\tdfisht: dfisht$1,\n\tDfr: Dfr$1,\n\tdfr: dfr$1,\n\tdHar: dHar$1,\n\tdharl: dharl$1,\n\tdharr: dharr$1,\n\tDiacriticalAcute: DiacriticalAcute$1,\n\tDiacriticalDot: DiacriticalDot$1,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute$1,\n\tDiacriticalGrave: DiacriticalGrave$1,\n\tDiacriticalTilde: DiacriticalTilde$1,\n\tdiam: diam$1,\n\tdiamond: diamond$1,\n\tDiamond: Diamond$1,\n\tdiamondsuit: diamondsuit$1,\n\tdiams: diams$1,\n\tdie: die$1,\n\tDifferentialD: DifferentialD$1,\n\tdigamma: digamma$1,\n\tdisin: disin$1,\n\tdiv: div$1,\n\tdivide: divide$3,\n\tdivideontimes: divideontimes$1,\n\tdivonx: divonx$1,\n\tDJcy: DJcy$1,\n\tdjcy: djcy$1,\n\tdlcorn: dlcorn$1,\n\tdlcrop: dlcrop$1,\n\tdollar: dollar$1,\n\tDopf: Dopf$1,\n\tdopf: dopf$1,\n\tDot: Dot$1,\n\tdot: dot$1,\n\tDotDot: DotDot$1,\n\tdoteq: doteq$1,\n\tdoteqdot: doteqdot$1,\n\tDotEqual: DotEqual$1,\n\tdotminus: dotminus$1,\n\tdotplus: dotplus$1,\n\tdotsquare: dotsquare$1,\n\tdoublebarwedge: doublebarwedge$1,\n\tDoubleContourIntegral: DoubleContourIntegral$1,\n\tDoubleDot: DoubleDot$1,\n\tDoubleDownArrow: DoubleDownArrow$1,\n\tDoubleLeftArrow: DoubleLeftArrow$1,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow$1,\n\tDoubleLeftTee: DoubleLeftTee$1,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow$1,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,\n\tDoubleLongRightArrow: DoubleLongRightArrow$1,\n\tDoubleRightArrow: DoubleRightArrow$1,\n\tDoubleRightTee: DoubleRightTee$1,\n\tDoubleUpArrow: DoubleUpArrow$1,\n\tDoubleUpDownArrow: DoubleUpDownArrow$1,\n\tDoubleVerticalBar: DoubleVerticalBar$1,\n\tDownArrowBar: DownArrowBar$1,\n\tdownarrow: downarrow$1,\n\tDownArrow: DownArrow$1,\n\tDownarrow: Downarrow$1,\n\tDownArrowUpArrow: DownArrowUpArrow$1,\n\tDownBreve: DownBreve$1,\n\tdowndownarrows: downdownarrows$1,\n\tdownharpoonleft: downharpoonleft$1,\n\tdownharpoonright: downharpoonright$1,\n\tDownLeftRightVector: DownLeftRightVector$1,\n\tDownLeftTeeVector: DownLeftTeeVector$1,\n\tDownLeftVectorBar: DownLeftVectorBar$1,\n\tDownLeftVector: DownLeftVector$1,\n\tDownRightTeeVector: DownRightTeeVector$1,\n\tDownRightVectorBar: DownRightVectorBar$1,\n\tDownRightVector: DownRightVector$1,\n\tDownTeeArrow: DownTeeArrow$1,\n\tDownTee: DownTee$1,\n\tdrbkarow: drbkarow$1,\n\tdrcorn: drcorn$1,\n\tdrcrop: drcrop$1,\n\tDscr: Dscr$1,\n\tdscr: dscr$1,\n\tDScy: DScy$1,\n\tdscy: dscy$1,\n\tdsol: dsol$1,\n\tDstrok: Dstrok$1,\n\tdstrok: dstrok$1,\n\tdtdot: dtdot$1,\n\tdtri: dtri$1,\n\tdtrif: dtrif$1,\n\tduarr: duarr$1,\n\tduhar: duhar$1,\n\tdwangle: dwangle$1,\n\tDZcy: DZcy$1,\n\tdzcy: dzcy$1,\n\tdzigrarr: dzigrarr$1,\n\tEacute: Eacute$3,\n\teacute: eacute$3,\n\teaster: easter$1,\n\tEcaron: Ecaron$1,\n\tecaron: ecaron$1,\n\tEcirc: Ecirc$3,\n\tecirc: ecirc$3,\n\tecir: ecir$1,\n\tecolon: ecolon$1,\n\tEcy: Ecy$1,\n\tecy: ecy$1,\n\teDDot: eDDot$1,\n\tEdot: Edot$1,\n\tedot: edot$1,\n\teDot: eDot$1,\n\tee: ee$1,\n\tefDot: efDot$1,\n\tEfr: Efr$1,\n\tefr: efr$1,\n\teg: eg$1,\n\tEgrave: Egrave$3,\n\tegrave: egrave$3,\n\tegs: egs$1,\n\tegsdot: egsdot$1,\n\tel: el$1,\n\tElement: Element$2,\n\telinters: elinters$1,\n\tell: ell$1,\n\tels: els$1,\n\telsdot: elsdot$1,\n\tEmacr: Emacr$1,\n\temacr: emacr$1,\n\tempty: empty$1,\n\temptyset: emptyset$1,\n\tEmptySmallSquare: EmptySmallSquare$1,\n\temptyv: emptyv$1,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare$1,\n\temsp13: emsp13$1,\n\temsp14: emsp14$1,\n\temsp: emsp$1,\n\tENG: ENG$1,\n\teng: eng$1,\n\tensp: ensp$1,\n\tEogon: Eogon$1,\n\teogon: eogon$1,\n\tEopf: Eopf$1,\n\teopf: eopf$1,\n\tepar: epar$1,\n\teparsl: eparsl$1,\n\teplus: eplus$1,\n\tepsi: epsi$1,\n\tEpsilon: Epsilon$1,\n\tepsilon: epsilon$1,\n\tepsiv: epsiv$1,\n\teqcirc: eqcirc$1,\n\teqcolon: eqcolon$1,\n\teqsim: eqsim$1,\n\teqslantgtr: eqslantgtr$1,\n\teqslantless: eqslantless$1,\n\tEqual: Equal$1,\n\tequals: equals$1,\n\tEqualTilde: EqualTilde$1,\n\tequest: equest$1,\n\tEquilibrium: Equilibrium$1,\n\tequiv: equiv$1,\n\tequivDD: equivDD$1,\n\teqvparsl: eqvparsl$1,\n\terarr: erarr$1,\n\terDot: erDot$1,\n\tescr: escr$1,\n\tEscr: Escr$1,\n\tesdot: esdot$1,\n\tEsim: Esim$1,\n\tesim: esim$1,\n\tEta: Eta$1,\n\teta: eta$1,\n\tETH: ETH$3,\n\teth: eth$3,\n\tEuml: Euml$3,\n\teuml: euml$3,\n\teuro: euro$1,\n\texcl: excl$1,\n\texist: exist$1,\n\tExists: Exists$1,\n\texpectation: expectation$1,\n\texponentiale: exponentiale$1,\n\tExponentialE: ExponentialE$1,\n\tfallingdotseq: fallingdotseq$1,\n\tFcy: Fcy$1,\n\tfcy: fcy$1,\n\tfemale: female$1,\n\tffilig: ffilig$1,\n\tfflig: fflig$1,\n\tffllig: ffllig$1,\n\tFfr: Ffr$1,\n\tffr: ffr$1,\n\tfilig: filig$1,\n\tFilledSmallSquare: FilledSmallSquare$1,\n\tFilledVerySmallSquare: FilledVerySmallSquare$1,\n\tfjlig: fjlig$1,\n\tflat: flat$1,\n\tfllig: fllig$1,\n\tfltns: fltns$1,\n\tfnof: fnof$1,\n\tFopf: Fopf$1,\n\tfopf: fopf$1,\n\tforall: forall$1,\n\tForAll: ForAll$1,\n\tfork: fork$1,\n\tforkv: forkv$1,\n\tFouriertrf: Fouriertrf$1,\n\tfpartint: fpartint$1,\n\tfrac12: frac12$3,\n\tfrac13: frac13$1,\n\tfrac14: frac14$3,\n\tfrac15: frac15$1,\n\tfrac16: frac16$1,\n\tfrac18: frac18$1,\n\tfrac23: frac23$1,\n\tfrac25: frac25$1,\n\tfrac34: frac34$3,\n\tfrac35: frac35$1,\n\tfrac38: frac38$1,\n\tfrac45: frac45$1,\n\tfrac56: frac56$1,\n\tfrac58: frac58$1,\n\tfrac78: frac78$1,\n\tfrasl: frasl$1,\n\tfrown: frown$1,\n\tfscr: fscr$1,\n\tFscr: Fscr$1,\n\tgacute: gacute$1,\n\tGamma: Gamma$1,\n\tgamma: gamma$1,\n\tGammad: Gammad$1,\n\tgammad: gammad$1,\n\tgap: gap$1,\n\tGbreve: Gbreve$1,\n\tgbreve: gbreve$1,\n\tGcedil: Gcedil$1,\n\tGcirc: Gcirc$1,\n\tgcirc: gcirc$1,\n\tGcy: Gcy$1,\n\tgcy: gcy$1,\n\tGdot: Gdot$1,\n\tgdot: gdot$1,\n\tge: ge$1,\n\tgE: gE$1,\n\tgEl: gEl$1,\n\tgel: gel$1,\n\tgeq: geq$1,\n\tgeqq: geqq$1,\n\tgeqslant: geqslant$1,\n\tgescc: gescc$1,\n\tges: ges$1,\n\tgesdot: gesdot$1,\n\tgesdoto: gesdoto$1,\n\tgesdotol: gesdotol$1,\n\tgesl: gesl$1,\n\tgesles: gesles$1,\n\tGfr: Gfr$1,\n\tgfr: gfr$1,\n\tgg: gg$1,\n\tGg: Gg$1,\n\tggg: ggg$1,\n\tgimel: gimel$1,\n\tGJcy: GJcy$1,\n\tgjcy: gjcy$1,\n\tgla: gla$1,\n\tgl: gl$1,\n\tglE: glE$1,\n\tglj: glj$1,\n\tgnap: gnap$1,\n\tgnapprox: gnapprox$1,\n\tgne: gne$1,\n\tgnE: gnE$1,\n\tgneq: gneq$1,\n\tgneqq: gneqq$1,\n\tgnsim: gnsim$1,\n\tGopf: Gopf$1,\n\tgopf: gopf$1,\n\tgrave: grave$1,\n\tGreaterEqual: GreaterEqual$1,\n\tGreaterEqualLess: GreaterEqualLess$1,\n\tGreaterFullEqual: GreaterFullEqual$1,\n\tGreaterGreater: GreaterGreater$1,\n\tGreaterLess: GreaterLess$1,\n\tGreaterSlantEqual: GreaterSlantEqual$1,\n\tGreaterTilde: GreaterTilde$1,\n\tGscr: Gscr$1,\n\tgscr: gscr$1,\n\tgsim: gsim$1,\n\tgsime: gsime$1,\n\tgsiml: gsiml$1,\n\tgtcc: gtcc$1,\n\tgtcir: gtcir$1,\n\tgt: gt$5,\n\tGT: GT$3,\n\tGt: Gt$1,\n\tgtdot: gtdot$1,\n\tgtlPar: gtlPar$1,\n\tgtquest: gtquest$1,\n\tgtrapprox: gtrapprox$1,\n\tgtrarr: gtrarr$1,\n\tgtrdot: gtrdot$1,\n\tgtreqless: gtreqless$1,\n\tgtreqqless: gtreqqless$1,\n\tgtrless: gtrless$1,\n\tgtrsim: gtrsim$1,\n\tgvertneqq: gvertneqq$1,\n\tgvnE: gvnE$1,\n\tHacek: Hacek$1,\n\thairsp: hairsp$1,\n\thalf: half$1,\n\thamilt: hamilt$1,\n\tHARDcy: HARDcy$1,\n\thardcy: hardcy$1,\n\tharrcir: harrcir$1,\n\tharr: harr$1,\n\thArr: hArr$1,\n\tharrw: harrw$1,\n\tHat: Hat$1,\n\thbar: hbar$1,\n\tHcirc: Hcirc$1,\n\thcirc: hcirc$1,\n\thearts: hearts$1,\n\theartsuit: heartsuit$1,\n\thellip: hellip$1,\n\thercon: hercon$1,\n\thfr: hfr$1,\n\tHfr: Hfr$1,\n\tHilbertSpace: HilbertSpace$1,\n\thksearow: hksearow$1,\n\thkswarow: hkswarow$1,\n\thoarr: hoarr$1,\n\thomtht: homtht$1,\n\thookleftarrow: hookleftarrow$1,\n\thookrightarrow: hookrightarrow$1,\n\thopf: hopf$1,\n\tHopf: Hopf$1,\n\thorbar: horbar$1,\n\tHorizontalLine: HorizontalLine$1,\n\thscr: hscr$1,\n\tHscr: Hscr$1,\n\thslash: hslash$1,\n\tHstrok: Hstrok$1,\n\thstrok: hstrok$1,\n\tHumpDownHump: HumpDownHump$1,\n\tHumpEqual: HumpEqual$1,\n\thybull: hybull$1,\n\thyphen: hyphen$1,\n\tIacute: Iacute$3,\n\tiacute: iacute$3,\n\tic: ic$1,\n\tIcirc: Icirc$3,\n\ticirc: icirc$3,\n\tIcy: Icy$1,\n\ticy: icy$1,\n\tIdot: Idot$1,\n\tIEcy: IEcy$1,\n\tiecy: iecy$1,\n\tiexcl: iexcl$3,\n\tiff: iff$1,\n\tifr: ifr$1,\n\tIfr: Ifr$1,\n\tIgrave: Igrave$3,\n\tigrave: igrave$3,\n\tii: ii$1,\n\tiiiint: iiiint$1,\n\tiiint: iiint$1,\n\tiinfin: iinfin$1,\n\tiiota: iiota$1,\n\tIJlig: IJlig$1,\n\tijlig: ijlig$1,\n\tImacr: Imacr$1,\n\timacr: imacr$1,\n\timage: image$1,\n\tImaginaryI: ImaginaryI$1,\n\timagline: imagline$1,\n\timagpart: imagpart$1,\n\timath: imath$1,\n\tIm: Im$1,\n\timof: imof$1,\n\timped: imped$1,\n\tImplies: Implies$1,\n\tincare: incare$1,\n\t\"in\": \"∈\",\n\tinfin: infin$1,\n\tinfintie: infintie$1,\n\tinodot: inodot$1,\n\tintcal: intcal$1,\n\tint: int$1,\n\tInt: Int$1,\n\tintegers: integers$1,\n\tIntegral: Integral$1,\n\tintercal: intercal$1,\n\tIntersection: Intersection$1,\n\tintlarhk: intlarhk$1,\n\tintprod: intprod$1,\n\tInvisibleComma: InvisibleComma$1,\n\tInvisibleTimes: InvisibleTimes$1,\n\tIOcy: IOcy$1,\n\tiocy: iocy$1,\n\tIogon: Iogon$1,\n\tiogon: iogon$1,\n\tIopf: Iopf$1,\n\tiopf: iopf$1,\n\tIota: Iota$1,\n\tiota: iota$1,\n\tiprod: iprod$1,\n\tiquest: iquest$3,\n\tiscr: iscr$1,\n\tIscr: Iscr$1,\n\tisin: isin$1,\n\tisindot: isindot$1,\n\tisinE: isinE$1,\n\tisins: isins$1,\n\tisinsv: isinsv$1,\n\tisinv: isinv$1,\n\tit: it$1,\n\tItilde: Itilde$1,\n\titilde: itilde$1,\n\tIukcy: Iukcy$1,\n\tiukcy: iukcy$1,\n\tIuml: Iuml$3,\n\tiuml: iuml$3,\n\tJcirc: Jcirc$1,\n\tjcirc: jcirc$1,\n\tJcy: Jcy$1,\n\tjcy: jcy$1,\n\tJfr: Jfr$1,\n\tjfr: jfr$1,\n\tjmath: jmath$1,\n\tJopf: Jopf$1,\n\tjopf: jopf$1,\n\tJscr: Jscr$1,\n\tjscr: jscr$1,\n\tJsercy: Jsercy$1,\n\tjsercy: jsercy$1,\n\tJukcy: Jukcy$1,\n\tjukcy: jukcy$1,\n\tKappa: Kappa$1,\n\tkappa: kappa$1,\n\tkappav: kappav$1,\n\tKcedil: Kcedil$1,\n\tkcedil: kcedil$1,\n\tKcy: Kcy$1,\n\tkcy: kcy$1,\n\tKfr: Kfr$1,\n\tkfr: kfr$1,\n\tkgreen: kgreen$1,\n\tKHcy: KHcy$1,\n\tkhcy: khcy$1,\n\tKJcy: KJcy$1,\n\tkjcy: kjcy$1,\n\tKopf: Kopf$1,\n\tkopf: kopf$1,\n\tKscr: Kscr$1,\n\tkscr: kscr$1,\n\tlAarr: lAarr$1,\n\tLacute: Lacute$1,\n\tlacute: lacute$1,\n\tlaemptyv: laemptyv$1,\n\tlagran: lagran$1,\n\tLambda: Lambda$1,\n\tlambda: lambda$1,\n\tlang: lang$1,\n\tLang: Lang$1,\n\tlangd: langd$1,\n\tlangle: langle$1,\n\tlap: lap$1,\n\tLaplacetrf: Laplacetrf$1,\n\tlaquo: laquo$3,\n\tlarrb: larrb$1,\n\tlarrbfs: larrbfs$1,\n\tlarr: larr$1,\n\tLarr: Larr$1,\n\tlArr: lArr$1,\n\tlarrfs: larrfs$1,\n\tlarrhk: larrhk$1,\n\tlarrlp: larrlp$1,\n\tlarrpl: larrpl$1,\n\tlarrsim: larrsim$1,\n\tlarrtl: larrtl$1,\n\tlatail: latail$1,\n\tlAtail: lAtail$1,\n\tlat: lat$1,\n\tlate: late$1,\n\tlates: lates$1,\n\tlbarr: lbarr$1,\n\tlBarr: lBarr$1,\n\tlbbrk: lbbrk$1,\n\tlbrace: lbrace$1,\n\tlbrack: lbrack$1,\n\tlbrke: lbrke$1,\n\tlbrksld: lbrksld$1,\n\tlbrkslu: lbrkslu$1,\n\tLcaron: Lcaron$1,\n\tlcaron: lcaron$1,\n\tLcedil: Lcedil$1,\n\tlcedil: lcedil$1,\n\tlceil: lceil$1,\n\tlcub: lcub$1,\n\tLcy: Lcy$1,\n\tlcy: lcy$1,\n\tldca: ldca$1,\n\tldquo: ldquo$1,\n\tldquor: ldquor$1,\n\tldrdhar: ldrdhar$1,\n\tldrushar: ldrushar$1,\n\tldsh: ldsh$1,\n\tle: le$1,\n\tlE: lE$1,\n\tLeftAngleBracket: LeftAngleBracket$1,\n\tLeftArrowBar: LeftArrowBar$1,\n\tleftarrow: leftarrow$1,\n\tLeftArrow: LeftArrow$1,\n\tLeftarrow: Leftarrow$1,\n\tLeftArrowRightArrow: LeftArrowRightArrow$1,\n\tleftarrowtail: leftarrowtail$1,\n\tLeftCeiling: LeftCeiling$1,\n\tLeftDoubleBracket: LeftDoubleBracket$1,\n\tLeftDownTeeVector: LeftDownTeeVector$1,\n\tLeftDownVectorBar: LeftDownVectorBar$1,\n\tLeftDownVector: LeftDownVector$1,\n\tLeftFloor: LeftFloor$1,\n\tleftharpoondown: leftharpoondown$1,\n\tleftharpoonup: leftharpoonup$1,\n\tleftleftarrows: leftleftarrows$1,\n\tleftrightarrow: leftrightarrow$1,\n\tLeftRightArrow: LeftRightArrow$1,\n\tLeftrightarrow: Leftrightarrow$1,\n\tleftrightarrows: leftrightarrows$1,\n\tleftrightharpoons: leftrightharpoons$1,\n\tleftrightsquigarrow: leftrightsquigarrow$1,\n\tLeftRightVector: LeftRightVector$1,\n\tLeftTeeArrow: LeftTeeArrow$1,\n\tLeftTee: LeftTee$1,\n\tLeftTeeVector: LeftTeeVector$1,\n\tleftthreetimes: leftthreetimes$1,\n\tLeftTriangleBar: LeftTriangleBar$1,\n\tLeftTriangle: LeftTriangle$1,\n\tLeftTriangleEqual: LeftTriangleEqual$1,\n\tLeftUpDownVector: LeftUpDownVector$1,\n\tLeftUpTeeVector: LeftUpTeeVector$1,\n\tLeftUpVectorBar: LeftUpVectorBar$1,\n\tLeftUpVector: LeftUpVector$1,\n\tLeftVectorBar: LeftVectorBar$1,\n\tLeftVector: LeftVector$1,\n\tlEg: lEg$1,\n\tleg: leg$1,\n\tleq: leq$1,\n\tleqq: leqq$1,\n\tleqslant: leqslant$1,\n\tlescc: lescc$1,\n\tles: les$1,\n\tlesdot: lesdot$1,\n\tlesdoto: lesdoto$1,\n\tlesdotor: lesdotor$1,\n\tlesg: lesg$1,\n\tlesges: lesges$1,\n\tlessapprox: lessapprox$1,\n\tlessdot: lessdot$1,\n\tlesseqgtr: lesseqgtr$1,\n\tlesseqqgtr: lesseqqgtr$1,\n\tLessEqualGreater: LessEqualGreater$1,\n\tLessFullEqual: LessFullEqual$1,\n\tLessGreater: LessGreater$1,\n\tlessgtr: lessgtr$1,\n\tLessLess: LessLess$1,\n\tlesssim: lesssim$1,\n\tLessSlantEqual: LessSlantEqual$1,\n\tLessTilde: LessTilde$1,\n\tlfisht: lfisht$1,\n\tlfloor: lfloor$1,\n\tLfr: Lfr$1,\n\tlfr: lfr$1,\n\tlg: lg$1,\n\tlgE: lgE$1,\n\tlHar: lHar$1,\n\tlhard: lhard$1,\n\tlharu: lharu$1,\n\tlharul: lharul$1,\n\tlhblk: lhblk$1,\n\tLJcy: LJcy$1,\n\tljcy: ljcy$1,\n\tllarr: llarr$1,\n\tll: ll$1,\n\tLl: Ll$1,\n\tllcorner: llcorner$1,\n\tLleftarrow: Lleftarrow$1,\n\tllhard: llhard$1,\n\tlltri: lltri$1,\n\tLmidot: Lmidot$1,\n\tlmidot: lmidot$1,\n\tlmoustache: lmoustache$1,\n\tlmoust: lmoust$1,\n\tlnap: lnap$1,\n\tlnapprox: lnapprox$1,\n\tlne: lne$1,\n\tlnE: lnE$1,\n\tlneq: lneq$1,\n\tlneqq: lneqq$1,\n\tlnsim: lnsim$1,\n\tloang: loang$1,\n\tloarr: loarr$1,\n\tlobrk: lobrk$1,\n\tlongleftarrow: longleftarrow$1,\n\tLongLeftArrow: LongLeftArrow$1,\n\tLongleftarrow: Longleftarrow$1,\n\tlongleftrightarrow: longleftrightarrow$1,\n\tLongLeftRightArrow: LongLeftRightArrow$1,\n\tLongleftrightarrow: Longleftrightarrow$1,\n\tlongmapsto: longmapsto$1,\n\tlongrightarrow: longrightarrow$1,\n\tLongRightArrow: LongRightArrow$1,\n\tLongrightarrow: Longrightarrow$1,\n\tlooparrowleft: looparrowleft$1,\n\tlooparrowright: looparrowright$1,\n\tlopar: lopar$1,\n\tLopf: Lopf$1,\n\tlopf: lopf$1,\n\tloplus: loplus$1,\n\tlotimes: lotimes$1,\n\tlowast: lowast$1,\n\tlowbar: lowbar$1,\n\tLowerLeftArrow: LowerLeftArrow$1,\n\tLowerRightArrow: LowerRightArrow$1,\n\tloz: loz$1,\n\tlozenge: lozenge$1,\n\tlozf: lozf$1,\n\tlpar: lpar$1,\n\tlparlt: lparlt$1,\n\tlrarr: lrarr$1,\n\tlrcorner: lrcorner$1,\n\tlrhar: lrhar$1,\n\tlrhard: lrhard$1,\n\tlrm: lrm$1,\n\tlrtri: lrtri$1,\n\tlsaquo: lsaquo$1,\n\tlscr: lscr$1,\n\tLscr: Lscr$1,\n\tlsh: lsh$1,\n\tLsh: Lsh$1,\n\tlsim: lsim$1,\n\tlsime: lsime$1,\n\tlsimg: lsimg$1,\n\tlsqb: lsqb$1,\n\tlsquo: lsquo$1,\n\tlsquor: lsquor$1,\n\tLstrok: Lstrok$1,\n\tlstrok: lstrok$1,\n\tltcc: ltcc$1,\n\tltcir: ltcir$1,\n\tlt: lt$5,\n\tLT: LT$3,\n\tLt: Lt$1,\n\tltdot: ltdot$1,\n\tlthree: lthree$1,\n\tltimes: ltimes$1,\n\tltlarr: ltlarr$1,\n\tltquest: ltquest$1,\n\tltri: ltri$1,\n\tltrie: ltrie$1,\n\tltrif: ltrif$1,\n\tltrPar: ltrPar$1,\n\tlurdshar: lurdshar$1,\n\tluruhar: luruhar$1,\n\tlvertneqq: lvertneqq$1,\n\tlvnE: lvnE$1,\n\tmacr: macr$3,\n\tmale: male$1,\n\tmalt: malt$1,\n\tmaltese: maltese$1,\n\t\"Map\": \"⤅\",\n\tmap: map$2,\n\tmapsto: mapsto$1,\n\tmapstodown: mapstodown$1,\n\tmapstoleft: mapstoleft$1,\n\tmapstoup: mapstoup$1,\n\tmarker: marker$1,\n\tmcomma: mcomma$1,\n\tMcy: Mcy$1,\n\tmcy: mcy$1,\n\tmdash: mdash$1,\n\tmDDot: mDDot$1,\n\tmeasuredangle: measuredangle$1,\n\tMediumSpace: MediumSpace$1,\n\tMellintrf: Mellintrf$1,\n\tMfr: Mfr$1,\n\tmfr: mfr$1,\n\tmho: mho$1,\n\tmicro: micro$3,\n\tmidast: midast$1,\n\tmidcir: midcir$1,\n\tmid: mid$1,\n\tmiddot: middot$3,\n\tminusb: minusb$1,\n\tminus: minus$1,\n\tminusd: minusd$1,\n\tminusdu: minusdu$1,\n\tMinusPlus: MinusPlus$1,\n\tmlcp: mlcp$1,\n\tmldr: mldr$1,\n\tmnplus: mnplus$1,\n\tmodels: models$1,\n\tMopf: Mopf$1,\n\tmopf: mopf$1,\n\tmp: mp$1,\n\tmscr: mscr$1,\n\tMscr: Mscr$1,\n\tmstpos: mstpos$1,\n\tMu: Mu$1,\n\tmu: mu$1,\n\tmultimap: multimap$1,\n\tmumap: mumap$1,\n\tnabla: nabla$1,\n\tNacute: Nacute$1,\n\tnacute: nacute$1,\n\tnang: nang$1,\n\tnap: nap$1,\n\tnapE: napE$1,\n\tnapid: napid$1,\n\tnapos: napos$1,\n\tnapprox: napprox$1,\n\tnatural: natural$1,\n\tnaturals: naturals$1,\n\tnatur: natur$1,\n\tnbsp: nbsp$3,\n\tnbump: nbump$1,\n\tnbumpe: nbumpe$1,\n\tncap: ncap$1,\n\tNcaron: Ncaron$1,\n\tncaron: ncaron$1,\n\tNcedil: Ncedil$1,\n\tncedil: ncedil$1,\n\tncong: ncong$1,\n\tncongdot: ncongdot$1,\n\tncup: ncup$1,\n\tNcy: Ncy$1,\n\tncy: ncy$1,\n\tndash: ndash$1,\n\tnearhk: nearhk$1,\n\tnearr: nearr$1,\n\tneArr: neArr$1,\n\tnearrow: nearrow$1,\n\tne: ne$1,\n\tnedot: nedot$1,\n\tNegativeMediumSpace: NegativeMediumSpace$1,\n\tNegativeThickSpace: NegativeThickSpace$1,\n\tNegativeThinSpace: NegativeThinSpace$1,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace$1,\n\tnequiv: nequiv$1,\n\tnesear: nesear$1,\n\tnesim: nesim$1,\n\tNestedGreaterGreater: NestedGreaterGreater$1,\n\tNestedLessLess: NestedLessLess$1,\n\tNewLine: NewLine$1,\n\tnexist: nexist$1,\n\tnexists: nexists$1,\n\tNfr: Nfr$1,\n\tnfr: nfr$1,\n\tngE: ngE$1,\n\tnge: nge$1,\n\tngeq: ngeq$1,\n\tngeqq: ngeqq$1,\n\tngeqslant: ngeqslant$1,\n\tnges: nges$1,\n\tnGg: nGg$1,\n\tngsim: ngsim$1,\n\tnGt: nGt$1,\n\tngt: ngt$1,\n\tngtr: ngtr$1,\n\tnGtv: nGtv$1,\n\tnharr: nharr$1,\n\tnhArr: nhArr$1,\n\tnhpar: nhpar$1,\n\tni: ni$1,\n\tnis: nis$1,\n\tnisd: nisd$1,\n\tniv: niv$1,\n\tNJcy: NJcy$1,\n\tnjcy: njcy$1,\n\tnlarr: nlarr$1,\n\tnlArr: nlArr$1,\n\tnldr: nldr$1,\n\tnlE: nlE$1,\n\tnle: nle$1,\n\tnleftarrow: nleftarrow$1,\n\tnLeftarrow: nLeftarrow$1,\n\tnleftrightarrow: nleftrightarrow$1,\n\tnLeftrightarrow: nLeftrightarrow$1,\n\tnleq: nleq$1,\n\tnleqq: nleqq$1,\n\tnleqslant: nleqslant$1,\n\tnles: nles$1,\n\tnless: nless$1,\n\tnLl: nLl$1,\n\tnlsim: nlsim$1,\n\tnLt: nLt$1,\n\tnlt: nlt$1,\n\tnltri: nltri$1,\n\tnltrie: nltrie$1,\n\tnLtv: nLtv$1,\n\tnmid: nmid$1,\n\tNoBreak: NoBreak$1,\n\tNonBreakingSpace: NonBreakingSpace$1,\n\tnopf: nopf$1,\n\tNopf: Nopf$1,\n\tNot: Not$1,\n\tnot: not$3,\n\tNotCongruent: NotCongruent$1,\n\tNotCupCap: NotCupCap$1,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar$1,\n\tNotElement: NotElement$1,\n\tNotEqual: NotEqual$1,\n\tNotEqualTilde: NotEqualTilde$1,\n\tNotExists: NotExists$1,\n\tNotGreater: NotGreater$1,\n\tNotGreaterEqual: NotGreaterEqual$1,\n\tNotGreaterFullEqual: NotGreaterFullEqual$1,\n\tNotGreaterGreater: NotGreaterGreater$1,\n\tNotGreaterLess: NotGreaterLess$1,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual$1,\n\tNotGreaterTilde: NotGreaterTilde$1,\n\tNotHumpDownHump: NotHumpDownHump$1,\n\tNotHumpEqual: NotHumpEqual$1,\n\tnotin: notin$1,\n\tnotindot: notindot$1,\n\tnotinE: notinE$1,\n\tnotinva: notinva$1,\n\tnotinvb: notinvb$1,\n\tnotinvc: notinvc$1,\n\tNotLeftTriangleBar: NotLeftTriangleBar$1,\n\tNotLeftTriangle: NotLeftTriangle$1,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual$1,\n\tNotLess: NotLess$1,\n\tNotLessEqual: NotLessEqual$1,\n\tNotLessGreater: NotLessGreater$1,\n\tNotLessLess: NotLessLess$1,\n\tNotLessSlantEqual: NotLessSlantEqual$1,\n\tNotLessTilde: NotLessTilde$1,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater$1,\n\tNotNestedLessLess: NotNestedLessLess$1,\n\tnotni: notni$1,\n\tnotniva: notniva$1,\n\tnotnivb: notnivb$1,\n\tnotnivc: notnivc$1,\n\tNotPrecedes: NotPrecedes$1,\n\tNotPrecedesEqual: NotPrecedesEqual$1,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual$1,\n\tNotReverseElement: NotReverseElement$1,\n\tNotRightTriangleBar: NotRightTriangleBar$1,\n\tNotRightTriangle: NotRightTriangle$1,\n\tNotRightTriangleEqual: NotRightTriangleEqual$1,\n\tNotSquareSubset: NotSquareSubset$1,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual$1,\n\tNotSquareSuperset: NotSquareSuperset$1,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual$1,\n\tNotSubset: NotSubset$1,\n\tNotSubsetEqual: NotSubsetEqual$1,\n\tNotSucceeds: NotSucceeds$1,\n\tNotSucceedsEqual: NotSucceedsEqual$1,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual$1,\n\tNotSucceedsTilde: NotSucceedsTilde$1,\n\tNotSuperset: NotSuperset$1,\n\tNotSupersetEqual: NotSupersetEqual$1,\n\tNotTilde: NotTilde$1,\n\tNotTildeEqual: NotTildeEqual$1,\n\tNotTildeFullEqual: NotTildeFullEqual$1,\n\tNotTildeTilde: NotTildeTilde$1,\n\tNotVerticalBar: NotVerticalBar$1,\n\tnparallel: nparallel$1,\n\tnpar: npar$1,\n\tnparsl: nparsl$1,\n\tnpart: npart$1,\n\tnpolint: npolint$1,\n\tnpr: npr$1,\n\tnprcue: nprcue$1,\n\tnprec: nprec$1,\n\tnpreceq: npreceq$1,\n\tnpre: npre$1,\n\tnrarrc: nrarrc$1,\n\tnrarr: nrarr$1,\n\tnrArr: nrArr$1,\n\tnrarrw: nrarrw$1,\n\tnrightarrow: nrightarrow$1,\n\tnRightarrow: nRightarrow$1,\n\tnrtri: nrtri$1,\n\tnrtrie: nrtrie$1,\n\tnsc: nsc$1,\n\tnsccue: nsccue$1,\n\tnsce: nsce$1,\n\tNscr: Nscr$1,\n\tnscr: nscr$1,\n\tnshortmid: nshortmid$1,\n\tnshortparallel: nshortparallel$1,\n\tnsim: nsim$1,\n\tnsime: nsime$1,\n\tnsimeq: nsimeq$1,\n\tnsmid: nsmid$1,\n\tnspar: nspar$1,\n\tnsqsube: nsqsube$1,\n\tnsqsupe: nsqsupe$1,\n\tnsub: nsub$1,\n\tnsubE: nsubE$1,\n\tnsube: nsube$1,\n\tnsubset: nsubset$1,\n\tnsubseteq: nsubseteq$1,\n\tnsubseteqq: nsubseteqq$1,\n\tnsucc: nsucc$1,\n\tnsucceq: nsucceq$1,\n\tnsup: nsup$1,\n\tnsupE: nsupE$1,\n\tnsupe: nsupe$1,\n\tnsupset: nsupset$1,\n\tnsupseteq: nsupseteq$1,\n\tnsupseteqq: nsupseteqq$1,\n\tntgl: ntgl$1,\n\tNtilde: Ntilde$3,\n\tntilde: ntilde$3,\n\tntlg: ntlg$1,\n\tntriangleleft: ntriangleleft$1,\n\tntrianglelefteq: ntrianglelefteq$1,\n\tntriangleright: ntriangleright$1,\n\tntrianglerighteq: ntrianglerighteq$1,\n\tNu: Nu$1,\n\tnu: nu$1,\n\tnum: num$1,\n\tnumero: numero$1,\n\tnumsp: numsp$1,\n\tnvap: nvap$1,\n\tnvdash: nvdash$1,\n\tnvDash: nvDash$1,\n\tnVdash: nVdash$1,\n\tnVDash: nVDash$1,\n\tnvge: nvge$1,\n\tnvgt: nvgt$1,\n\tnvHarr: nvHarr$1,\n\tnvinfin: nvinfin$1,\n\tnvlArr: nvlArr$1,\n\tnvle: nvle$1,\n\tnvlt: nvlt$1,\n\tnvltrie: nvltrie$1,\n\tnvrArr: nvrArr$1,\n\tnvrtrie: nvrtrie$1,\n\tnvsim: nvsim$1,\n\tnwarhk: nwarhk$1,\n\tnwarr: nwarr$1,\n\tnwArr: nwArr$1,\n\tnwarrow: nwarrow$1,\n\tnwnear: nwnear$1,\n\tOacute: Oacute$3,\n\toacute: oacute$3,\n\toast: oast$1,\n\tOcirc: Ocirc$3,\n\tocirc: ocirc$3,\n\tocir: ocir$1,\n\tOcy: Ocy$1,\n\tocy: ocy$1,\n\todash: odash$1,\n\tOdblac: Odblac$1,\n\todblac: odblac$1,\n\todiv: odiv$1,\n\todot: odot$1,\n\todsold: odsold$1,\n\tOElig: OElig$1,\n\toelig: oelig$1,\n\tofcir: ofcir$1,\n\tOfr: Ofr$1,\n\tofr: ofr$1,\n\togon: ogon$1,\n\tOgrave: Ograve$3,\n\tograve: ograve$3,\n\togt: ogt$1,\n\tohbar: ohbar$1,\n\tohm: ohm$1,\n\toint: oint$1,\n\tolarr: olarr$1,\n\tolcir: olcir$1,\n\tolcross: olcross$1,\n\toline: oline$1,\n\tolt: olt$1,\n\tOmacr: Omacr$1,\n\tomacr: omacr$1,\n\tOmega: Omega$1,\n\tomega: omega$1,\n\tOmicron: Omicron$1,\n\tomicron: omicron$1,\n\tomid: omid$1,\n\tominus: ominus$1,\n\tOopf: Oopf$1,\n\toopf: oopf$1,\n\topar: opar$1,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,\n\tOpenCurlyQuote: OpenCurlyQuote$1,\n\toperp: operp$1,\n\toplus: oplus$1,\n\torarr: orarr$1,\n\tOr: Or$1,\n\tor: or$1,\n\tord: ord$1,\n\torder: order$1,\n\torderof: orderof$1,\n\tordf: ordf$3,\n\tordm: ordm$3,\n\torigof: origof$1,\n\toror: oror$1,\n\torslope: orslope$1,\n\torv: orv$1,\n\toS: oS$1,\n\tOscr: Oscr$1,\n\toscr: oscr$1,\n\tOslash: Oslash$3,\n\toslash: oslash$3,\n\tosol: osol$1,\n\tOtilde: Otilde$3,\n\totilde: otilde$3,\n\totimesas: otimesas$1,\n\tOtimes: Otimes$1,\n\totimes: otimes$1,\n\tOuml: Ouml$3,\n\touml: ouml$3,\n\tovbar: ovbar$1,\n\tOverBar: OverBar$1,\n\tOverBrace: OverBrace$1,\n\tOverBracket: OverBracket$1,\n\tOverParenthesis: OverParenthesis$1,\n\tpara: para$3,\n\tparallel: parallel$1,\n\tpar: par$1,\n\tparsim: parsim$1,\n\tparsl: parsl$1,\n\tpart: part$1,\n\tPartialD: PartialD$1,\n\tPcy: Pcy$1,\n\tpcy: pcy$1,\n\tpercnt: percnt$1,\n\tperiod: period$1,\n\tpermil: permil$1,\n\tperp: perp$1,\n\tpertenk: pertenk$1,\n\tPfr: Pfr$1,\n\tpfr: pfr$1,\n\tPhi: Phi$1,\n\tphi: phi$1,\n\tphiv: phiv$1,\n\tphmmat: phmmat$1,\n\tphone: phone$1,\n\tPi: Pi$1,\n\tpi: pi$1,\n\tpitchfork: pitchfork$1,\n\tpiv: piv$1,\n\tplanck: planck$1,\n\tplanckh: planckh$1,\n\tplankv: plankv$1,\n\tplusacir: plusacir$1,\n\tplusb: plusb$1,\n\tpluscir: pluscir$1,\n\tplus: plus$1,\n\tplusdo: plusdo$1,\n\tplusdu: plusdu$1,\n\tpluse: pluse$1,\n\tPlusMinus: PlusMinus$1,\n\tplusmn: plusmn$3,\n\tplussim: plussim$1,\n\tplustwo: plustwo$1,\n\tpm: pm$1,\n\tPoincareplane: Poincareplane$1,\n\tpointint: pointint$1,\n\tpopf: popf$1,\n\tPopf: Popf$1,\n\tpound: pound$3,\n\tprap: prap$1,\n\tPr: Pr$1,\n\tpr: pr$1,\n\tprcue: prcue$1,\n\tprecapprox: precapprox$1,\n\tprec: prec$1,\n\tpreccurlyeq: preccurlyeq$1,\n\tPrecedes: Precedes$1,\n\tPrecedesEqual: PrecedesEqual$1,\n\tPrecedesSlantEqual: PrecedesSlantEqual$1,\n\tPrecedesTilde: PrecedesTilde$1,\n\tpreceq: preceq$1,\n\tprecnapprox: precnapprox$1,\n\tprecneqq: precneqq$1,\n\tprecnsim: precnsim$1,\n\tpre: pre$1,\n\tprE: prE$1,\n\tprecsim: precsim$1,\n\tprime: prime$1,\n\tPrime: Prime$1,\n\tprimes: primes$1,\n\tprnap: prnap$1,\n\tprnE: prnE$1,\n\tprnsim: prnsim$1,\n\tprod: prod$1,\n\tProduct: Product$1,\n\tprofalar: profalar$1,\n\tprofline: profline$1,\n\tprofsurf: profsurf$1,\n\tprop: prop$1,\n\tProportional: Proportional$1,\n\tProportion: Proportion$1,\n\tpropto: propto$1,\n\tprsim: prsim$1,\n\tprurel: prurel$1,\n\tPscr: Pscr$1,\n\tpscr: pscr$1,\n\tPsi: Psi$1,\n\tpsi: psi$1,\n\tpuncsp: puncsp$1,\n\tQfr: Qfr$1,\n\tqfr: qfr$1,\n\tqint: qint$1,\n\tqopf: qopf$1,\n\tQopf: Qopf$1,\n\tqprime: qprime$1,\n\tQscr: Qscr$1,\n\tqscr: qscr$1,\n\tquaternions: quaternions$1,\n\tquatint: quatint$1,\n\tquest: quest$1,\n\tquesteq: questeq$1,\n\tquot: quot$5,\n\tQUOT: QUOT$3,\n\trAarr: rAarr$1,\n\trace: race$1,\n\tRacute: Racute$1,\n\tracute: racute$1,\n\tradic: radic$1,\n\traemptyv: raemptyv$1,\n\trang: rang$1,\n\tRang: Rang$1,\n\trangd: rangd$1,\n\trange: range$1,\n\trangle: rangle$1,\n\traquo: raquo$3,\n\trarrap: rarrap$1,\n\trarrb: rarrb$1,\n\trarrbfs: rarrbfs$1,\n\trarrc: rarrc$1,\n\trarr: rarr$1,\n\tRarr: Rarr$1,\n\trArr: rArr$1,\n\trarrfs: rarrfs$1,\n\trarrhk: rarrhk$1,\n\trarrlp: rarrlp$1,\n\trarrpl: rarrpl$1,\n\trarrsim: rarrsim$1,\n\tRarrtl: Rarrtl$1,\n\trarrtl: rarrtl$1,\n\trarrw: rarrw$1,\n\tratail: ratail$1,\n\trAtail: rAtail$1,\n\tratio: ratio$1,\n\trationals: rationals$1,\n\trbarr: rbarr$1,\n\trBarr: rBarr$1,\n\tRBarr: RBarr$1,\n\trbbrk: rbbrk$1,\n\trbrace: rbrace$1,\n\trbrack: rbrack$1,\n\trbrke: rbrke$1,\n\trbrksld: rbrksld$1,\n\trbrkslu: rbrkslu$1,\n\tRcaron: Rcaron$1,\n\trcaron: rcaron$1,\n\tRcedil: Rcedil$1,\n\trcedil: rcedil$1,\n\trceil: rceil$1,\n\trcub: rcub$1,\n\tRcy: Rcy$1,\n\trcy: rcy$1,\n\trdca: rdca$1,\n\trdldhar: rdldhar$1,\n\trdquo: rdquo$1,\n\trdquor: rdquor$1,\n\trdsh: rdsh$1,\n\treal: real$1,\n\trealine: realine$1,\n\trealpart: realpart$1,\n\treals: reals$1,\n\tRe: Re$1,\n\trect: rect$1,\n\treg: reg$3,\n\tREG: REG$3,\n\tReverseElement: ReverseElement$1,\n\tReverseEquilibrium: ReverseEquilibrium$1,\n\tReverseUpEquilibrium: ReverseUpEquilibrium$1,\n\trfisht: rfisht$1,\n\trfloor: rfloor$1,\n\trfr: rfr$1,\n\tRfr: Rfr$1,\n\trHar: rHar$1,\n\trhard: rhard$1,\n\trharu: rharu$1,\n\trharul: rharul$1,\n\tRho: Rho$1,\n\trho: rho$1,\n\trhov: rhov$1,\n\tRightAngleBracket: RightAngleBracket$1,\n\tRightArrowBar: RightArrowBar$1,\n\trightarrow: rightarrow$1,\n\tRightArrow: RightArrow$1,\n\tRightarrow: Rightarrow$1,\n\tRightArrowLeftArrow: RightArrowLeftArrow$1,\n\trightarrowtail: rightarrowtail$1,\n\tRightCeiling: RightCeiling$1,\n\tRightDoubleBracket: RightDoubleBracket$1,\n\tRightDownTeeVector: RightDownTeeVector$1,\n\tRightDownVectorBar: RightDownVectorBar$1,\n\tRightDownVector: RightDownVector$1,\n\tRightFloor: RightFloor$1,\n\trightharpoondown: rightharpoondown$1,\n\trightharpoonup: rightharpoonup$1,\n\trightleftarrows: rightleftarrows$1,\n\trightleftharpoons: rightleftharpoons$1,\n\trightrightarrows: rightrightarrows$1,\n\trightsquigarrow: rightsquigarrow$1,\n\tRightTeeArrow: RightTeeArrow$1,\n\tRightTee: RightTee$1,\n\tRightTeeVector: RightTeeVector$1,\n\trightthreetimes: rightthreetimes$1,\n\tRightTriangleBar: RightTriangleBar$1,\n\tRightTriangle: RightTriangle$1,\n\tRightTriangleEqual: RightTriangleEqual$1,\n\tRightUpDownVector: RightUpDownVector$1,\n\tRightUpTeeVector: RightUpTeeVector$1,\n\tRightUpVectorBar: RightUpVectorBar$1,\n\tRightUpVector: RightUpVector$1,\n\tRightVectorBar: RightVectorBar$1,\n\tRightVector: RightVector$1,\n\tring: ring$1,\n\trisingdotseq: risingdotseq$1,\n\trlarr: rlarr$1,\n\trlhar: rlhar$1,\n\trlm: rlm$1,\n\trmoustache: rmoustache$1,\n\trmoust: rmoust$1,\n\trnmid: rnmid$1,\n\troang: roang$1,\n\troarr: roarr$1,\n\trobrk: robrk$1,\n\tropar: ropar$1,\n\tropf: ropf$1,\n\tRopf: Ropf$1,\n\troplus: roplus$1,\n\trotimes: rotimes$1,\n\tRoundImplies: RoundImplies$1,\n\trpar: rpar$1,\n\trpargt: rpargt$1,\n\trppolint: rppolint$1,\n\trrarr: rrarr$1,\n\tRrightarrow: Rrightarrow$1,\n\trsaquo: rsaquo$1,\n\trscr: rscr$1,\n\tRscr: Rscr$1,\n\trsh: rsh$1,\n\tRsh: Rsh$1,\n\trsqb: rsqb$1,\n\trsquo: rsquo$1,\n\trsquor: rsquor$1,\n\trthree: rthree$1,\n\trtimes: rtimes$1,\n\trtri: rtri$1,\n\trtrie: rtrie$1,\n\trtrif: rtrif$1,\n\trtriltri: rtriltri$1,\n\tRuleDelayed: RuleDelayed$1,\n\truluhar: ruluhar$1,\n\trx: rx$2,\n\tSacute: Sacute$1,\n\tsacute: sacute$1,\n\tsbquo: sbquo$1,\n\tscap: scap$1,\n\tScaron: Scaron$1,\n\tscaron: scaron$1,\n\tSc: Sc$1,\n\tsc: sc$1,\n\tsccue: sccue$1,\n\tsce: sce$1,\n\tscE: scE$1,\n\tScedil: Scedil$1,\n\tscedil: scedil$1,\n\tScirc: Scirc$1,\n\tscirc: scirc$1,\n\tscnap: scnap$1,\n\tscnE: scnE$1,\n\tscnsim: scnsim$1,\n\tscpolint: scpolint$1,\n\tscsim: scsim$1,\n\tScy: Scy$1,\n\tscy: scy$1,\n\tsdotb: sdotb$1,\n\tsdot: sdot$1,\n\tsdote: sdote$1,\n\tsearhk: searhk$1,\n\tsearr: searr$1,\n\tseArr: seArr$1,\n\tsearrow: searrow$1,\n\tsect: sect$3,\n\tsemi: semi$1,\n\tseswar: seswar$1,\n\tsetminus: setminus$1,\n\tsetmn: setmn$1,\n\tsext: sext$1,\n\tSfr: Sfr$1,\n\tsfr: sfr$1,\n\tsfrown: sfrown$1,\n\tsharp: sharp$1,\n\tSHCHcy: SHCHcy$1,\n\tshchcy: shchcy$1,\n\tSHcy: SHcy$1,\n\tshcy: shcy$1,\n\tShortDownArrow: ShortDownArrow$1,\n\tShortLeftArrow: ShortLeftArrow$1,\n\tshortmid: shortmid$1,\n\tshortparallel: shortparallel$1,\n\tShortRightArrow: ShortRightArrow$1,\n\tShortUpArrow: ShortUpArrow$1,\n\tshy: shy$3,\n\tSigma: Sigma$1,\n\tsigma: sigma$1,\n\tsigmaf: sigmaf$1,\n\tsigmav: sigmav$1,\n\tsim: sim$1,\n\tsimdot: simdot$1,\n\tsime: sime$1,\n\tsimeq: simeq$1,\n\tsimg: simg$1,\n\tsimgE: simgE$1,\n\tsiml: siml$1,\n\tsimlE: simlE$1,\n\tsimne: simne$1,\n\tsimplus: simplus$1,\n\tsimrarr: simrarr$1,\n\tslarr: slarr$1,\n\tSmallCircle: SmallCircle$1,\n\tsmallsetminus: smallsetminus$1,\n\tsmashp: smashp$1,\n\tsmeparsl: smeparsl$1,\n\tsmid: smid$1,\n\tsmile: smile$1,\n\tsmt: smt$1,\n\tsmte: smte$1,\n\tsmtes: smtes$1,\n\tSOFTcy: SOFTcy$1,\n\tsoftcy: softcy$1,\n\tsolbar: solbar$1,\n\tsolb: solb$1,\n\tsol: sol$1,\n\tSopf: Sopf$1,\n\tsopf: sopf$1,\n\tspades: spades$1,\n\tspadesuit: spadesuit$1,\n\tspar: spar$1,\n\tsqcap: sqcap$1,\n\tsqcaps: sqcaps$1,\n\tsqcup: sqcup$1,\n\tsqcups: sqcups$1,\n\tSqrt: Sqrt$1,\n\tsqsub: sqsub$1,\n\tsqsube: sqsube$1,\n\tsqsubset: sqsubset$1,\n\tsqsubseteq: sqsubseteq$1,\n\tsqsup: sqsup$1,\n\tsqsupe: sqsupe$1,\n\tsqsupset: sqsupset$1,\n\tsqsupseteq: sqsupseteq$1,\n\tsquare: square$1,\n\tSquare: Square$1,\n\tSquareIntersection: SquareIntersection$1,\n\tSquareSubset: SquareSubset$1,\n\tSquareSubsetEqual: SquareSubsetEqual$1,\n\tSquareSuperset: SquareSuperset$1,\n\tSquareSupersetEqual: SquareSupersetEqual$1,\n\tSquareUnion: SquareUnion$1,\n\tsquarf: squarf$1,\n\tsqu: squ$1,\n\tsquf: squf$1,\n\tsrarr: srarr$1,\n\tSscr: Sscr$1,\n\tsscr: sscr$1,\n\tssetmn: ssetmn$1,\n\tssmile: ssmile$1,\n\tsstarf: sstarf$1,\n\tStar: Star$1,\n\tstar: star$1,\n\tstarf: starf$1,\n\tstraightepsilon: straightepsilon$1,\n\tstraightphi: straightphi$1,\n\tstrns: strns$1,\n\tsub: sub$1,\n\tSub: Sub$1,\n\tsubdot: subdot$1,\n\tsubE: subE$1,\n\tsube: sube$1,\n\tsubedot: subedot$1,\n\tsubmult: submult$1,\n\tsubnE: subnE$1,\n\tsubne: subne$1,\n\tsubplus: subplus$1,\n\tsubrarr: subrarr$1,\n\tsubset: subset$1,\n\tSubset: Subset$1,\n\tsubseteq: subseteq$1,\n\tsubseteqq: subseteqq$1,\n\tSubsetEqual: SubsetEqual$1,\n\tsubsetneq: subsetneq$1,\n\tsubsetneqq: subsetneqq$1,\n\tsubsim: subsim$1,\n\tsubsub: subsub$1,\n\tsubsup: subsup$1,\n\tsuccapprox: succapprox$1,\n\tsucc: succ$1,\n\tsucccurlyeq: succcurlyeq$1,\n\tSucceeds: Succeeds$1,\n\tSucceedsEqual: SucceedsEqual$1,\n\tSucceedsSlantEqual: SucceedsSlantEqual$1,\n\tSucceedsTilde: SucceedsTilde$1,\n\tsucceq: succeq$1,\n\tsuccnapprox: succnapprox$1,\n\tsuccneqq: succneqq$1,\n\tsuccnsim: succnsim$1,\n\tsuccsim: succsim$1,\n\tSuchThat: SuchThat$1,\n\tsum: sum$1,\n\tSum: Sum$1,\n\tsung: sung$1,\n\tsup1: sup1$3,\n\tsup2: sup2$3,\n\tsup3: sup3$3,\n\tsup: sup$1,\n\tSup: Sup$1,\n\tsupdot: supdot$1,\n\tsupdsub: supdsub$1,\n\tsupE: supE$1,\n\tsupe: supe$1,\n\tsupedot: supedot$1,\n\tSuperset: Superset$1,\n\tSupersetEqual: SupersetEqual$1,\n\tsuphsol: suphsol$1,\n\tsuphsub: suphsub$1,\n\tsuplarr: suplarr$1,\n\tsupmult: supmult$1,\n\tsupnE: supnE$1,\n\tsupne: supne$1,\n\tsupplus: supplus$1,\n\tsupset: supset$1,\n\tSupset: Supset$1,\n\tsupseteq: supseteq$1,\n\tsupseteqq: supseteqq$1,\n\tsupsetneq: supsetneq$1,\n\tsupsetneqq: supsetneqq$1,\n\tsupsim: supsim$1,\n\tsupsub: supsub$1,\n\tsupsup: supsup$1,\n\tswarhk: swarhk$1,\n\tswarr: swarr$1,\n\tswArr: swArr$1,\n\tswarrow: swarrow$1,\n\tswnwar: swnwar$1,\n\tszlig: szlig$3,\n\tTab: Tab$1,\n\ttarget: target$2,\n\tTau: Tau$1,\n\ttau: tau$1,\n\ttbrk: tbrk$1,\n\tTcaron: Tcaron$1,\n\ttcaron: tcaron$1,\n\tTcedil: Tcedil$1,\n\ttcedil: tcedil$1,\n\tTcy: Tcy$1,\n\ttcy: tcy$1,\n\ttdot: tdot$1,\n\ttelrec: telrec$1,\n\tTfr: Tfr$1,\n\ttfr: tfr$1,\n\tthere4: there4$1,\n\ttherefore: therefore$1,\n\tTherefore: Therefore$1,\n\tTheta: Theta$1,\n\ttheta: theta$1,\n\tthetasym: thetasym$1,\n\tthetav: thetav$1,\n\tthickapprox: thickapprox$1,\n\tthicksim: thicksim$1,\n\tThickSpace: ThickSpace$1,\n\tThinSpace: ThinSpace$1,\n\tthinsp: thinsp$1,\n\tthkap: thkap$1,\n\tthksim: thksim$1,\n\tTHORN: THORN$3,\n\tthorn: thorn$3,\n\ttilde: tilde$1,\n\tTilde: Tilde$1,\n\tTildeEqual: TildeEqual$1,\n\tTildeFullEqual: TildeFullEqual$1,\n\tTildeTilde: TildeTilde$1,\n\ttimesbar: timesbar$1,\n\ttimesb: timesb$1,\n\ttimes: times$3,\n\ttimesd: timesd$1,\n\ttint: tint$1,\n\ttoea: toea$1,\n\ttopbot: topbot$1,\n\ttopcir: topcir$1,\n\ttop: top$1,\n\tTopf: Topf$1,\n\ttopf: topf$1,\n\ttopfork: topfork$1,\n\ttosa: tosa$1,\n\ttprime: tprime$1,\n\ttrade: trade$1,\n\tTRADE: TRADE$1,\n\ttriangle: triangle$1,\n\ttriangledown: triangledown$1,\n\ttriangleleft: triangleleft$1,\n\ttrianglelefteq: trianglelefteq$1,\n\ttriangleq: triangleq$1,\n\ttriangleright: triangleright$1,\n\ttrianglerighteq: trianglerighteq$1,\n\ttridot: tridot$1,\n\ttrie: trie$1,\n\ttriminus: triminus$1,\n\tTripleDot: TripleDot$1,\n\ttriplus: triplus$1,\n\ttrisb: trisb$1,\n\ttritime: tritime$1,\n\ttrpezium: trpezium$1,\n\tTscr: Tscr$1,\n\ttscr: tscr$1,\n\tTScy: TScy$1,\n\ttscy: tscy$1,\n\tTSHcy: TSHcy$1,\n\ttshcy: tshcy$1,\n\tTstrok: Tstrok$1,\n\ttstrok: tstrok$1,\n\ttwixt: twixt$1,\n\ttwoheadleftarrow: twoheadleftarrow$1,\n\ttwoheadrightarrow: twoheadrightarrow$1,\n\tUacute: Uacute$3,\n\tuacute: uacute$3,\n\tuarr: uarr$1,\n\tUarr: Uarr$1,\n\tuArr: uArr$1,\n\tUarrocir: Uarrocir$1,\n\tUbrcy: Ubrcy$1,\n\tubrcy: ubrcy$1,\n\tUbreve: Ubreve$1,\n\tubreve: ubreve$1,\n\tUcirc: Ucirc$3,\n\tucirc: ucirc$3,\n\tUcy: Ucy$1,\n\tucy: ucy$1,\n\tudarr: udarr$1,\n\tUdblac: Udblac$1,\n\tudblac: udblac$1,\n\tudhar: udhar$1,\n\tufisht: ufisht$1,\n\tUfr: Ufr$1,\n\tufr: ufr$1,\n\tUgrave: Ugrave$3,\n\tugrave: ugrave$3,\n\tuHar: uHar$1,\n\tuharl: uharl$1,\n\tuharr: uharr$1,\n\tuhblk: uhblk$1,\n\tulcorn: ulcorn$1,\n\tulcorner: ulcorner$1,\n\tulcrop: ulcrop$1,\n\tultri: ultri$1,\n\tUmacr: Umacr$1,\n\tumacr: umacr$1,\n\tuml: uml$3,\n\tUnderBar: UnderBar$1,\n\tUnderBrace: UnderBrace$1,\n\tUnderBracket: UnderBracket$1,\n\tUnderParenthesis: UnderParenthesis$1,\n\tUnion: Union$1,\n\tUnionPlus: UnionPlus$1,\n\tUogon: Uogon$1,\n\tuogon: uogon$1,\n\tUopf: Uopf$1,\n\tuopf: uopf$1,\n\tUpArrowBar: UpArrowBar$1,\n\tuparrow: uparrow$1,\n\tUpArrow: UpArrow$1,\n\tUparrow: Uparrow$1,\n\tUpArrowDownArrow: UpArrowDownArrow$1,\n\tupdownarrow: updownarrow$1,\n\tUpDownArrow: UpDownArrow$1,\n\tUpdownarrow: Updownarrow$1,\n\tUpEquilibrium: UpEquilibrium$1,\n\tupharpoonleft: upharpoonleft$1,\n\tupharpoonright: upharpoonright$1,\n\tuplus: uplus$1,\n\tUpperLeftArrow: UpperLeftArrow$1,\n\tUpperRightArrow: UpperRightArrow$1,\n\tupsi: upsi$1,\n\tUpsi: Upsi$1,\n\tupsih: upsih$1,\n\tUpsilon: Upsilon$1,\n\tupsilon: upsilon$1,\n\tUpTeeArrow: UpTeeArrow$1,\n\tUpTee: UpTee$1,\n\tupuparrows: upuparrows$1,\n\turcorn: urcorn$1,\n\turcorner: urcorner$1,\n\turcrop: urcrop$1,\n\tUring: Uring$1,\n\turing: uring$1,\n\turtri: urtri$1,\n\tUscr: Uscr$1,\n\tuscr: uscr$1,\n\tutdot: utdot$1,\n\tUtilde: Utilde$1,\n\tutilde: utilde$1,\n\tutri: utri$1,\n\tutrif: utrif$1,\n\tuuarr: uuarr$1,\n\tUuml: Uuml$3,\n\tuuml: uuml$3,\n\tuwangle: uwangle$1,\n\tvangrt: vangrt$1,\n\tvarepsilon: varepsilon$1,\n\tvarkappa: varkappa$1,\n\tvarnothing: varnothing$1,\n\tvarphi: varphi$1,\n\tvarpi: varpi$1,\n\tvarpropto: varpropto$1,\n\tvarr: varr$1,\n\tvArr: vArr$1,\n\tvarrho: varrho$1,\n\tvarsigma: varsigma$1,\n\tvarsubsetneq: varsubsetneq$1,\n\tvarsubsetneqq: varsubsetneqq$1,\n\tvarsupsetneq: varsupsetneq$1,\n\tvarsupsetneqq: varsupsetneqq$1,\n\tvartheta: vartheta$1,\n\tvartriangleleft: vartriangleleft$1,\n\tvartriangleright: vartriangleright$1,\n\tvBar: vBar$1,\n\tVbar: Vbar$1,\n\tvBarv: vBarv$1,\n\tVcy: Vcy$1,\n\tvcy: vcy$1,\n\tvdash: vdash$1,\n\tvDash: vDash$1,\n\tVdash: Vdash$1,\n\tVDash: VDash$1,\n\tVdashl: Vdashl$1,\n\tveebar: veebar$1,\n\tvee: vee$1,\n\tVee: Vee$1,\n\tveeeq: veeeq$1,\n\tvellip: vellip$1,\n\tverbar: verbar$1,\n\tVerbar: Verbar$1,\n\tvert: vert$1,\n\tVert: Vert$1,\n\tVerticalBar: VerticalBar$1,\n\tVerticalLine: VerticalLine$1,\n\tVerticalSeparator: VerticalSeparator$1,\n\tVerticalTilde: VerticalTilde$1,\n\tVeryThinSpace: VeryThinSpace$1,\n\tVfr: Vfr$1,\n\tvfr: vfr$1,\n\tvltri: vltri$1,\n\tvnsub: vnsub$1,\n\tvnsup: vnsup$1,\n\tVopf: Vopf$1,\n\tvopf: vopf$1,\n\tvprop: vprop$1,\n\tvrtri: vrtri$1,\n\tVscr: Vscr$1,\n\tvscr: vscr$1,\n\tvsubnE: vsubnE$1,\n\tvsubne: vsubne$1,\n\tvsupnE: vsupnE$1,\n\tvsupne: vsupne$1,\n\tVvdash: Vvdash$1,\n\tvzigzag: vzigzag$1,\n\tWcirc: Wcirc$1,\n\twcirc: wcirc$1,\n\twedbar: wedbar$1,\n\twedge: wedge$1,\n\tWedge: Wedge$1,\n\twedgeq: wedgeq$1,\n\tweierp: weierp$1,\n\tWfr: Wfr$1,\n\twfr: wfr$1,\n\tWopf: Wopf$1,\n\twopf: wopf$1,\n\twp: wp$1,\n\twr: wr$1,\n\twreath: wreath$1,\n\tWscr: Wscr$1,\n\twscr: wscr$1,\n\txcap: xcap$1,\n\txcirc: xcirc$1,\n\txcup: xcup$1,\n\txdtri: xdtri$1,\n\tXfr: Xfr$1,\n\txfr: xfr$1,\n\txharr: xharr$1,\n\txhArr: xhArr$1,\n\tXi: Xi$1,\n\txi: xi$1,\n\txlarr: xlarr$1,\n\txlArr: xlArr$1,\n\txmap: xmap$1,\n\txnis: xnis$1,\n\txodot: xodot$1,\n\tXopf: Xopf$1,\n\txopf: xopf$1,\n\txoplus: xoplus$1,\n\txotime: xotime$1,\n\txrarr: xrarr$1,\n\txrArr: xrArr$1,\n\tXscr: Xscr$1,\n\txscr: xscr$1,\n\txsqcup: xsqcup$1,\n\txuplus: xuplus$1,\n\txutri: xutri$1,\n\txvee: xvee$1,\n\txwedge: xwedge$1,\n\tYacute: Yacute$3,\n\tyacute: yacute$3,\n\tYAcy: YAcy$1,\n\tyacy: yacy$1,\n\tYcirc: Ycirc$1,\n\tycirc: ycirc$1,\n\tYcy: Ycy$1,\n\tycy: ycy$1,\n\tyen: yen$3,\n\tYfr: Yfr$1,\n\tyfr: yfr$1,\n\tYIcy: YIcy$1,\n\tyicy: yicy$1,\n\tYopf: Yopf$1,\n\tyopf: yopf$1,\n\tYscr: Yscr$1,\n\tyscr: yscr$1,\n\tYUcy: YUcy$1,\n\tyucy: yucy$1,\n\tyuml: yuml$3,\n\tYuml: Yuml$1,\n\tZacute: Zacute$1,\n\tzacute: zacute$1,\n\tZcaron: Zcaron$1,\n\tzcaron: zcaron$1,\n\tZcy: Zcy$1,\n\tzcy: zcy$1,\n\tZdot: Zdot$1,\n\tzdot: zdot$1,\n\tzeetrf: zeetrf$1,\n\tZeroWidthSpace: ZeroWidthSpace$1,\n\tZeta: Zeta$1,\n\tzeta: zeta$1,\n\tzfr: zfr$1,\n\tZfr: Zfr$1,\n\tZHcy: ZHcy$1,\n\tzhcy: zhcy$1,\n\tzigrarr: zigrarr$1,\n\tzopf: zopf$1,\n\tZopf: Zopf$1,\n\tZscr: Zscr$1,\n\tzscr: zscr$1,\n\tzwj: zwj$1,\n\tzwnj: zwnj$1\n};\n\nvar Aacute$2 = \"Á\";\nvar aacute$2 = \"á\";\nvar Acirc$2 = \"Â\";\nvar acirc$2 = \"â\";\nvar acute$2 = \"´\";\nvar AElig$2 = \"Æ\";\nvar aelig$2 = \"æ\";\nvar Agrave$2 = \"À\";\nvar agrave$2 = \"à\";\nvar amp$4 = \"&\";\nvar AMP$2 = \"&\";\nvar Aring$2 = \"Å\";\nvar aring$2 = \"å\";\nvar Atilde$2 = \"Ã\";\nvar atilde$2 = \"ã\";\nvar Auml$2 = \"Ä\";\nvar auml$2 = \"ä\";\nvar brvbar$2 = \"¦\";\nvar Ccedil$2 = \"Ç\";\nvar ccedil$2 = \"ç\";\nvar cedil$2 = \"¸\";\nvar cent$2 = \"¢\";\nvar copy$2 = \"©\";\nvar COPY$2 = \"©\";\nvar curren$2 = \"¤\";\nvar deg$2 = \"°\";\nvar divide$2 = \"÷\";\nvar Eacute$2 = \"É\";\nvar eacute$2 = \"é\";\nvar Ecirc$2 = \"Ê\";\nvar ecirc$2 = \"ê\";\nvar Egrave$2 = \"È\";\nvar egrave$2 = \"è\";\nvar ETH$2 = \"Ð\";\nvar eth$2 = \"ð\";\nvar Euml$2 = \"Ë\";\nvar euml$2 = \"ë\";\nvar frac12$2 = \"½\";\nvar frac14$2 = \"¼\";\nvar frac34$2 = \"¾\";\nvar gt$4 = \">\";\nvar GT$2 = \">\";\nvar Iacute$2 = \"Í\";\nvar iacute$2 = \"í\";\nvar Icirc$2 = \"Î\";\nvar icirc$2 = \"î\";\nvar iexcl$2 = \"¡\";\nvar Igrave$2 = \"Ì\";\nvar igrave$2 = \"ì\";\nvar iquest$2 = \"¿\";\nvar Iuml$2 = \"Ï\";\nvar iuml$2 = \"ï\";\nvar laquo$2 = \"«\";\nvar lt$4 = \"<\";\nvar LT$2 = \"<\";\nvar macr$2 = \"¯\";\nvar micro$2 = \"µ\";\nvar middot$2 = \"·\";\nvar nbsp$2 = \" \";\nvar not$2 = \"¬\";\nvar Ntilde$2 = \"Ñ\";\nvar ntilde$2 = \"ñ\";\nvar Oacute$2 = \"Ó\";\nvar oacute$2 = \"ó\";\nvar Ocirc$2 = \"Ô\";\nvar ocirc$2 = \"ô\";\nvar Ograve$2 = \"Ò\";\nvar ograve$2 = \"ò\";\nvar ordf$2 = \"ª\";\nvar ordm$2 = \"º\";\nvar Oslash$2 = \"Ø\";\nvar oslash$2 = \"ø\";\nvar Otilde$2 = \"Õ\";\nvar otilde$2 = \"õ\";\nvar Ouml$2 = \"Ö\";\nvar ouml$2 = \"ö\";\nvar para$2 = \"¶\";\nvar plusmn$2 = \"±\";\nvar pound$2 = \"£\";\nvar quot$4 = \"\\\"\";\nvar QUOT$2 = \"\\\"\";\nvar raquo$2 = \"»\";\nvar reg$2 = \"®\";\nvar REG$2 = \"®\";\nvar sect$2 = \"§\";\nvar shy$2 = \"­\";\nvar sup1$2 = \"¹\";\nvar sup2$2 = \"²\";\nvar sup3$2 = \"³\";\nvar szlig$2 = \"ß\";\nvar THORN$2 = \"Þ\";\nvar thorn$2 = \"þ\";\nvar times$2 = \"×\";\nvar Uacute$2 = \"Ú\";\nvar uacute$2 = \"ú\";\nvar Ucirc$2 = \"Û\";\nvar ucirc$2 = \"û\";\nvar Ugrave$2 = \"Ù\";\nvar ugrave$2 = \"ù\";\nvar uml$2 = \"¨\";\nvar Uuml$2 = \"Ü\";\nvar uuml$2 = \"ü\";\nvar Yacute$2 = \"Ý\";\nvar yacute$2 = \"ý\";\nvar yen$2 = \"¥\";\nvar yuml$2 = \"ÿ\";\nvar require$$2$2 = {\n\tAacute: Aacute$2,\n\taacute: aacute$2,\n\tAcirc: Acirc$2,\n\tacirc: acirc$2,\n\tacute: acute$2,\n\tAElig: AElig$2,\n\taelig: aelig$2,\n\tAgrave: Agrave$2,\n\tagrave: agrave$2,\n\tamp: amp$4,\n\tAMP: AMP$2,\n\tAring: Aring$2,\n\taring: aring$2,\n\tAtilde: Atilde$2,\n\tatilde: atilde$2,\n\tAuml: Auml$2,\n\tauml: auml$2,\n\tbrvbar: brvbar$2,\n\tCcedil: Ccedil$2,\n\tccedil: ccedil$2,\n\tcedil: cedil$2,\n\tcent: cent$2,\n\tcopy: copy$2,\n\tCOPY: COPY$2,\n\tcurren: curren$2,\n\tdeg: deg$2,\n\tdivide: divide$2,\n\tEacute: Eacute$2,\n\teacute: eacute$2,\n\tEcirc: Ecirc$2,\n\tecirc: ecirc$2,\n\tEgrave: Egrave$2,\n\tegrave: egrave$2,\n\tETH: ETH$2,\n\teth: eth$2,\n\tEuml: Euml$2,\n\teuml: euml$2,\n\tfrac12: frac12$2,\n\tfrac14: frac14$2,\n\tfrac34: frac34$2,\n\tgt: gt$4,\n\tGT: GT$2,\n\tIacute: Iacute$2,\n\tiacute: iacute$2,\n\tIcirc: Icirc$2,\n\ticirc: icirc$2,\n\tiexcl: iexcl$2,\n\tIgrave: Igrave$2,\n\tigrave: igrave$2,\n\tiquest: iquest$2,\n\tIuml: Iuml$2,\n\tiuml: iuml$2,\n\tlaquo: laquo$2,\n\tlt: lt$4,\n\tLT: LT$2,\n\tmacr: macr$2,\n\tmicro: micro$2,\n\tmiddot: middot$2,\n\tnbsp: nbsp$2,\n\tnot: not$2,\n\tNtilde: Ntilde$2,\n\tntilde: ntilde$2,\n\tOacute: Oacute$2,\n\toacute: oacute$2,\n\tOcirc: Ocirc$2,\n\tocirc: ocirc$2,\n\tOgrave: Ograve$2,\n\tograve: ograve$2,\n\tordf: ordf$2,\n\tordm: ordm$2,\n\tOslash: Oslash$2,\n\toslash: oslash$2,\n\tOtilde: Otilde$2,\n\totilde: otilde$2,\n\tOuml: Ouml$2,\n\touml: ouml$2,\n\tpara: para$2,\n\tplusmn: plusmn$2,\n\tpound: pound$2,\n\tquot: quot$4,\n\tQUOT: QUOT$2,\n\traquo: raquo$2,\n\treg: reg$2,\n\tREG: REG$2,\n\tsect: sect$2,\n\tshy: shy$2,\n\tsup1: sup1$2,\n\tsup2: sup2$2,\n\tsup3: sup3$2,\n\tszlig: szlig$2,\n\tTHORN: THORN$2,\n\tthorn: thorn$2,\n\ttimes: times$2,\n\tUacute: Uacute$2,\n\tuacute: uacute$2,\n\tUcirc: Ucirc$2,\n\tucirc: ucirc$2,\n\tUgrave: Ugrave$2,\n\tugrave: ugrave$2,\n\tuml: uml$2,\n\tUuml: Uuml$2,\n\tuuml: uuml$2,\n\tYacute: Yacute$2,\n\tyacute: yacute$2,\n\tyen: yen$2,\n\tyuml: yuml$2\n};\n\nvar amp$3 = \"&\";\nvar apos$2 = \"'\";\nvar gt$3 = \">\";\nvar lt$3 = \"<\";\nvar quot$3 = \"\\\"\";\nvar require$$3$1 = {\n\tamp: amp$3,\n\tapos: apos$2,\n\tgt: gt$3,\n\tlt: lt$3,\n\tquot: quot$3\n};\n\nvar Tokenizer_1 = Tokenizer$1;\nvar decodeCodePoint = decode_codepoint$1;\nvar entityMap = require$$1$4;\nvar legacyMap = require$$2$2;\nvar xmlMap = require$$3$1;\nvar i$1 = 0;\nvar TEXT = i$1++;\nvar BEFORE_TAG_NAME = i$1++; //after <\nvar IN_TAG_NAME = i$1++;\nvar IN_SELF_CLOSING_TAG = i$1++;\nvar BEFORE_CLOSING_TAG_NAME = i$1++;\nvar IN_CLOSING_TAG_NAME = i$1++;\nvar AFTER_CLOSING_TAG_NAME = i$1++;\n\n//attributes\nvar BEFORE_ATTRIBUTE_NAME = i$1++;\nvar IN_ATTRIBUTE_NAME = i$1++;\nvar AFTER_ATTRIBUTE_NAME = i$1++;\nvar BEFORE_ATTRIBUTE_VALUE = i$1++;\nvar IN_ATTRIBUTE_VALUE_DQ = i$1++; // \"\nvar IN_ATTRIBUTE_VALUE_SQ = i$1++; // '\nvar IN_ATTRIBUTE_VALUE_NQ = i$1++;\n\n//declarations\nvar BEFORE_DECLARATION = i$1++; // !\nvar IN_DECLARATION = i$1++;\n\n//processing instructions\nvar IN_PROCESSING_INSTRUCTION = i$1++; // ?\n\n//comments\nvar BEFORE_COMMENT = i$1++;\nvar IN_COMMENT = i$1++;\nvar AFTER_COMMENT_1 = i$1++;\nvar AFTER_COMMENT_2 = i$1++;\n\n//cdata\nvar BEFORE_CDATA_1 = i$1++; // [\nvar BEFORE_CDATA_2 = i$1++; // C\nvar BEFORE_CDATA_3 = i$1++; // D\nvar BEFORE_CDATA_4 = i$1++; // A\nvar BEFORE_CDATA_5 = i$1++; // T\nvar BEFORE_CDATA_6 = i$1++; // A\nvar IN_CDATA = i$1++; // [\nvar AFTER_CDATA_1 = i$1++; // ]\nvar AFTER_CDATA_2 = i$1++; // ]\n\n//special tags\nvar BEFORE_SPECIAL = i$1++; //S\nvar BEFORE_SPECIAL_END = i$1++; //S\n\nvar BEFORE_SCRIPT_1 = i$1++; //C\nvar BEFORE_SCRIPT_2 = i$1++; //R\nvar BEFORE_SCRIPT_3 = i$1++; //I\nvar BEFORE_SCRIPT_4 = i$1++; //P\nvar BEFORE_SCRIPT_5 = i$1++; //T\nvar AFTER_SCRIPT_1 = i$1++; //C\nvar AFTER_SCRIPT_2 = i$1++; //R\nvar AFTER_SCRIPT_3 = i$1++; //I\nvar AFTER_SCRIPT_4 = i$1++; //P\nvar AFTER_SCRIPT_5 = i$1++; //T\n\nvar BEFORE_STYLE_1 = i$1++; //T\nvar BEFORE_STYLE_2 = i$1++; //Y\nvar BEFORE_STYLE_3 = i$1++; //L\nvar BEFORE_STYLE_4 = i$1++; //E\nvar AFTER_STYLE_1 = i$1++; //T\nvar AFTER_STYLE_2 = i$1++; //Y\nvar AFTER_STYLE_3 = i$1++; //L\nvar AFTER_STYLE_4 = i$1++; //E\n\nvar BEFORE_ENTITY = i$1++; //&\nvar BEFORE_NUMERIC_ENTITY = i$1++; //#\nvar IN_NAMED_ENTITY = i$1++;\nvar IN_NUMERIC_ENTITY = i$1++;\nvar IN_HEX_ENTITY = i$1++; //X\n\nvar j = 0;\nvar SPECIAL_NONE = j++;\nvar SPECIAL_SCRIPT = j++;\nvar SPECIAL_STYLE = j++;\nfunction whitespace$1(c) {\n  return c === \" \" || c === \"\\n\" || c === \"\\t\" || c === \"\\f\" || c === \"\\r\";\n}\nfunction ifElseState(upper, SUCCESS, FAILURE) {\n  var lower = upper.toLowerCase();\n  if (upper === lower) {\n    return function (c) {\n      if (c === lower) {\n        this._state = SUCCESS;\n      } else {\n        this._state = FAILURE;\n        this._index--;\n      }\n    };\n  } else {\n    return function (c) {\n      if (c === lower || c === upper) {\n        this._state = SUCCESS;\n      } else {\n        this._state = FAILURE;\n        this._index--;\n      }\n    };\n  }\n}\nfunction consumeSpecialNameChar(upper, NEXT_STATE) {\n  var lower = upper.toLowerCase();\n  return function (c) {\n    if (c === lower || c === upper) {\n      this._state = NEXT_STATE;\n    } else {\n      this._state = IN_TAG_NAME;\n      this._index--; //consume the token again\n    }\n  };\n}\nfunction Tokenizer$1(options, cbs) {\n  this._state = TEXT;\n  this._buffer = \"\";\n  this._sectionStart = 0;\n  this._index = 0;\n  this._bufferOffset = 0; //chars removed from _buffer\n  this._baseState = TEXT;\n  this._special = SPECIAL_NONE;\n  this._cbs = cbs;\n  this._running = true;\n  this._ended = false;\n  this._xmlMode = !!(options && options.xmlMode);\n  this._decodeEntities = !!(options && options.decodeEntities);\n}\nTokenizer$1.prototype._stateText = function (c) {\n  if (c === \"<\") {\n    if (this._index > this._sectionStart) {\n      this._cbs.ontext(this._getSection());\n    }\n    this._state = BEFORE_TAG_NAME;\n    this._sectionStart = this._index;\n  } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === \"&\") {\n    if (this._index > this._sectionStart) {\n      this._cbs.ontext(this._getSection());\n    }\n    this._baseState = TEXT;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateBeforeTagName = function (c) {\n  if (c === \"/\") {\n    this._state = BEFORE_CLOSING_TAG_NAME;\n  } else if (c === \"<\") {\n    this._cbs.ontext(this._getSection());\n    this._sectionStart = this._index;\n  } else if (c === \">\" || this._special !== SPECIAL_NONE || whitespace$1(c)) {\n    this._state = TEXT;\n  } else if (c === \"!\") {\n    this._state = BEFORE_DECLARATION;\n    this._sectionStart = this._index + 1;\n  } else if (c === \"?\") {\n    this._state = IN_PROCESSING_INSTRUCTION;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = !this._xmlMode && (c === \"s\" || c === \"S\") ? BEFORE_SPECIAL : IN_TAG_NAME;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateInTagName = function (c) {\n  if (c === \"/\" || c === \">\" || whitespace$1(c)) {\n    this._emitToken(\"onopentagname\");\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateBeforeCloseingTagName = function (c) {\n  if (whitespace$1(c)) ;else if (c === \">\") {\n    this._state = TEXT;\n  } else if (this._special !== SPECIAL_NONE) {\n    if (c === \"s\" || c === \"S\") {\n      this._state = BEFORE_SPECIAL_END;\n    } else {\n      this._state = TEXT;\n      this._index--;\n    }\n  } else {\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateInCloseingTagName = function (c) {\n  if (c === \">\" || whitespace$1(c)) {\n    this._emitToken(\"onclosetag\");\n    this._state = AFTER_CLOSING_TAG_NAME;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateAfterCloseingTagName = function (c) {\n  //skip everything until \">\"\n  if (c === \">\") {\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\nTokenizer$1.prototype._stateBeforeAttributeName = function (c) {\n  if (c === \">\") {\n    this._cbs.onopentagend();\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c === \"/\") {\n    this._state = IN_SELF_CLOSING_TAG;\n  } else if (!whitespace$1(c)) {\n    this._state = IN_ATTRIBUTE_NAME;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateInSelfClosingTag = function (c) {\n  if (c === \">\") {\n    this._cbs.onselfclosingtag();\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (!whitespace$1(c)) {\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateInAttributeName = function (c) {\n  if (c === \"=\" || c === \"/\" || c === \">\" || whitespace$1(c)) {\n    this._cbs.onattribname(this._getSection());\n    this._sectionStart = -1;\n    this._state = AFTER_ATTRIBUTE_NAME;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateAfterAttributeName = function (c) {\n  if (c === \"=\") {\n    this._state = BEFORE_ATTRIBUTE_VALUE;\n  } else if (c === \"/\" || c === \">\") {\n    this._cbs.onattribend();\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  } else if (!whitespace$1(c)) {\n    this._cbs.onattribend();\n    this._state = IN_ATTRIBUTE_NAME;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateBeforeAttributeValue = function (c) {\n  if (c === '\"') {\n    this._state = IN_ATTRIBUTE_VALUE_DQ;\n    this._sectionStart = this._index + 1;\n  } else if (c === \"'\") {\n    this._state = IN_ATTRIBUTE_VALUE_SQ;\n    this._sectionStart = this._index + 1;\n  } else if (!whitespace$1(c)) {\n    this._state = IN_ATTRIBUTE_VALUE_NQ;\n    this._sectionStart = this._index;\n    this._index--; //reconsume token\n  }\n};\nTokenizer$1.prototype._stateInAttributeValueDoubleQuotes = function (c) {\n  if (c === '\"') {\n    this._emitToken(\"onattribdata\");\n    this._cbs.onattribend();\n    this._state = BEFORE_ATTRIBUTE_NAME;\n  } else if (this._decodeEntities && c === \"&\") {\n    this._emitToken(\"onattribdata\");\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateInAttributeValueSingleQuotes = function (c) {\n  if (c === \"'\") {\n    this._emitToken(\"onattribdata\");\n    this._cbs.onattribend();\n    this._state = BEFORE_ATTRIBUTE_NAME;\n  } else if (this._decodeEntities && c === \"&\") {\n    this._emitToken(\"onattribdata\");\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateInAttributeValueNoQuotes = function (c) {\n  if (whitespace$1(c) || c === \">\") {\n    this._emitToken(\"onattribdata\");\n    this._cbs.onattribend();\n    this._state = BEFORE_ATTRIBUTE_NAME;\n    this._index--;\n  } else if (this._decodeEntities && c === \"&\") {\n    this._emitToken(\"onattribdata\");\n    this._baseState = this._state;\n    this._state = BEFORE_ENTITY;\n    this._sectionStart = this._index;\n  }\n};\nTokenizer$1.prototype._stateBeforeDeclaration = function (c) {\n  this._state = c === \"[\" ? BEFORE_CDATA_1 : c === \"-\" ? BEFORE_COMMENT : IN_DECLARATION;\n};\nTokenizer$1.prototype._stateInDeclaration = function (c) {\n  if (c === \">\") {\n    this._cbs.ondeclaration(this._getSection());\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\nTokenizer$1.prototype._stateInProcessingInstruction = function (c) {\n  if (c === \">\") {\n    this._cbs.onprocessinginstruction(this._getSection());\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  }\n};\nTokenizer$1.prototype._stateBeforeComment = function (c) {\n  if (c === \"-\") {\n    this._state = IN_COMMENT;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = IN_DECLARATION;\n  }\n};\nTokenizer$1.prototype._stateInComment = function (c) {\n  if (c === \"-\") this._state = AFTER_COMMENT_1;\n};\nTokenizer$1.prototype._stateAfterComment1 = function (c) {\n  if (c === \"-\") {\n    this._state = AFTER_COMMENT_2;\n  } else {\n    this._state = IN_COMMENT;\n  }\n};\nTokenizer$1.prototype._stateAfterComment2 = function (c) {\n  if (c === \">\") {\n    //remove 2 trailing chars\n    this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c !== \"-\") {\n    this._state = IN_COMMENT;\n  }\n  // else: stay in AFTER_COMMENT_2 (`--->`)\n};\nTokenizer$1.prototype._stateBeforeCdata1 = ifElseState(\"C\", BEFORE_CDATA_2, IN_DECLARATION);\nTokenizer$1.prototype._stateBeforeCdata2 = ifElseState(\"D\", BEFORE_CDATA_3, IN_DECLARATION);\nTokenizer$1.prototype._stateBeforeCdata3 = ifElseState(\"A\", BEFORE_CDATA_4, IN_DECLARATION);\nTokenizer$1.prototype._stateBeforeCdata4 = ifElseState(\"T\", BEFORE_CDATA_5, IN_DECLARATION);\nTokenizer$1.prototype._stateBeforeCdata5 = ifElseState(\"A\", BEFORE_CDATA_6, IN_DECLARATION);\nTokenizer$1.prototype._stateBeforeCdata6 = function (c) {\n  if (c === \"[\") {\n    this._state = IN_CDATA;\n    this._sectionStart = this._index + 1;\n  } else {\n    this._state = IN_DECLARATION;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateInCdata = function (c) {\n  if (c === \"]\") this._state = AFTER_CDATA_1;\n};\nTokenizer$1.prototype._stateAfterCdata1 = function (c) {\n  if (c === \"]\") this._state = AFTER_CDATA_2;else this._state = IN_CDATA;\n};\nTokenizer$1.prototype._stateAfterCdata2 = function (c) {\n  if (c === \">\") {\n    //remove 2 trailing chars\n    this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));\n    this._state = TEXT;\n    this._sectionStart = this._index + 1;\n  } else if (c !== \"]\") {\n    this._state = IN_CDATA;\n  }\n  //else: stay in AFTER_CDATA_2 (`]]]>`)\n};\nTokenizer$1.prototype._stateBeforeSpecial = function (c) {\n  if (c === \"c\" || c === \"C\") {\n    this._state = BEFORE_SCRIPT_1;\n  } else if (c === \"t\" || c === \"T\") {\n    this._state = BEFORE_STYLE_1;\n  } else {\n    this._state = IN_TAG_NAME;\n    this._index--; //consume the token again\n  }\n};\nTokenizer$1.prototype._stateBeforeSpecialEnd = function (c) {\n  if (this._special === SPECIAL_SCRIPT && (c === \"c\" || c === \"C\")) {\n    this._state = AFTER_SCRIPT_1;\n  } else if (this._special === SPECIAL_STYLE && (c === \"t\" || c === \"T\")) {\n    this._state = AFTER_STYLE_1;\n  } else this._state = TEXT;\n};\nTokenizer$1.prototype._stateBeforeScript1 = consumeSpecialNameChar(\"R\", BEFORE_SCRIPT_2);\nTokenizer$1.prototype._stateBeforeScript2 = consumeSpecialNameChar(\"I\", BEFORE_SCRIPT_3);\nTokenizer$1.prototype._stateBeforeScript3 = consumeSpecialNameChar(\"P\", BEFORE_SCRIPT_4);\nTokenizer$1.prototype._stateBeforeScript4 = consumeSpecialNameChar(\"T\", BEFORE_SCRIPT_5);\nTokenizer$1.prototype._stateBeforeScript5 = function (c) {\n  if (c === \"/\" || c === \">\" || whitespace$1(c)) {\n    this._special = SPECIAL_SCRIPT;\n  }\n  this._state = IN_TAG_NAME;\n  this._index--; //consume the token again\n};\nTokenizer$1.prototype._stateAfterScript1 = ifElseState(\"R\", AFTER_SCRIPT_2, TEXT);\nTokenizer$1.prototype._stateAfterScript2 = ifElseState(\"I\", AFTER_SCRIPT_3, TEXT);\nTokenizer$1.prototype._stateAfterScript3 = ifElseState(\"P\", AFTER_SCRIPT_4, TEXT);\nTokenizer$1.prototype._stateAfterScript4 = ifElseState(\"T\", AFTER_SCRIPT_5, TEXT);\nTokenizer$1.prototype._stateAfterScript5 = function (c) {\n  if (c === \">\" || whitespace$1(c)) {\n    this._special = SPECIAL_NONE;\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index - 6;\n    this._index--; //reconsume the token\n  } else this._state = TEXT;\n};\nTokenizer$1.prototype._stateBeforeStyle1 = consumeSpecialNameChar(\"Y\", BEFORE_STYLE_2);\nTokenizer$1.prototype._stateBeforeStyle2 = consumeSpecialNameChar(\"L\", BEFORE_STYLE_3);\nTokenizer$1.prototype._stateBeforeStyle3 = consumeSpecialNameChar(\"E\", BEFORE_STYLE_4);\nTokenizer$1.prototype._stateBeforeStyle4 = function (c) {\n  if (c === \"/\" || c === \">\" || whitespace$1(c)) {\n    this._special = SPECIAL_STYLE;\n  }\n  this._state = IN_TAG_NAME;\n  this._index--; //consume the token again\n};\nTokenizer$1.prototype._stateAfterStyle1 = ifElseState(\"Y\", AFTER_STYLE_2, TEXT);\nTokenizer$1.prototype._stateAfterStyle2 = ifElseState(\"L\", AFTER_STYLE_3, TEXT);\nTokenizer$1.prototype._stateAfterStyle3 = ifElseState(\"E\", AFTER_STYLE_4, TEXT);\nTokenizer$1.prototype._stateAfterStyle4 = function (c) {\n  if (c === \">\" || whitespace$1(c)) {\n    this._special = SPECIAL_NONE;\n    this._state = IN_CLOSING_TAG_NAME;\n    this._sectionStart = this._index - 5;\n    this._index--; //reconsume the token\n  } else this._state = TEXT;\n};\nTokenizer$1.prototype._stateBeforeEntity = ifElseState(\"#\", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);\nTokenizer$1.prototype._stateBeforeNumericEntity = ifElseState(\"X\", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);\n\n//for entities terminated with a semicolon\nTokenizer$1.prototype._parseNamedEntityStrict = function () {\n  //offset = 1\n  if (this._sectionStart + 1 < this._index) {\n    var entity = this._buffer.substring(this._sectionStart + 1, this._index),\n      map = this._xmlMode ? xmlMap : entityMap;\n    if (map.hasOwnProperty(entity)) {\n      this._emitPartial(map[entity]);\n      this._sectionStart = this._index + 1;\n    }\n  }\n};\n\n//parses legacy entities (without trailing semicolon)\nTokenizer$1.prototype._parseLegacyEntity = function () {\n  var start = this._sectionStart + 1,\n    limit = this._index - start;\n  if (limit > 6) limit = 6; //the max length of legacy entities is 6\n\n  while (limit >= 2) {\n    //the min length of legacy entities is 2\n    var entity = this._buffer.substr(start, limit);\n    if (legacyMap.hasOwnProperty(entity)) {\n      this._emitPartial(legacyMap[entity]);\n      this._sectionStart += limit + 1;\n      return;\n    } else {\n      limit--;\n    }\n  }\n};\nTokenizer$1.prototype._stateInNamedEntity = function (c) {\n  if (c === \";\") {\n    this._parseNamedEntityStrict();\n    if (this._sectionStart + 1 < this._index && !this._xmlMode) {\n      this._parseLegacyEntity();\n    }\n    this._state = this._baseState;\n  } else if ((c < \"a\" || c > \"z\") && (c < \"A\" || c > \"Z\") && (c < \"0\" || c > \"9\")) {\n    if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== TEXT) {\n      if (c !== \"=\") {\n        this._parseNamedEntityStrict();\n      }\n    } else {\n      this._parseLegacyEntity();\n    }\n    this._state = this._baseState;\n    this._index--;\n  }\n};\nTokenizer$1.prototype._decodeNumericEntity = function (offset, base) {\n  var sectionStart = this._sectionStart + offset;\n  if (sectionStart !== this._index) {\n    //parse entity\n    var entity = this._buffer.substring(sectionStart, this._index);\n    var parsed = parseInt(entity, base);\n    this._emitPartial(decodeCodePoint(parsed));\n    this._sectionStart = this._index;\n  } else {\n    this._sectionStart--;\n  }\n  this._state = this._baseState;\n};\nTokenizer$1.prototype._stateInNumericEntity = function (c) {\n  if (c === \";\") {\n    this._decodeNumericEntity(2, 10);\n    this._sectionStart++;\n  } else if (c < \"0\" || c > \"9\") {\n    if (!this._xmlMode) {\n      this._decodeNumericEntity(2, 10);\n    } else {\n      this._state = this._baseState;\n    }\n    this._index--;\n  }\n};\nTokenizer$1.prototype._stateInHexEntity = function (c) {\n  if (c === \";\") {\n    this._decodeNumericEntity(3, 16);\n    this._sectionStart++;\n  } else if ((c < \"a\" || c > \"f\") && (c < \"A\" || c > \"F\") && (c < \"0\" || c > \"9\")) {\n    if (!this._xmlMode) {\n      this._decodeNumericEntity(3, 16);\n    } else {\n      this._state = this._baseState;\n    }\n    this._index--;\n  }\n};\nTokenizer$1.prototype._cleanup = function () {\n  if (this._sectionStart < 0) {\n    this._buffer = \"\";\n    this._bufferOffset += this._index;\n    this._index = 0;\n  } else if (this._running) {\n    if (this._state === TEXT) {\n      if (this._sectionStart !== this._index) {\n        this._cbs.ontext(this._buffer.substr(this._sectionStart));\n      }\n      this._buffer = \"\";\n      this._bufferOffset += this._index;\n      this._index = 0;\n    } else if (this._sectionStart === this._index) {\n      //the section just started\n      this._buffer = \"\";\n      this._bufferOffset += this._index;\n      this._index = 0;\n    } else {\n      //remove everything unnecessary\n      this._buffer = this._buffer.substr(this._sectionStart);\n      this._index -= this._sectionStart;\n      this._bufferOffset += this._sectionStart;\n    }\n    this._sectionStart = 0;\n  }\n};\n\n//TODO make events conditional\nTokenizer$1.prototype.write = function (chunk) {\n  if (this._ended) this._cbs.onerror(Error(\".write() after done!\"));\n  this._buffer += chunk;\n  this._parse();\n};\nTokenizer$1.prototype._parse = function () {\n  while (this._index < this._buffer.length && this._running) {\n    var c = this._buffer.charAt(this._index);\n    if (this._state === TEXT) {\n      this._stateText(c);\n    } else if (this._state === BEFORE_TAG_NAME) {\n      this._stateBeforeTagName(c);\n    } else if (this._state === IN_TAG_NAME) {\n      this._stateInTagName(c);\n    } else if (this._state === BEFORE_CLOSING_TAG_NAME) {\n      this._stateBeforeCloseingTagName(c);\n    } else if (this._state === IN_CLOSING_TAG_NAME) {\n      this._stateInCloseingTagName(c);\n    } else if (this._state === AFTER_CLOSING_TAG_NAME) {\n      this._stateAfterCloseingTagName(c);\n    } else if (this._state === IN_SELF_CLOSING_TAG) {\n      this._stateInSelfClosingTag(c);\n    } else if (this._state === BEFORE_ATTRIBUTE_NAME) {\n      /*\n      *\tattributes\n      */\n      this._stateBeforeAttributeName(c);\n    } else if (this._state === IN_ATTRIBUTE_NAME) {\n      this._stateInAttributeName(c);\n    } else if (this._state === AFTER_ATTRIBUTE_NAME) {\n      this._stateAfterAttributeName(c);\n    } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {\n      this._stateBeforeAttributeValue(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {\n      this._stateInAttributeValueDoubleQuotes(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {\n      this._stateInAttributeValueSingleQuotes(c);\n    } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {\n      this._stateInAttributeValueNoQuotes(c);\n    } else if (this._state === BEFORE_DECLARATION) {\n      /*\n      *\tdeclarations\n      */\n      this._stateBeforeDeclaration(c);\n    } else if (this._state === IN_DECLARATION) {\n      this._stateInDeclaration(c);\n    } else if (this._state === IN_PROCESSING_INSTRUCTION) {\n      /*\n      *\tprocessing instructions\n      */\n      this._stateInProcessingInstruction(c);\n    } else if (this._state === BEFORE_COMMENT) {\n      /*\n      *\tcomments\n      */\n      this._stateBeforeComment(c);\n    } else if (this._state === IN_COMMENT) {\n      this._stateInComment(c);\n    } else if (this._state === AFTER_COMMENT_1) {\n      this._stateAfterComment1(c);\n    } else if (this._state === AFTER_COMMENT_2) {\n      this._stateAfterComment2(c);\n    } else if (this._state === BEFORE_CDATA_1) {\n      /*\n      *\tcdata\n      */\n      this._stateBeforeCdata1(c);\n    } else if (this._state === BEFORE_CDATA_2) {\n      this._stateBeforeCdata2(c);\n    } else if (this._state === BEFORE_CDATA_3) {\n      this._stateBeforeCdata3(c);\n    } else if (this._state === BEFORE_CDATA_4) {\n      this._stateBeforeCdata4(c);\n    } else if (this._state === BEFORE_CDATA_5) {\n      this._stateBeforeCdata5(c);\n    } else if (this._state === BEFORE_CDATA_6) {\n      this._stateBeforeCdata6(c);\n    } else if (this._state === IN_CDATA) {\n      this._stateInCdata(c);\n    } else if (this._state === AFTER_CDATA_1) {\n      this._stateAfterCdata1(c);\n    } else if (this._state === AFTER_CDATA_2) {\n      this._stateAfterCdata2(c);\n    } else if (this._state === BEFORE_SPECIAL) {\n      /*\n      * special tags\n      */\n      this._stateBeforeSpecial(c);\n    } else if (this._state === BEFORE_SPECIAL_END) {\n      this._stateBeforeSpecialEnd(c);\n    } else if (this._state === BEFORE_SCRIPT_1) {\n      /*\n      * script\n      */\n      this._stateBeforeScript1(c);\n    } else if (this._state === BEFORE_SCRIPT_2) {\n      this._stateBeforeScript2(c);\n    } else if (this._state === BEFORE_SCRIPT_3) {\n      this._stateBeforeScript3(c);\n    } else if (this._state === BEFORE_SCRIPT_4) {\n      this._stateBeforeScript4(c);\n    } else if (this._state === BEFORE_SCRIPT_5) {\n      this._stateBeforeScript5(c);\n    } else if (this._state === AFTER_SCRIPT_1) {\n      this._stateAfterScript1(c);\n    } else if (this._state === AFTER_SCRIPT_2) {\n      this._stateAfterScript2(c);\n    } else if (this._state === AFTER_SCRIPT_3) {\n      this._stateAfterScript3(c);\n    } else if (this._state === AFTER_SCRIPT_4) {\n      this._stateAfterScript4(c);\n    } else if (this._state === AFTER_SCRIPT_5) {\n      this._stateAfterScript5(c);\n    } else if (this._state === BEFORE_STYLE_1) {\n      /*\n      * style\n      */\n      this._stateBeforeStyle1(c);\n    } else if (this._state === BEFORE_STYLE_2) {\n      this._stateBeforeStyle2(c);\n    } else if (this._state === BEFORE_STYLE_3) {\n      this._stateBeforeStyle3(c);\n    } else if (this._state === BEFORE_STYLE_4) {\n      this._stateBeforeStyle4(c);\n    } else if (this._state === AFTER_STYLE_1) {\n      this._stateAfterStyle1(c);\n    } else if (this._state === AFTER_STYLE_2) {\n      this._stateAfterStyle2(c);\n    } else if (this._state === AFTER_STYLE_3) {\n      this._stateAfterStyle3(c);\n    } else if (this._state === AFTER_STYLE_4) {\n      this._stateAfterStyle4(c);\n    } else if (this._state === BEFORE_ENTITY) {\n      /*\n      * entities\n      */\n      this._stateBeforeEntity(c);\n    } else if (this._state === BEFORE_NUMERIC_ENTITY) {\n      this._stateBeforeNumericEntity(c);\n    } else if (this._state === IN_NAMED_ENTITY) {\n      this._stateInNamedEntity(c);\n    } else if (this._state === IN_NUMERIC_ENTITY) {\n      this._stateInNumericEntity(c);\n    } else if (this._state === IN_HEX_ENTITY) {\n      this._stateInHexEntity(c);\n    } else {\n      this._cbs.onerror(Error(\"unknown _state\"), this._state);\n    }\n    this._index++;\n  }\n  this._cleanup();\n};\nTokenizer$1.prototype.pause = function () {\n  this._running = false;\n};\nTokenizer$1.prototype.resume = function () {\n  this._running = true;\n  if (this._index < this._buffer.length) {\n    this._parse();\n  }\n  if (this._ended) {\n    this._finish();\n  }\n};\nTokenizer$1.prototype.end = function (chunk) {\n  if (this._ended) this._cbs.onerror(Error(\".end() after done!\"));\n  if (chunk) this.write(chunk);\n  this._ended = true;\n  if (this._running) this._finish();\n};\nTokenizer$1.prototype._finish = function () {\n  //if there is remaining data, emit it in a reasonable way\n  if (this._sectionStart < this._index) {\n    this._handleTrailingData();\n  }\n  this._cbs.onend();\n};\nTokenizer$1.prototype._handleTrailingData = function () {\n  var data = this._buffer.substr(this._sectionStart);\n  if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {\n    this._cbs.oncdata(data);\n  } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {\n    this._cbs.oncomment(data);\n  } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {\n    this._parseLegacyEntity();\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n      this._handleTrailingData();\n    }\n  } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {\n    this._decodeNumericEntity(2, 10);\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n      this._handleTrailingData();\n    }\n  } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {\n    this._decodeNumericEntity(3, 16);\n    if (this._sectionStart < this._index) {\n      this._state = this._baseState;\n      this._handleTrailingData();\n    }\n  } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {\n    this._cbs.ontext(data);\n  }\n  //else, ignore remaining data\n  //TODO add a way to remove current tag\n};\nTokenizer$1.prototype.reset = function () {\n  Tokenizer$1.call(this, {\n    xmlMode: this._xmlMode,\n    decodeEntities: this._decodeEntities\n  }, this._cbs);\n};\nTokenizer$1.prototype.getAbsoluteIndex = function () {\n  return this._bufferOffset + this._index;\n};\nTokenizer$1.prototype._getSection = function () {\n  return this._buffer.substring(this._sectionStart, this._index);\n};\nTokenizer$1.prototype._emitToken = function (name) {\n  this._cbs[name](this._getSection());\n  this._sectionStart = -1;\n};\nTokenizer$1.prototype._emitPartial = function (value) {\n  if (this._baseState !== TEXT) {\n    this._cbs.onattribdata(value); //TODO implement the new event\n  } else {\n    this._cbs.ontext(value);\n  }\n};\n\nvar inherits;\nif (typeof Object.create === 'function'){\n  inherits = function inherits(ctor, superCtor) {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\nvar inherits$1 = inherits;\n\nvar _polyfillNode_inherits = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  default: inherits$1\n});\n\nvar require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_inherits);\n\nvar Tokenizer = Tokenizer_1;\n\n/*\n\tOptions:\n\n\txmlMode: Disables the special behavior for script/style tags (false by default)\n\tlowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)\n\tlowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)\n*/\n\n/*\n\tCallbacks:\n\n\toncdataend,\n\toncdatastart,\n\tonclosetag,\n\toncomment,\n\toncommentend,\n\tonerror,\n\tonopentag,\n\tonprocessinginstruction,\n\tonreset,\n\tontext\n*/\n\nvar formTags = {\n  input: true,\n  option: true,\n  optgroup: true,\n  select: true,\n  button: true,\n  datalist: true,\n  textarea: true\n};\nvar openImpliesClose = {\n  tr: {\n    tr: true,\n    th: true,\n    td: true\n  },\n  th: {\n    th: true\n  },\n  td: {\n    thead: true,\n    th: true,\n    td: true\n  },\n  body: {\n    head: true,\n    link: true,\n    script: true\n  },\n  li: {\n    li: true\n  },\n  p: {\n    p: true\n  },\n  h1: {\n    p: true\n  },\n  h2: {\n    p: true\n  },\n  h3: {\n    p: true\n  },\n  h4: {\n    p: true\n  },\n  h5: {\n    p: true\n  },\n  h6: {\n    p: true\n  },\n  select: formTags,\n  input: formTags,\n  output: formTags,\n  button: formTags,\n  datalist: formTags,\n  textarea: formTags,\n  option: {\n    option: true\n  },\n  optgroup: {\n    optgroup: true\n  }\n};\nvar voidElements = {\n  __proto__: null,\n  area: true,\n  base: true,\n  basefont: true,\n  br: true,\n  col: true,\n  command: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  isindex: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\nvar foreignContextElements = {\n  __proto__: null,\n  math: true,\n  svg: true\n};\nvar htmlIntegrationElements = {\n  __proto__: null,\n  mi: true,\n  mo: true,\n  mn: true,\n  ms: true,\n  mtext: true,\n  \"annotation-xml\": true,\n  foreignObject: true,\n  desc: true,\n  title: true\n};\nvar re_nameEnd = /\\s|\\//;\nfunction Parser(cbs, options) {\n  this._options = options || {};\n  this._cbs = cbs || {};\n  this._tagname = \"\";\n  this._attribname = \"\";\n  this._attribvalue = \"\";\n  this._attribs = null;\n  this._stack = [];\n  this._foreignContext = [];\n  this.startIndex = 0;\n  this.endIndex = null;\n  this._lowerCaseTagNames = \"lowerCaseTags\" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;\n  this._lowerCaseAttributeNames = \"lowerCaseAttributeNames\" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;\n  if (this._options.Tokenizer) {\n    Tokenizer = this._options.Tokenizer;\n  }\n  this._tokenizer = new Tokenizer(this._options, this);\n  if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n}\nrequire$$1$3(Parser, require$$0$3.EventEmitter);\nParser.prototype._updatePosition = function (initialOffset) {\n  if (this.endIndex === null) {\n    if (this._tokenizer._sectionStart <= initialOffset) {\n      this.startIndex = 0;\n    } else {\n      this.startIndex = this._tokenizer._sectionStart - initialOffset;\n    }\n  } else this.startIndex = this.endIndex + 1;\n  this.endIndex = this._tokenizer.getAbsoluteIndex();\n};\n\n//Tokenizer event handlers\nParser.prototype.ontext = function (data) {\n  this._updatePosition(1);\n  this.endIndex--;\n  if (this._cbs.ontext) this._cbs.ontext(data);\n};\nParser.prototype.onopentagname = function (name) {\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n  this._tagname = name;\n  if (!this._options.xmlMode && name in openImpliesClose) {\n    for (var el; ((el = this._stack[this._stack.length - 1]) in openImpliesClose[name]); this.onclosetag(el));\n  }\n  if (this._options.xmlMode || !(name in voidElements)) {\n    this._stack.push(name);\n    if (name in foreignContextElements) this._foreignContext.push(true);else if (name in htmlIntegrationElements) this._foreignContext.push(false);\n  }\n  if (this._cbs.onopentagname) this._cbs.onopentagname(name);\n  if (this._cbs.onopentag) this._attribs = {};\n};\nParser.prototype.onopentagend = function () {\n  this._updatePosition(1);\n  if (this._attribs) {\n    if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);\n    this._attribs = null;\n  }\n  if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {\n    this._cbs.onclosetag(this._tagname);\n  }\n  this._tagname = \"\";\n};\nParser.prototype.onclosetag = function (name) {\n  this._updatePosition(1);\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n  if (name in foreignContextElements || name in htmlIntegrationElements) {\n    this._foreignContext.pop();\n  }\n  if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {\n    var pos = this._stack.lastIndexOf(name);\n    if (pos !== -1) {\n      if (this._cbs.onclosetag) {\n        pos = this._stack.length - pos;\n        while (pos--) this._cbs.onclosetag(this._stack.pop());\n      } else this._stack.length = pos;\n    } else if (name === \"p\" && !this._options.xmlMode) {\n      this.onopentagname(name);\n      this._closeCurrentTag();\n    }\n  } else if (!this._options.xmlMode && (name === \"br\" || name === \"p\")) {\n    this.onopentagname(name);\n    this._closeCurrentTag();\n  }\n};\nParser.prototype.onselfclosingtag = function () {\n  if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {\n    this._closeCurrentTag();\n  } else {\n    this.onopentagend();\n  }\n};\nParser.prototype._closeCurrentTag = function () {\n  var name = this._tagname;\n  this.onopentagend();\n\n  //self-closing tags will be on the top of the stack\n  //(cheaper check than in onclosetag)\n  if (this._stack[this._stack.length - 1] === name) {\n    if (this._cbs.onclosetag) {\n      this._cbs.onclosetag(name);\n    }\n    this._stack.pop();\n  }\n};\nParser.prototype.onattribname = function (name) {\n  if (this._lowerCaseAttributeNames) {\n    name = name.toLowerCase();\n  }\n  this._attribname = name;\n};\nParser.prototype.onattribdata = function (value) {\n  this._attribvalue += value;\n};\nParser.prototype.onattribend = function () {\n  if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);\n  if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {\n    this._attribs[this._attribname] = this._attribvalue;\n  }\n  this._attribname = \"\";\n  this._attribvalue = \"\";\n};\nParser.prototype._getInstructionName = function (value) {\n  var idx = value.search(re_nameEnd),\n    name = idx < 0 ? value : value.substr(0, idx);\n  if (this._lowerCaseTagNames) {\n    name = name.toLowerCase();\n  }\n  return name;\n};\nParser.prototype.ondeclaration = function (value) {\n  if (this._cbs.onprocessinginstruction) {\n    var name = this._getInstructionName(value);\n    this._cbs.onprocessinginstruction(\"!\" + name, \"!\" + value);\n  }\n};\nParser.prototype.onprocessinginstruction = function (value) {\n  if (this._cbs.onprocessinginstruction) {\n    var name = this._getInstructionName(value);\n    this._cbs.onprocessinginstruction(\"?\" + name, \"?\" + value);\n  }\n};\nParser.prototype.oncomment = function (value) {\n  this._updatePosition(4);\n  if (this._cbs.oncomment) this._cbs.oncomment(value);\n  if (this._cbs.oncommentend) this._cbs.oncommentend();\n};\nParser.prototype.oncdata = function (value) {\n  this._updatePosition(1);\n  if (this._options.xmlMode || this._options.recognizeCDATA) {\n    if (this._cbs.oncdatastart) this._cbs.oncdatastart();\n    if (this._cbs.ontext) this._cbs.ontext(value);\n    if (this._cbs.oncdataend) this._cbs.oncdataend();\n  } else {\n    this.oncomment(\"[CDATA[\" + value + \"]]\");\n  }\n};\nParser.prototype.onerror = function (err) {\n  if (this._cbs.onerror) this._cbs.onerror(err);\n};\nParser.prototype.onend = function () {\n  if (this._cbs.onclosetag) {\n    for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));\n  }\n  if (this._cbs.onend) this._cbs.onend();\n};\n\n//Resets the parser to a blank state, ready to parse a new HTML document\nParser.prototype.reset = function () {\n  if (this._cbs.onreset) this._cbs.onreset();\n  this._tokenizer.reset();\n  this._tagname = \"\";\n  this._attribname = \"\";\n  this._attribs = null;\n  this._stack = [];\n  if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n};\n\n//Parses a complete HTML document and pushes it to the handler\nParser.prototype.parseComplete = function (data) {\n  this.reset();\n  this.end(data);\n};\nParser.prototype.write = function (chunk) {\n  this._tokenizer.write(chunk);\n};\nParser.prototype.end = function (chunk) {\n  this._tokenizer.end(chunk);\n};\nParser.prototype.pause = function () {\n  this._tokenizer.pause();\n};\nParser.prototype.resume = function () {\n  this._tokenizer.resume();\n};\n\n//alias for backwards compat\nParser.prototype.parseChunk = Parser.prototype.write;\nParser.prototype.done = Parser.prototype.end;\nvar Parser_1 = Parser;\n\n//Types of elements found in the DOM\nvar domelementtype = {\n  Text: \"text\",\n  //Text\n  Directive: \"directive\",\n  //<? ... ?>\n  Comment: \"comment\",\n  //<!-- ... -->\n  Script: \"script\",\n  //<script> tags\n  Style: \"style\",\n  //<style> tags\n  Tag: \"tag\",\n  //Any tag\n  CDATA: \"cdata\",\n  //<![CDATA[ ... ]]>\n  Doctype: \"doctype\",\n  isTag: function isTag(elem) {\n    return elem.type === \"tag\" || elem.type === \"script\" || elem.type === \"style\";\n  }\n};\n\nvar node = {exports: {}};\n\n// This object will be used as the prototype for Nodes when creating a\n// DOM-Level-1-compliant structure.\nnode.exports = {\n  get firstChild() {\n    var children = this.children;\n    return children && children[0] || null;\n  },\n  get lastChild() {\n    var children = this.children;\n    return children && children[children.length - 1] || null;\n  },\n  get nodeType() {\n    return nodeTypes[this.type] || nodeTypes.element;\n  }\n};\nvar domLvl1$1 = {\n  tagName: \"name\",\n  childNodes: \"children\",\n  parentNode: \"parent\",\n  previousSibling: \"prev\",\n  nextSibling: \"next\",\n  nodeValue: \"data\"\n};\nvar nodeTypes = {\n  element: 1,\n  text: 3,\n  cdata: 4,\n  comment: 8\n};\nObject.keys(domLvl1$1).forEach(function (key) {\n});\nvar nodeExports = node.exports;\n\nvar element = {exports: {}};\n\n// DOM-Level-1-compliant structure\nvar NodePrototype$1 = nodeExports;\nvar ElementPrototype$1 = element.exports = Object.create(NodePrototype$1);\nvar domLvl1 = {\n  tagName: \"name\"\n};\nObject.keys(domLvl1).forEach(function (key) {\n  var shorthand = domLvl1[key];\n  Object.defineProperty(ElementPrototype$1, key, {\n    get: function get() {\n      return this[shorthand] || null;\n    },\n    set: function set(val) {\n      this[shorthand] = val;\n      return val;\n    }\n  });\n});\nvar elementExports = element.exports;\n\nvar ElementType = domelementtype;\nvar re_whitespace = /\\s+/g;\nvar NodePrototype = nodeExports;\nvar ElementPrototype = elementExports;\nfunction DomHandler(callback, options, elementCB) {\n  if (_typeof(callback) === \"object\") {\n    elementCB = options;\n    options = callback;\n    callback = null;\n  } else if (typeof options === \"function\") {\n    elementCB = options;\n    options = defaultOpts;\n  }\n  this._callback = callback;\n  this._options = options || defaultOpts;\n  this._elementCB = elementCB;\n  this.dom = [];\n  this._done = false;\n  this._tagStack = [];\n  this._parser = this._parser || null;\n}\n\n//default options\nvar defaultOpts = {\n  normalizeWhitespace: false,\n  //Replace all whitespace with single spaces\n  withStartIndices: false,\n  //Add startIndex properties to nodes\n  withEndIndices: false //Add endIndex properties to nodes\n};\nDomHandler.prototype.onparserinit = function (parser) {\n  this._parser = parser;\n};\n\n//Resets the handler back to starting state\nDomHandler.prototype.onreset = function () {\n  DomHandler.call(this, this._callback, this._options, this._elementCB);\n};\n\n//Signals the handler that parsing is done\nDomHandler.prototype.onend = function () {\n  if (this._done) return;\n  this._done = true;\n  this._parser = null;\n  this._handleCallback(null);\n};\nDomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) {\n  if (typeof this._callback === \"function\") {\n    this._callback(error, this.dom);\n  } else {\n    if (error) throw error;\n  }\n};\nDomHandler.prototype.onclosetag = function () {\n  //if(this._tagStack.pop().name !== name) this._handleCallback(Error(\"Tagname didn't match!\"));\n\n  var elem = this._tagStack.pop();\n  if (this._options.withEndIndices && elem) {\n    elem.endIndex = this._parser.endIndex;\n  }\n  if (this._elementCB) this._elementCB(elem);\n};\nDomHandler.prototype._createDomElement = function (properties) {\n  if (!this._options.withDomLvl1) return properties;\n  var element;\n  if (properties.type === \"tag\") {\n    element = Object.create(ElementPrototype);\n  } else {\n    element = Object.create(NodePrototype);\n  }\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      element[key] = properties[key];\n    }\n  }\n  return element;\n};\nDomHandler.prototype._addDomElement = function (element) {\n  var parent = this._tagStack[this._tagStack.length - 1];\n  var siblings = parent ? parent.children : this.dom;\n  var previousSibling = siblings[siblings.length - 1];\n  element.next = null;\n  if (this._options.withStartIndices) {\n    element.startIndex = this._parser.startIndex;\n  }\n  if (this._options.withEndIndices) {\n    element.endIndex = this._parser.endIndex;\n  }\n  if (previousSibling) {\n    element.prev = previousSibling;\n    previousSibling.next = element;\n  } else {\n    element.prev = null;\n  }\n  siblings.push(element);\n  element.parent = parent || null;\n};\nDomHandler.prototype.onopentag = function (name, attribs) {\n  var properties = {\n    type: name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag,\n    name: name,\n    attribs: attribs,\n    children: []\n  };\n  var element = this._createDomElement(properties);\n  this._addDomElement(element);\n  this._tagStack.push(element);\n};\nDomHandler.prototype.ontext = function (data) {\n  //the ignoreWhitespace is officially dropped, but for now,\n  //it's an alias for normalizeWhitespace\n  var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;\n  var lastTag;\n  if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {\n    if (normalize) {\n      lastTag.data = (lastTag.data + data).replace(re_whitespace, \" \");\n    } else {\n      lastTag.data += data;\n    }\n  } else {\n    if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {\n      if (normalize) {\n        lastTag.data = (lastTag.data + data).replace(re_whitespace, \" \");\n      } else {\n        lastTag.data += data;\n      }\n    } else {\n      if (normalize) {\n        data = data.replace(re_whitespace, \" \");\n      }\n      var element = this._createDomElement({\n        data: data,\n        type: ElementType.Text\n      });\n      this._addDomElement(element);\n    }\n  }\n};\nDomHandler.prototype.oncomment = function (data) {\n  var lastTag = this._tagStack[this._tagStack.length - 1];\n  if (lastTag && lastTag.type === ElementType.Comment) {\n    lastTag.data += data;\n    return;\n  }\n  var properties = {\n    data: data,\n    type: ElementType.Comment\n  };\n  var element = this._createDomElement(properties);\n  this._addDomElement(element);\n  this._tagStack.push(element);\n};\nDomHandler.prototype.oncdatastart = function () {\n  var properties = {\n    children: [{\n      data: \"\",\n      type: ElementType.Text\n    }],\n    type: ElementType.CDATA\n  };\n  var element = this._createDomElement(properties);\n  this._addDomElement(element);\n  this._tagStack.push(element);\n};\nDomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () {\n  this._tagStack.pop();\n};\nDomHandler.prototype.onprocessinginstruction = function (name, data) {\n  var element = this._createDomElement({\n    name: name,\n    data: data,\n    type: ElementType.Directive\n  });\n  this._addDomElement(element);\n};\nvar domhandler = DomHandler;\n\nvar domutils = {exports: {}};\n\nvar domSerializer = {exports: {}};\n\nvar lib$1 = {};\n\nvar hasRequiredLib$2;\nfunction requireLib$2() {\n  if (hasRequiredLib$2) return lib$1;\n  hasRequiredLib$2 = 1;\n  (function (exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;\n    /** Types of elements found in htmlparser2's DOM */\n    var ElementType;\n    (function (ElementType) {\n      /** Type for the root element of a document */\n      ElementType[\"Root\"] = \"root\";\n      /** Type for Text */\n      ElementType[\"Text\"] = \"text\";\n      /** Type for <? ... ?> */\n      ElementType[\"Directive\"] = \"directive\";\n      /** Type for <!-- ... --> */\n      ElementType[\"Comment\"] = \"comment\";\n      /** Type for <script> tags */\n      ElementType[\"Script\"] = \"script\";\n      /** Type for <style> tags */\n      ElementType[\"Style\"] = \"style\";\n      /** Type for Any tag */\n      ElementType[\"Tag\"] = \"tag\";\n      /** Type for <![CDATA[ ... ]]> */\n      ElementType[\"CDATA\"] = \"cdata\";\n      /** Type for <!doctype ...> */\n      ElementType[\"Doctype\"] = \"doctype\";\n    })(ElementType = exports.ElementType || (exports.ElementType = {}));\n    /**\n     * Tests whether an element is a tag or not.\n     *\n     * @param elem Element to test\n     */\n    function isTag(elem) {\n      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;\n    }\n    exports.isTag = isTag;\n    // Exports for backwards compatibility\n    /** Type for the root element of a document */\n    exports.Root = ElementType.Root;\n    /** Type for Text */\n    exports.Text = ElementType.Text;\n    /** Type for <? ... ?> */\n    exports.Directive = ElementType.Directive;\n    /** Type for <!-- ... --> */\n    exports.Comment = ElementType.Comment;\n    /** Type for <script> tags */\n    exports.Script = ElementType.Script;\n    /** Type for <style> tags */\n    exports.Style = ElementType.Style;\n    /** Type for Any tag */\n    exports.Tag = ElementType.Tag;\n    /** Type for <![CDATA[ ... ]]> */\n    exports.CDATA = ElementType.CDATA;\n    /** Type for <!doctype ...> */\n    exports.Doctype = ElementType.Doctype;\n  })(lib$1);\n  return lib$1;\n}\n\nvar lib = {};\n\nvar decode = {};\n\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element$1 = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map$1 = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx$1 = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target$1 = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$2 = {\n\tAacute: Aacute$1,\n\taacute: aacute$1,\n\tAbreve: Abreve,\n\tabreve: abreve,\n\tac: ac,\n\tacd: acd,\n\tacE: acE,\n\tAcirc: Acirc$1,\n\tacirc: acirc$1,\n\tacute: acute$1,\n\tAcy: Acy,\n\tacy: acy,\n\tAElig: AElig$1,\n\taelig: aelig$1,\n\taf: af,\n\tAfr: Afr,\n\tafr: afr,\n\tAgrave: Agrave$1,\n\tagrave: agrave$1,\n\talefsym: alefsym,\n\taleph: aleph,\n\tAlpha: Alpha,\n\talpha: alpha,\n\tAmacr: Amacr,\n\tamacr: amacr,\n\tamalg: amalg,\n\tamp: amp$2,\n\tAMP: AMP$1,\n\tandand: andand,\n\tAnd: And,\n\tand: and,\n\tandd: andd,\n\tandslope: andslope,\n\tandv: andv,\n\tang: ang,\n\tange: ange,\n\tangle: angle,\n\tangmsdaa: angmsdaa,\n\tangmsdab: angmsdab,\n\tangmsdac: angmsdac,\n\tangmsdad: angmsdad,\n\tangmsdae: angmsdae,\n\tangmsdaf: angmsdaf,\n\tangmsdag: angmsdag,\n\tangmsdah: angmsdah,\n\tangmsd: angmsd,\n\tangrt: angrt,\n\tangrtvb: angrtvb,\n\tangrtvbd: angrtvbd,\n\tangsph: angsph,\n\tangst: angst,\n\tangzarr: angzarr,\n\tAogon: Aogon,\n\taogon: aogon,\n\tAopf: Aopf,\n\taopf: aopf,\n\tapacir: apacir,\n\tap: ap,\n\tapE: apE,\n\tape: ape,\n\tapid: apid,\n\tapos: apos$1,\n\tApplyFunction: ApplyFunction,\n\tapprox: approx,\n\tapproxeq: approxeq,\n\tAring: Aring$1,\n\taring: aring$1,\n\tAscr: Ascr,\n\tascr: ascr,\n\tAssign: Assign,\n\tast: ast,\n\tasymp: asymp,\n\tasympeq: asympeq,\n\tAtilde: Atilde$1,\n\tatilde: atilde$1,\n\tAuml: Auml$1,\n\tauml: auml$1,\n\tawconint: awconint,\n\tawint: awint,\n\tbackcong: backcong,\n\tbackepsilon: backepsilon,\n\tbackprime: backprime,\n\tbacksim: backsim,\n\tbacksimeq: backsimeq,\n\tBackslash: Backslash,\n\tBarv: Barv,\n\tbarvee: barvee,\n\tbarwed: barwed,\n\tBarwed: Barwed,\n\tbarwedge: barwedge,\n\tbbrk: bbrk,\n\tbbrktbrk: bbrktbrk,\n\tbcong: bcong,\n\tBcy: Bcy,\n\tbcy: bcy,\n\tbdquo: bdquo,\n\tbecaus: becaus,\n\tbecause: because,\n\tBecause: Because,\n\tbemptyv: bemptyv,\n\tbepsi: bepsi,\n\tbernou: bernou,\n\tBernoullis: Bernoullis,\n\tBeta: Beta,\n\tbeta: beta,\n\tbeth: beth,\n\tbetween: between,\n\tBfr: Bfr,\n\tbfr: bfr,\n\tbigcap: bigcap,\n\tbigcirc: bigcirc,\n\tbigcup: bigcup,\n\tbigodot: bigodot,\n\tbigoplus: bigoplus,\n\tbigotimes: bigotimes,\n\tbigsqcup: bigsqcup,\n\tbigstar: bigstar,\n\tbigtriangledown: bigtriangledown,\n\tbigtriangleup: bigtriangleup,\n\tbiguplus: biguplus,\n\tbigvee: bigvee,\n\tbigwedge: bigwedge,\n\tbkarow: bkarow,\n\tblacklozenge: blacklozenge,\n\tblacksquare: blacksquare,\n\tblacktriangle: blacktriangle,\n\tblacktriangledown: blacktriangledown,\n\tblacktriangleleft: blacktriangleleft,\n\tblacktriangleright: blacktriangleright,\n\tblank: blank,\n\tblk12: blk12,\n\tblk14: blk14,\n\tblk34: blk34,\n\tblock: block,\n\tbne: bne,\n\tbnequiv: bnequiv,\n\tbNot: bNot,\n\tbnot: bnot,\n\tBopf: Bopf,\n\tbopf: bopf,\n\tbot: bot,\n\tbottom: bottom,\n\tbowtie: bowtie,\n\tboxbox: boxbox,\n\tboxdl: boxdl,\n\tboxdL: boxdL,\n\tboxDl: boxDl,\n\tboxDL: boxDL,\n\tboxdr: boxdr,\n\tboxdR: boxdR,\n\tboxDr: boxDr,\n\tboxDR: boxDR,\n\tboxh: boxh,\n\tboxH: boxH,\n\tboxhd: boxhd,\n\tboxHd: boxHd,\n\tboxhD: boxhD,\n\tboxHD: boxHD,\n\tboxhu: boxhu,\n\tboxHu: boxHu,\n\tboxhU: boxhU,\n\tboxHU: boxHU,\n\tboxminus: boxminus,\n\tboxplus: boxplus,\n\tboxtimes: boxtimes,\n\tboxul: boxul,\n\tboxuL: boxuL,\n\tboxUl: boxUl,\n\tboxUL: boxUL,\n\tboxur: boxur,\n\tboxuR: boxuR,\n\tboxUr: boxUr,\n\tboxUR: boxUR,\n\tboxv: boxv,\n\tboxV: boxV,\n\tboxvh: boxvh,\n\tboxvH: boxvH,\n\tboxVh: boxVh,\n\tboxVH: boxVH,\n\tboxvl: boxvl,\n\tboxvL: boxvL,\n\tboxVl: boxVl,\n\tboxVL: boxVL,\n\tboxvr: boxvr,\n\tboxvR: boxvR,\n\tboxVr: boxVr,\n\tboxVR: boxVR,\n\tbprime: bprime,\n\tbreve: breve,\n\tBreve: Breve,\n\tbrvbar: brvbar$1,\n\tbscr: bscr,\n\tBscr: Bscr,\n\tbsemi: bsemi,\n\tbsim: bsim,\n\tbsime: bsime,\n\tbsolb: bsolb,\n\tbsol: bsol,\n\tbsolhsub: bsolhsub,\n\tbull: bull,\n\tbullet: bullet,\n\tbump: bump,\n\tbumpE: bumpE,\n\tbumpe: bumpe,\n\tBumpeq: Bumpeq,\n\tbumpeq: bumpeq,\n\tCacute: Cacute,\n\tcacute: cacute,\n\tcapand: capand,\n\tcapbrcup: capbrcup,\n\tcapcap: capcap,\n\tcap: cap,\n\tCap: Cap,\n\tcapcup: capcup,\n\tcapdot: capdot,\n\tCapitalDifferentialD: CapitalDifferentialD,\n\tcaps: caps,\n\tcaret: caret,\n\tcaron: caron,\n\tCayleys: Cayleys,\n\tccaps: ccaps,\n\tCcaron: Ccaron,\n\tccaron: ccaron,\n\tCcedil: Ccedil$1,\n\tccedil: ccedil$1,\n\tCcirc: Ccirc,\n\tccirc: ccirc,\n\tCconint: Cconint,\n\tccups: ccups,\n\tccupssm: ccupssm,\n\tCdot: Cdot,\n\tcdot: cdot,\n\tcedil: cedil$1,\n\tCedilla: Cedilla,\n\tcemptyv: cemptyv,\n\tcent: cent$1,\n\tcenterdot: centerdot,\n\tCenterDot: CenterDot,\n\tcfr: cfr,\n\tCfr: Cfr,\n\tCHcy: CHcy,\n\tchcy: chcy,\n\tcheck: check,\n\tcheckmark: checkmark,\n\tChi: Chi,\n\tchi: chi,\n\tcirc: circ,\n\tcirceq: circeq,\n\tcirclearrowleft: circlearrowleft,\n\tcirclearrowright: circlearrowright,\n\tcircledast: circledast,\n\tcircledcirc: circledcirc,\n\tcircleddash: circleddash,\n\tCircleDot: CircleDot,\n\tcircledR: circledR,\n\tcircledS: circledS,\n\tCircleMinus: CircleMinus,\n\tCirclePlus: CirclePlus,\n\tCircleTimes: CircleTimes,\n\tcir: cir,\n\tcirE: cirE,\n\tcire: cire,\n\tcirfnint: cirfnint,\n\tcirmid: cirmid,\n\tcirscir: cirscir,\n\tClockwiseContourIntegral: ClockwiseContourIntegral,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n\tCloseCurlyQuote: CloseCurlyQuote,\n\tclubs: clubs,\n\tclubsuit: clubsuit,\n\tcolon: colon,\n\tColon: Colon,\n\tColone: Colone,\n\tcolone: colone,\n\tcoloneq: coloneq,\n\tcomma: comma,\n\tcommat: commat,\n\tcomp: comp,\n\tcompfn: compfn,\n\tcomplement: complement,\n\tcomplexes: complexes,\n\tcong: cong,\n\tcongdot: congdot,\n\tCongruent: Congruent,\n\tconint: conint,\n\tConint: Conint,\n\tContourIntegral: ContourIntegral,\n\tcopf: copf,\n\tCopf: Copf,\n\tcoprod: coprod,\n\tCoproduct: Coproduct,\n\tcopy: copy$1,\n\tCOPY: COPY$1,\n\tcopysr: copysr,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n\tcrarr: crarr,\n\tcross: cross,\n\tCross: Cross,\n\tCscr: Cscr,\n\tcscr: cscr,\n\tcsub: csub,\n\tcsube: csube,\n\tcsup: csup,\n\tcsupe: csupe,\n\tctdot: ctdot,\n\tcudarrl: cudarrl,\n\tcudarrr: cudarrr,\n\tcuepr: cuepr,\n\tcuesc: cuesc,\n\tcularr: cularr,\n\tcularrp: cularrp,\n\tcupbrcap: cupbrcap,\n\tcupcap: cupcap,\n\tCupCap: CupCap,\n\tcup: cup,\n\tCup: Cup,\n\tcupcup: cupcup,\n\tcupdot: cupdot,\n\tcupor: cupor,\n\tcups: cups,\n\tcurarr: curarr,\n\tcurarrm: curarrm,\n\tcurlyeqprec: curlyeqprec,\n\tcurlyeqsucc: curlyeqsucc,\n\tcurlyvee: curlyvee,\n\tcurlywedge: curlywedge,\n\tcurren: curren$1,\n\tcurvearrowleft: curvearrowleft,\n\tcurvearrowright: curvearrowright,\n\tcuvee: cuvee,\n\tcuwed: cuwed,\n\tcwconint: cwconint,\n\tcwint: cwint,\n\tcylcty: cylcty,\n\tdagger: dagger,\n\tDagger: Dagger,\n\tdaleth: daleth,\n\tdarr: darr,\n\tDarr: Darr,\n\tdArr: dArr,\n\tdash: dash,\n\tDashv: Dashv,\n\tdashv: dashv,\n\tdbkarow: dbkarow,\n\tdblac: dblac,\n\tDcaron: Dcaron,\n\tdcaron: dcaron,\n\tDcy: Dcy,\n\tdcy: dcy,\n\tddagger: ddagger,\n\tddarr: ddarr,\n\tDD: DD,\n\tdd: dd,\n\tDDotrahd: DDotrahd,\n\tddotseq: ddotseq,\n\tdeg: deg$1,\n\tDel: Del,\n\tDelta: Delta,\n\tdelta: delta,\n\tdemptyv: demptyv,\n\tdfisht: dfisht,\n\tDfr: Dfr,\n\tdfr: dfr,\n\tdHar: dHar,\n\tdharl: dharl,\n\tdharr: dharr,\n\tDiacriticalAcute: DiacriticalAcute,\n\tDiacriticalDot: DiacriticalDot,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute,\n\tDiacriticalGrave: DiacriticalGrave,\n\tDiacriticalTilde: DiacriticalTilde,\n\tdiam: diam,\n\tdiamond: diamond,\n\tDiamond: Diamond,\n\tdiamondsuit: diamondsuit,\n\tdiams: diams,\n\tdie: die,\n\tDifferentialD: DifferentialD,\n\tdigamma: digamma,\n\tdisin: disin,\n\tdiv: div,\n\tdivide: divide$1,\n\tdivideontimes: divideontimes,\n\tdivonx: divonx,\n\tDJcy: DJcy,\n\tdjcy: djcy,\n\tdlcorn: dlcorn,\n\tdlcrop: dlcrop,\n\tdollar: dollar,\n\tDopf: Dopf,\n\tdopf: dopf,\n\tDot: Dot,\n\tdot: dot,\n\tDotDot: DotDot,\n\tdoteq: doteq,\n\tdoteqdot: doteqdot,\n\tDotEqual: DotEqual,\n\tdotminus: dotminus,\n\tdotplus: dotplus,\n\tdotsquare: dotsquare,\n\tdoublebarwedge: doublebarwedge,\n\tDoubleContourIntegral: DoubleContourIntegral,\n\tDoubleDot: DoubleDot,\n\tDoubleDownArrow: DoubleDownArrow,\n\tDoubleLeftArrow: DoubleLeftArrow,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow,\n\tDoubleLeftTee: DoubleLeftTee,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n\tDoubleLongRightArrow: DoubleLongRightArrow,\n\tDoubleRightArrow: DoubleRightArrow,\n\tDoubleRightTee: DoubleRightTee,\n\tDoubleUpArrow: DoubleUpArrow,\n\tDoubleUpDownArrow: DoubleUpDownArrow,\n\tDoubleVerticalBar: DoubleVerticalBar,\n\tDownArrowBar: DownArrowBar,\n\tdownarrow: downarrow,\n\tDownArrow: DownArrow,\n\tDownarrow: Downarrow,\n\tDownArrowUpArrow: DownArrowUpArrow,\n\tDownBreve: DownBreve,\n\tdowndownarrows: downdownarrows,\n\tdownharpoonleft: downharpoonleft,\n\tdownharpoonright: downharpoonright,\n\tDownLeftRightVector: DownLeftRightVector,\n\tDownLeftTeeVector: DownLeftTeeVector,\n\tDownLeftVectorBar: DownLeftVectorBar,\n\tDownLeftVector: DownLeftVector,\n\tDownRightTeeVector: DownRightTeeVector,\n\tDownRightVectorBar: DownRightVectorBar,\n\tDownRightVector: DownRightVector,\n\tDownTeeArrow: DownTeeArrow,\n\tDownTee: DownTee,\n\tdrbkarow: drbkarow,\n\tdrcorn: drcorn,\n\tdrcrop: drcrop,\n\tDscr: Dscr,\n\tdscr: dscr,\n\tDScy: DScy,\n\tdscy: dscy,\n\tdsol: dsol,\n\tDstrok: Dstrok,\n\tdstrok: dstrok,\n\tdtdot: dtdot,\n\tdtri: dtri,\n\tdtrif: dtrif,\n\tduarr: duarr,\n\tduhar: duhar,\n\tdwangle: dwangle,\n\tDZcy: DZcy,\n\tdzcy: dzcy,\n\tdzigrarr: dzigrarr,\n\tEacute: Eacute$1,\n\teacute: eacute$1,\n\teaster: easter,\n\tEcaron: Ecaron,\n\tecaron: ecaron,\n\tEcirc: Ecirc$1,\n\tecirc: ecirc$1,\n\tecir: ecir,\n\tecolon: ecolon,\n\tEcy: Ecy,\n\tecy: ecy,\n\teDDot: eDDot,\n\tEdot: Edot,\n\tedot: edot,\n\teDot: eDot,\n\tee: ee,\n\tefDot: efDot,\n\tEfr: Efr,\n\tefr: efr,\n\teg: eg,\n\tEgrave: Egrave$1,\n\tegrave: egrave$1,\n\tegs: egs,\n\tegsdot: egsdot,\n\tel: el,\n\tElement: Element$1,\n\telinters: elinters,\n\tell: ell,\n\tels: els,\n\telsdot: elsdot,\n\tEmacr: Emacr,\n\temacr: emacr,\n\tempty: empty,\n\temptyset: emptyset,\n\tEmptySmallSquare: EmptySmallSquare,\n\temptyv: emptyv,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare,\n\temsp13: emsp13,\n\temsp14: emsp14,\n\temsp: emsp,\n\tENG: ENG,\n\teng: eng,\n\tensp: ensp,\n\tEogon: Eogon,\n\teogon: eogon,\n\tEopf: Eopf,\n\teopf: eopf,\n\tepar: epar,\n\teparsl: eparsl,\n\teplus: eplus,\n\tepsi: epsi,\n\tEpsilon: Epsilon,\n\tepsilon: epsilon,\n\tepsiv: epsiv,\n\teqcirc: eqcirc,\n\teqcolon: eqcolon,\n\teqsim: eqsim,\n\teqslantgtr: eqslantgtr,\n\teqslantless: eqslantless,\n\tEqual: Equal,\n\tequals: equals,\n\tEqualTilde: EqualTilde,\n\tequest: equest,\n\tEquilibrium: Equilibrium,\n\tequiv: equiv,\n\tequivDD: equivDD,\n\teqvparsl: eqvparsl,\n\terarr: erarr,\n\terDot: erDot,\n\tescr: escr,\n\tEscr: Escr,\n\tesdot: esdot,\n\tEsim: Esim,\n\tesim: esim,\n\tEta: Eta,\n\teta: eta,\n\tETH: ETH$1,\n\teth: eth$1,\n\tEuml: Euml$1,\n\teuml: euml$1,\n\teuro: euro,\n\texcl: excl,\n\texist: exist,\n\tExists: Exists,\n\texpectation: expectation,\n\texponentiale: exponentiale,\n\tExponentialE: ExponentialE,\n\tfallingdotseq: fallingdotseq,\n\tFcy: Fcy,\n\tfcy: fcy,\n\tfemale: female,\n\tffilig: ffilig,\n\tfflig: fflig,\n\tffllig: ffllig,\n\tFfr: Ffr,\n\tffr: ffr,\n\tfilig: filig,\n\tFilledSmallSquare: FilledSmallSquare,\n\tFilledVerySmallSquare: FilledVerySmallSquare,\n\tfjlig: fjlig,\n\tflat: flat,\n\tfllig: fllig,\n\tfltns: fltns,\n\tfnof: fnof,\n\tFopf: Fopf,\n\tfopf: fopf,\n\tforall: forall,\n\tForAll: ForAll,\n\tfork: fork,\n\tforkv: forkv,\n\tFouriertrf: Fouriertrf,\n\tfpartint: fpartint,\n\tfrac12: frac12$1,\n\tfrac13: frac13,\n\tfrac14: frac14$1,\n\tfrac15: frac15,\n\tfrac16: frac16,\n\tfrac18: frac18,\n\tfrac23: frac23,\n\tfrac25: frac25,\n\tfrac34: frac34$1,\n\tfrac35: frac35,\n\tfrac38: frac38,\n\tfrac45: frac45,\n\tfrac56: frac56,\n\tfrac58: frac58,\n\tfrac78: frac78,\n\tfrasl: frasl,\n\tfrown: frown,\n\tfscr: fscr,\n\tFscr: Fscr,\n\tgacute: gacute,\n\tGamma: Gamma,\n\tgamma: gamma,\n\tGammad: Gammad,\n\tgammad: gammad,\n\tgap: gap,\n\tGbreve: Gbreve,\n\tgbreve: gbreve,\n\tGcedil: Gcedil,\n\tGcirc: Gcirc,\n\tgcirc: gcirc,\n\tGcy: Gcy,\n\tgcy: gcy,\n\tGdot: Gdot,\n\tgdot: gdot,\n\tge: ge,\n\tgE: gE,\n\tgEl: gEl,\n\tgel: gel,\n\tgeq: geq,\n\tgeqq: geqq,\n\tgeqslant: geqslant,\n\tgescc: gescc,\n\tges: ges,\n\tgesdot: gesdot,\n\tgesdoto: gesdoto,\n\tgesdotol: gesdotol,\n\tgesl: gesl,\n\tgesles: gesles,\n\tGfr: Gfr,\n\tgfr: gfr,\n\tgg: gg,\n\tGg: Gg,\n\tggg: ggg,\n\tgimel: gimel,\n\tGJcy: GJcy,\n\tgjcy: gjcy,\n\tgla: gla,\n\tgl: gl,\n\tglE: glE,\n\tglj: glj,\n\tgnap: gnap,\n\tgnapprox: gnapprox,\n\tgne: gne,\n\tgnE: gnE,\n\tgneq: gneq,\n\tgneqq: gneqq,\n\tgnsim: gnsim,\n\tGopf: Gopf,\n\tgopf: gopf,\n\tgrave: grave,\n\tGreaterEqual: GreaterEqual,\n\tGreaterEqualLess: GreaterEqualLess,\n\tGreaterFullEqual: GreaterFullEqual,\n\tGreaterGreater: GreaterGreater,\n\tGreaterLess: GreaterLess,\n\tGreaterSlantEqual: GreaterSlantEqual,\n\tGreaterTilde: GreaterTilde,\n\tGscr: Gscr,\n\tgscr: gscr,\n\tgsim: gsim,\n\tgsime: gsime,\n\tgsiml: gsiml,\n\tgtcc: gtcc,\n\tgtcir: gtcir,\n\tgt: gt$2,\n\tGT: GT$1,\n\tGt: Gt,\n\tgtdot: gtdot,\n\tgtlPar: gtlPar,\n\tgtquest: gtquest,\n\tgtrapprox: gtrapprox,\n\tgtrarr: gtrarr,\n\tgtrdot: gtrdot,\n\tgtreqless: gtreqless,\n\tgtreqqless: gtreqqless,\n\tgtrless: gtrless,\n\tgtrsim: gtrsim,\n\tgvertneqq: gvertneqq,\n\tgvnE: gvnE,\n\tHacek: Hacek,\n\thairsp: hairsp,\n\thalf: half,\n\thamilt: hamilt,\n\tHARDcy: HARDcy,\n\thardcy: hardcy,\n\tharrcir: harrcir,\n\tharr: harr,\n\thArr: hArr,\n\tharrw: harrw,\n\tHat: Hat,\n\thbar: hbar,\n\tHcirc: Hcirc,\n\thcirc: hcirc,\n\thearts: hearts,\n\theartsuit: heartsuit,\n\thellip: hellip,\n\thercon: hercon,\n\thfr: hfr,\n\tHfr: Hfr,\n\tHilbertSpace: HilbertSpace,\n\thksearow: hksearow,\n\thkswarow: hkswarow,\n\thoarr: hoarr,\n\thomtht: homtht,\n\thookleftarrow: hookleftarrow,\n\thookrightarrow: hookrightarrow,\n\thopf: hopf,\n\tHopf: Hopf,\n\thorbar: horbar,\n\tHorizontalLine: HorizontalLine,\n\thscr: hscr,\n\tHscr: Hscr,\n\thslash: hslash,\n\tHstrok: Hstrok,\n\thstrok: hstrok,\n\tHumpDownHump: HumpDownHump,\n\tHumpEqual: HumpEqual,\n\thybull: hybull,\n\thyphen: hyphen,\n\tIacute: Iacute$1,\n\tiacute: iacute$1,\n\tic: ic,\n\tIcirc: Icirc$1,\n\ticirc: icirc$1,\n\tIcy: Icy,\n\ticy: icy,\n\tIdot: Idot,\n\tIEcy: IEcy,\n\tiecy: iecy,\n\tiexcl: iexcl$1,\n\tiff: iff,\n\tifr: ifr,\n\tIfr: Ifr,\n\tIgrave: Igrave$1,\n\tigrave: igrave$1,\n\tii: ii,\n\tiiiint: iiiint,\n\tiiint: iiint,\n\tiinfin: iinfin,\n\tiiota: iiota,\n\tIJlig: IJlig,\n\tijlig: ijlig,\n\tImacr: Imacr,\n\timacr: imacr,\n\timage: image,\n\tImaginaryI: ImaginaryI,\n\timagline: imagline,\n\timagpart: imagpart,\n\timath: imath,\n\tIm: Im,\n\timof: imof,\n\timped: imped,\n\tImplies: Implies,\n\tincare: incare,\n\t\"in\": \"∈\",\n\tinfin: infin,\n\tinfintie: infintie,\n\tinodot: inodot,\n\tintcal: intcal,\n\tint: int,\n\tInt: Int,\n\tintegers: integers,\n\tIntegral: Integral,\n\tintercal: intercal,\n\tIntersection: Intersection,\n\tintlarhk: intlarhk,\n\tintprod: intprod,\n\tInvisibleComma: InvisibleComma,\n\tInvisibleTimes: InvisibleTimes,\n\tIOcy: IOcy,\n\tiocy: iocy,\n\tIogon: Iogon,\n\tiogon: iogon,\n\tIopf: Iopf,\n\tiopf: iopf,\n\tIota: Iota,\n\tiota: iota,\n\tiprod: iprod,\n\tiquest: iquest$1,\n\tiscr: iscr,\n\tIscr: Iscr,\n\tisin: isin,\n\tisindot: isindot,\n\tisinE: isinE,\n\tisins: isins,\n\tisinsv: isinsv,\n\tisinv: isinv,\n\tit: it,\n\tItilde: Itilde,\n\titilde: itilde,\n\tIukcy: Iukcy,\n\tiukcy: iukcy,\n\tIuml: Iuml$1,\n\tiuml: iuml$1,\n\tJcirc: Jcirc,\n\tjcirc: jcirc,\n\tJcy: Jcy,\n\tjcy: jcy,\n\tJfr: Jfr,\n\tjfr: jfr,\n\tjmath: jmath,\n\tJopf: Jopf,\n\tjopf: jopf,\n\tJscr: Jscr,\n\tjscr: jscr,\n\tJsercy: Jsercy,\n\tjsercy: jsercy,\n\tJukcy: Jukcy,\n\tjukcy: jukcy,\n\tKappa: Kappa,\n\tkappa: kappa,\n\tkappav: kappav,\n\tKcedil: Kcedil,\n\tkcedil: kcedil,\n\tKcy: Kcy,\n\tkcy: kcy,\n\tKfr: Kfr,\n\tkfr: kfr,\n\tkgreen: kgreen,\n\tKHcy: KHcy,\n\tkhcy: khcy,\n\tKJcy: KJcy,\n\tkjcy: kjcy,\n\tKopf: Kopf,\n\tkopf: kopf,\n\tKscr: Kscr,\n\tkscr: kscr,\n\tlAarr: lAarr,\n\tLacute: Lacute,\n\tlacute: lacute,\n\tlaemptyv: laemptyv,\n\tlagran: lagran,\n\tLambda: Lambda,\n\tlambda: lambda,\n\tlang: lang,\n\tLang: Lang,\n\tlangd: langd,\n\tlangle: langle,\n\tlap: lap,\n\tLaplacetrf: Laplacetrf,\n\tlaquo: laquo$1,\n\tlarrb: larrb,\n\tlarrbfs: larrbfs,\n\tlarr: larr,\n\tLarr: Larr,\n\tlArr: lArr,\n\tlarrfs: larrfs,\n\tlarrhk: larrhk,\n\tlarrlp: larrlp,\n\tlarrpl: larrpl,\n\tlarrsim: larrsim,\n\tlarrtl: larrtl,\n\tlatail: latail,\n\tlAtail: lAtail,\n\tlat: lat,\n\tlate: late,\n\tlates: lates,\n\tlbarr: lbarr,\n\tlBarr: lBarr,\n\tlbbrk: lbbrk,\n\tlbrace: lbrace,\n\tlbrack: lbrack,\n\tlbrke: lbrke,\n\tlbrksld: lbrksld,\n\tlbrkslu: lbrkslu,\n\tLcaron: Lcaron,\n\tlcaron: lcaron,\n\tLcedil: Lcedil,\n\tlcedil: lcedil,\n\tlceil: lceil,\n\tlcub: lcub,\n\tLcy: Lcy,\n\tlcy: lcy,\n\tldca: ldca,\n\tldquo: ldquo,\n\tldquor: ldquor,\n\tldrdhar: ldrdhar,\n\tldrushar: ldrushar,\n\tldsh: ldsh,\n\tle: le,\n\tlE: lE,\n\tLeftAngleBracket: LeftAngleBracket,\n\tLeftArrowBar: LeftArrowBar,\n\tleftarrow: leftarrow,\n\tLeftArrow: LeftArrow,\n\tLeftarrow: Leftarrow,\n\tLeftArrowRightArrow: LeftArrowRightArrow,\n\tleftarrowtail: leftarrowtail,\n\tLeftCeiling: LeftCeiling,\n\tLeftDoubleBracket: LeftDoubleBracket,\n\tLeftDownTeeVector: LeftDownTeeVector,\n\tLeftDownVectorBar: LeftDownVectorBar,\n\tLeftDownVector: LeftDownVector,\n\tLeftFloor: LeftFloor,\n\tleftharpoondown: leftharpoondown,\n\tleftharpoonup: leftharpoonup,\n\tleftleftarrows: leftleftarrows,\n\tleftrightarrow: leftrightarrow,\n\tLeftRightArrow: LeftRightArrow,\n\tLeftrightarrow: Leftrightarrow,\n\tleftrightarrows: leftrightarrows,\n\tleftrightharpoons: leftrightharpoons,\n\tleftrightsquigarrow: leftrightsquigarrow,\n\tLeftRightVector: LeftRightVector,\n\tLeftTeeArrow: LeftTeeArrow,\n\tLeftTee: LeftTee,\n\tLeftTeeVector: LeftTeeVector,\n\tleftthreetimes: leftthreetimes,\n\tLeftTriangleBar: LeftTriangleBar,\n\tLeftTriangle: LeftTriangle,\n\tLeftTriangleEqual: LeftTriangleEqual,\n\tLeftUpDownVector: LeftUpDownVector,\n\tLeftUpTeeVector: LeftUpTeeVector,\n\tLeftUpVectorBar: LeftUpVectorBar,\n\tLeftUpVector: LeftUpVector,\n\tLeftVectorBar: LeftVectorBar,\n\tLeftVector: LeftVector,\n\tlEg: lEg,\n\tleg: leg,\n\tleq: leq,\n\tleqq: leqq,\n\tleqslant: leqslant,\n\tlescc: lescc,\n\tles: les,\n\tlesdot: lesdot,\n\tlesdoto: lesdoto,\n\tlesdotor: lesdotor,\n\tlesg: lesg,\n\tlesges: lesges,\n\tlessapprox: lessapprox,\n\tlessdot: lessdot,\n\tlesseqgtr: lesseqgtr,\n\tlesseqqgtr: lesseqqgtr,\n\tLessEqualGreater: LessEqualGreater,\n\tLessFullEqual: LessFullEqual,\n\tLessGreater: LessGreater,\n\tlessgtr: lessgtr,\n\tLessLess: LessLess,\n\tlesssim: lesssim,\n\tLessSlantEqual: LessSlantEqual,\n\tLessTilde: LessTilde,\n\tlfisht: lfisht,\n\tlfloor: lfloor,\n\tLfr: Lfr,\n\tlfr: lfr,\n\tlg: lg,\n\tlgE: lgE,\n\tlHar: lHar,\n\tlhard: lhard,\n\tlharu: lharu,\n\tlharul: lharul,\n\tlhblk: lhblk,\n\tLJcy: LJcy,\n\tljcy: ljcy,\n\tllarr: llarr,\n\tll: ll,\n\tLl: Ll,\n\tllcorner: llcorner,\n\tLleftarrow: Lleftarrow,\n\tllhard: llhard,\n\tlltri: lltri,\n\tLmidot: Lmidot,\n\tlmidot: lmidot,\n\tlmoustache: lmoustache,\n\tlmoust: lmoust,\n\tlnap: lnap,\n\tlnapprox: lnapprox,\n\tlne: lne,\n\tlnE: lnE,\n\tlneq: lneq,\n\tlneqq: lneqq,\n\tlnsim: lnsim,\n\tloang: loang,\n\tloarr: loarr,\n\tlobrk: lobrk,\n\tlongleftarrow: longleftarrow,\n\tLongLeftArrow: LongLeftArrow,\n\tLongleftarrow: Longleftarrow,\n\tlongleftrightarrow: longleftrightarrow,\n\tLongLeftRightArrow: LongLeftRightArrow,\n\tLongleftrightarrow: Longleftrightarrow,\n\tlongmapsto: longmapsto,\n\tlongrightarrow: longrightarrow,\n\tLongRightArrow: LongRightArrow,\n\tLongrightarrow: Longrightarrow,\n\tlooparrowleft: looparrowleft,\n\tlooparrowright: looparrowright,\n\tlopar: lopar,\n\tLopf: Lopf,\n\tlopf: lopf,\n\tloplus: loplus,\n\tlotimes: lotimes,\n\tlowast: lowast,\n\tlowbar: lowbar,\n\tLowerLeftArrow: LowerLeftArrow,\n\tLowerRightArrow: LowerRightArrow,\n\tloz: loz,\n\tlozenge: lozenge,\n\tlozf: lozf,\n\tlpar: lpar,\n\tlparlt: lparlt,\n\tlrarr: lrarr,\n\tlrcorner: lrcorner,\n\tlrhar: lrhar,\n\tlrhard: lrhard,\n\tlrm: lrm,\n\tlrtri: lrtri,\n\tlsaquo: lsaquo,\n\tlscr: lscr,\n\tLscr: Lscr,\n\tlsh: lsh,\n\tLsh: Lsh,\n\tlsim: lsim,\n\tlsime: lsime,\n\tlsimg: lsimg,\n\tlsqb: lsqb,\n\tlsquo: lsquo,\n\tlsquor: lsquor,\n\tLstrok: Lstrok,\n\tlstrok: lstrok,\n\tltcc: ltcc,\n\tltcir: ltcir,\n\tlt: lt$2,\n\tLT: LT$1,\n\tLt: Lt,\n\tltdot: ltdot,\n\tlthree: lthree,\n\tltimes: ltimes,\n\tltlarr: ltlarr,\n\tltquest: ltquest,\n\tltri: ltri,\n\tltrie: ltrie,\n\tltrif: ltrif,\n\tltrPar: ltrPar,\n\tlurdshar: lurdshar,\n\tluruhar: luruhar,\n\tlvertneqq: lvertneqq,\n\tlvnE: lvnE,\n\tmacr: macr$1,\n\tmale: male,\n\tmalt: malt,\n\tmaltese: maltese,\n\t\"Map\": \"⤅\",\n\tmap: map$1,\n\tmapsto: mapsto,\n\tmapstodown: mapstodown,\n\tmapstoleft: mapstoleft,\n\tmapstoup: mapstoup,\n\tmarker: marker,\n\tmcomma: mcomma,\n\tMcy: Mcy,\n\tmcy: mcy,\n\tmdash: mdash,\n\tmDDot: mDDot,\n\tmeasuredangle: measuredangle,\n\tMediumSpace: MediumSpace,\n\tMellintrf: Mellintrf,\n\tMfr: Mfr,\n\tmfr: mfr,\n\tmho: mho,\n\tmicro: micro$1,\n\tmidast: midast,\n\tmidcir: midcir,\n\tmid: mid,\n\tmiddot: middot$1,\n\tminusb: minusb,\n\tminus: minus,\n\tminusd: minusd,\n\tminusdu: minusdu,\n\tMinusPlus: MinusPlus,\n\tmlcp: mlcp,\n\tmldr: mldr,\n\tmnplus: mnplus,\n\tmodels: models,\n\tMopf: Mopf,\n\tmopf: mopf,\n\tmp: mp,\n\tmscr: mscr,\n\tMscr: Mscr,\n\tmstpos: mstpos,\n\tMu: Mu,\n\tmu: mu,\n\tmultimap: multimap,\n\tmumap: mumap,\n\tnabla: nabla,\n\tNacute: Nacute,\n\tnacute: nacute,\n\tnang: nang,\n\tnap: nap,\n\tnapE: napE,\n\tnapid: napid,\n\tnapos: napos,\n\tnapprox: napprox,\n\tnatural: natural,\n\tnaturals: naturals,\n\tnatur: natur,\n\tnbsp: nbsp$1,\n\tnbump: nbump,\n\tnbumpe: nbumpe,\n\tncap: ncap,\n\tNcaron: Ncaron,\n\tncaron: ncaron,\n\tNcedil: Ncedil,\n\tncedil: ncedil,\n\tncong: ncong,\n\tncongdot: ncongdot,\n\tncup: ncup,\n\tNcy: Ncy,\n\tncy: ncy,\n\tndash: ndash,\n\tnearhk: nearhk,\n\tnearr: nearr,\n\tneArr: neArr,\n\tnearrow: nearrow,\n\tne: ne,\n\tnedot: nedot,\n\tNegativeMediumSpace: NegativeMediumSpace,\n\tNegativeThickSpace: NegativeThickSpace,\n\tNegativeThinSpace: NegativeThinSpace,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace,\n\tnequiv: nequiv,\n\tnesear: nesear,\n\tnesim: nesim,\n\tNestedGreaterGreater: NestedGreaterGreater,\n\tNestedLessLess: NestedLessLess,\n\tNewLine: NewLine,\n\tnexist: nexist,\n\tnexists: nexists,\n\tNfr: Nfr,\n\tnfr: nfr,\n\tngE: ngE,\n\tnge: nge,\n\tngeq: ngeq,\n\tngeqq: ngeqq,\n\tngeqslant: ngeqslant,\n\tnges: nges,\n\tnGg: nGg,\n\tngsim: ngsim,\n\tnGt: nGt,\n\tngt: ngt,\n\tngtr: ngtr,\n\tnGtv: nGtv,\n\tnharr: nharr,\n\tnhArr: nhArr,\n\tnhpar: nhpar,\n\tni: ni,\n\tnis: nis,\n\tnisd: nisd,\n\tniv: niv,\n\tNJcy: NJcy,\n\tnjcy: njcy,\n\tnlarr: nlarr,\n\tnlArr: nlArr,\n\tnldr: nldr,\n\tnlE: nlE,\n\tnle: nle,\n\tnleftarrow: nleftarrow,\n\tnLeftarrow: nLeftarrow,\n\tnleftrightarrow: nleftrightarrow,\n\tnLeftrightarrow: nLeftrightarrow,\n\tnleq: nleq,\n\tnleqq: nleqq,\n\tnleqslant: nleqslant,\n\tnles: nles,\n\tnless: nless,\n\tnLl: nLl,\n\tnlsim: nlsim,\n\tnLt: nLt,\n\tnlt: nlt,\n\tnltri: nltri,\n\tnltrie: nltrie,\n\tnLtv: nLtv,\n\tnmid: nmid,\n\tNoBreak: NoBreak,\n\tNonBreakingSpace: NonBreakingSpace,\n\tnopf: nopf,\n\tNopf: Nopf,\n\tNot: Not,\n\tnot: not$1,\n\tNotCongruent: NotCongruent,\n\tNotCupCap: NotCupCap,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar,\n\tNotElement: NotElement,\n\tNotEqual: NotEqual,\n\tNotEqualTilde: NotEqualTilde,\n\tNotExists: NotExists,\n\tNotGreater: NotGreater,\n\tNotGreaterEqual: NotGreaterEqual,\n\tNotGreaterFullEqual: NotGreaterFullEqual,\n\tNotGreaterGreater: NotGreaterGreater,\n\tNotGreaterLess: NotGreaterLess,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual,\n\tNotGreaterTilde: NotGreaterTilde,\n\tNotHumpDownHump: NotHumpDownHump,\n\tNotHumpEqual: NotHumpEqual,\n\tnotin: notin,\n\tnotindot: notindot,\n\tnotinE: notinE,\n\tnotinva: notinva,\n\tnotinvb: notinvb,\n\tnotinvc: notinvc,\n\tNotLeftTriangleBar: NotLeftTriangleBar,\n\tNotLeftTriangle: NotLeftTriangle,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual,\n\tNotLess: NotLess,\n\tNotLessEqual: NotLessEqual,\n\tNotLessGreater: NotLessGreater,\n\tNotLessLess: NotLessLess,\n\tNotLessSlantEqual: NotLessSlantEqual,\n\tNotLessTilde: NotLessTilde,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater,\n\tNotNestedLessLess: NotNestedLessLess,\n\tnotni: notni,\n\tnotniva: notniva,\n\tnotnivb: notnivb,\n\tnotnivc: notnivc,\n\tNotPrecedes: NotPrecedes,\n\tNotPrecedesEqual: NotPrecedesEqual,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual,\n\tNotReverseElement: NotReverseElement,\n\tNotRightTriangleBar: NotRightTriangleBar,\n\tNotRightTriangle: NotRightTriangle,\n\tNotRightTriangleEqual: NotRightTriangleEqual,\n\tNotSquareSubset: NotSquareSubset,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual,\n\tNotSquareSuperset: NotSquareSuperset,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual,\n\tNotSubset: NotSubset,\n\tNotSubsetEqual: NotSubsetEqual,\n\tNotSucceeds: NotSucceeds,\n\tNotSucceedsEqual: NotSucceedsEqual,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual,\n\tNotSucceedsTilde: NotSucceedsTilde,\n\tNotSuperset: NotSuperset,\n\tNotSupersetEqual: NotSupersetEqual,\n\tNotTilde: NotTilde,\n\tNotTildeEqual: NotTildeEqual,\n\tNotTildeFullEqual: NotTildeFullEqual,\n\tNotTildeTilde: NotTildeTilde,\n\tNotVerticalBar: NotVerticalBar,\n\tnparallel: nparallel,\n\tnpar: npar,\n\tnparsl: nparsl,\n\tnpart: npart,\n\tnpolint: npolint,\n\tnpr: npr,\n\tnprcue: nprcue,\n\tnprec: nprec,\n\tnpreceq: npreceq,\n\tnpre: npre,\n\tnrarrc: nrarrc,\n\tnrarr: nrarr,\n\tnrArr: nrArr,\n\tnrarrw: nrarrw,\n\tnrightarrow: nrightarrow,\n\tnRightarrow: nRightarrow,\n\tnrtri: nrtri,\n\tnrtrie: nrtrie,\n\tnsc: nsc,\n\tnsccue: nsccue,\n\tnsce: nsce,\n\tNscr: Nscr,\n\tnscr: nscr,\n\tnshortmid: nshortmid,\n\tnshortparallel: nshortparallel,\n\tnsim: nsim,\n\tnsime: nsime,\n\tnsimeq: nsimeq,\n\tnsmid: nsmid,\n\tnspar: nspar,\n\tnsqsube: nsqsube,\n\tnsqsupe: nsqsupe,\n\tnsub: nsub,\n\tnsubE: nsubE,\n\tnsube: nsube,\n\tnsubset: nsubset,\n\tnsubseteq: nsubseteq,\n\tnsubseteqq: nsubseteqq,\n\tnsucc: nsucc,\n\tnsucceq: nsucceq,\n\tnsup: nsup,\n\tnsupE: nsupE,\n\tnsupe: nsupe,\n\tnsupset: nsupset,\n\tnsupseteq: nsupseteq,\n\tnsupseteqq: nsupseteqq,\n\tntgl: ntgl,\n\tNtilde: Ntilde$1,\n\tntilde: ntilde$1,\n\tntlg: ntlg,\n\tntriangleleft: ntriangleleft,\n\tntrianglelefteq: ntrianglelefteq,\n\tntriangleright: ntriangleright,\n\tntrianglerighteq: ntrianglerighteq,\n\tNu: Nu,\n\tnu: nu,\n\tnum: num,\n\tnumero: numero,\n\tnumsp: numsp,\n\tnvap: nvap,\n\tnvdash: nvdash,\n\tnvDash: nvDash,\n\tnVdash: nVdash,\n\tnVDash: nVDash,\n\tnvge: nvge,\n\tnvgt: nvgt,\n\tnvHarr: nvHarr,\n\tnvinfin: nvinfin,\n\tnvlArr: nvlArr,\n\tnvle: nvle,\n\tnvlt: nvlt,\n\tnvltrie: nvltrie,\n\tnvrArr: nvrArr,\n\tnvrtrie: nvrtrie,\n\tnvsim: nvsim,\n\tnwarhk: nwarhk,\n\tnwarr: nwarr,\n\tnwArr: nwArr,\n\tnwarrow: nwarrow,\n\tnwnear: nwnear,\n\tOacute: Oacute$1,\n\toacute: oacute$1,\n\toast: oast,\n\tOcirc: Ocirc$1,\n\tocirc: ocirc$1,\n\tocir: ocir,\n\tOcy: Ocy,\n\tocy: ocy,\n\todash: odash,\n\tOdblac: Odblac,\n\todblac: odblac,\n\todiv: odiv,\n\todot: odot,\n\todsold: odsold,\n\tOElig: OElig,\n\toelig: oelig,\n\tofcir: ofcir,\n\tOfr: Ofr,\n\tofr: ofr,\n\togon: ogon,\n\tOgrave: Ograve$1,\n\tograve: ograve$1,\n\togt: ogt,\n\tohbar: ohbar,\n\tohm: ohm,\n\toint: oint,\n\tolarr: olarr,\n\tolcir: olcir,\n\tolcross: olcross,\n\toline: oline,\n\tolt: olt,\n\tOmacr: Omacr,\n\tomacr: omacr,\n\tOmega: Omega,\n\tomega: omega,\n\tOmicron: Omicron,\n\tomicron: omicron,\n\tomid: omid,\n\tominus: ominus,\n\tOopf: Oopf,\n\toopf: oopf,\n\topar: opar,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n\tOpenCurlyQuote: OpenCurlyQuote,\n\toperp: operp,\n\toplus: oplus,\n\torarr: orarr,\n\tOr: Or,\n\tor: or,\n\tord: ord,\n\torder: order,\n\torderof: orderof,\n\tordf: ordf$1,\n\tordm: ordm$1,\n\torigof: origof,\n\toror: oror,\n\torslope: orslope,\n\torv: orv,\n\toS: oS,\n\tOscr: Oscr,\n\toscr: oscr,\n\tOslash: Oslash$1,\n\toslash: oslash$1,\n\tosol: osol,\n\tOtilde: Otilde$1,\n\totilde: otilde$1,\n\totimesas: otimesas,\n\tOtimes: Otimes,\n\totimes: otimes,\n\tOuml: Ouml$1,\n\touml: ouml$1,\n\tovbar: ovbar,\n\tOverBar: OverBar,\n\tOverBrace: OverBrace,\n\tOverBracket: OverBracket,\n\tOverParenthesis: OverParenthesis,\n\tpara: para$1,\n\tparallel: parallel,\n\tpar: par,\n\tparsim: parsim,\n\tparsl: parsl,\n\tpart: part,\n\tPartialD: PartialD,\n\tPcy: Pcy,\n\tpcy: pcy,\n\tpercnt: percnt,\n\tperiod: period,\n\tpermil: permil,\n\tperp: perp,\n\tpertenk: pertenk,\n\tPfr: Pfr,\n\tpfr: pfr,\n\tPhi: Phi,\n\tphi: phi,\n\tphiv: phiv,\n\tphmmat: phmmat,\n\tphone: phone,\n\tPi: Pi,\n\tpi: pi,\n\tpitchfork: pitchfork,\n\tpiv: piv,\n\tplanck: planck,\n\tplanckh: planckh,\n\tplankv: plankv,\n\tplusacir: plusacir,\n\tplusb: plusb,\n\tpluscir: pluscir,\n\tplus: plus,\n\tplusdo: plusdo,\n\tplusdu: plusdu,\n\tpluse: pluse,\n\tPlusMinus: PlusMinus,\n\tplusmn: plusmn$1,\n\tplussim: plussim,\n\tplustwo: plustwo,\n\tpm: pm,\n\tPoincareplane: Poincareplane,\n\tpointint: pointint,\n\tpopf: popf,\n\tPopf: Popf,\n\tpound: pound$1,\n\tprap: prap,\n\tPr: Pr,\n\tpr: pr,\n\tprcue: prcue,\n\tprecapprox: precapprox,\n\tprec: prec,\n\tpreccurlyeq: preccurlyeq,\n\tPrecedes: Precedes,\n\tPrecedesEqual: PrecedesEqual,\n\tPrecedesSlantEqual: PrecedesSlantEqual,\n\tPrecedesTilde: PrecedesTilde,\n\tpreceq: preceq,\n\tprecnapprox: precnapprox,\n\tprecneqq: precneqq,\n\tprecnsim: precnsim,\n\tpre: pre,\n\tprE: prE,\n\tprecsim: precsim,\n\tprime: prime,\n\tPrime: Prime,\n\tprimes: primes,\n\tprnap: prnap,\n\tprnE: prnE,\n\tprnsim: prnsim,\n\tprod: prod,\n\tProduct: Product,\n\tprofalar: profalar,\n\tprofline: profline,\n\tprofsurf: profsurf,\n\tprop: prop,\n\tProportional: Proportional,\n\tProportion: Proportion,\n\tpropto: propto,\n\tprsim: prsim,\n\tprurel: prurel,\n\tPscr: Pscr,\n\tpscr: pscr,\n\tPsi: Psi,\n\tpsi: psi,\n\tpuncsp: puncsp,\n\tQfr: Qfr,\n\tqfr: qfr,\n\tqint: qint,\n\tqopf: qopf,\n\tQopf: Qopf,\n\tqprime: qprime,\n\tQscr: Qscr,\n\tqscr: qscr,\n\tquaternions: quaternions,\n\tquatint: quatint,\n\tquest: quest,\n\tquesteq: questeq,\n\tquot: quot$2,\n\tQUOT: QUOT$1,\n\trAarr: rAarr,\n\trace: race,\n\tRacute: Racute,\n\tracute: racute,\n\tradic: radic,\n\traemptyv: raemptyv,\n\trang: rang,\n\tRang: Rang,\n\trangd: rangd,\n\trange: range,\n\trangle: rangle,\n\traquo: raquo$1,\n\trarrap: rarrap,\n\trarrb: rarrb,\n\trarrbfs: rarrbfs,\n\trarrc: rarrc,\n\trarr: rarr,\n\tRarr: Rarr,\n\trArr: rArr,\n\trarrfs: rarrfs,\n\trarrhk: rarrhk,\n\trarrlp: rarrlp,\n\trarrpl: rarrpl,\n\trarrsim: rarrsim,\n\tRarrtl: Rarrtl,\n\trarrtl: rarrtl,\n\trarrw: rarrw,\n\tratail: ratail,\n\trAtail: rAtail,\n\tratio: ratio,\n\trationals: rationals,\n\trbarr: rbarr,\n\trBarr: rBarr,\n\tRBarr: RBarr,\n\trbbrk: rbbrk,\n\trbrace: rbrace,\n\trbrack: rbrack,\n\trbrke: rbrke,\n\trbrksld: rbrksld,\n\trbrkslu: rbrkslu,\n\tRcaron: Rcaron,\n\trcaron: rcaron,\n\tRcedil: Rcedil,\n\trcedil: rcedil,\n\trceil: rceil,\n\trcub: rcub,\n\tRcy: Rcy,\n\trcy: rcy,\n\trdca: rdca,\n\trdldhar: rdldhar,\n\trdquo: rdquo,\n\trdquor: rdquor,\n\trdsh: rdsh,\n\treal: real,\n\trealine: realine,\n\trealpart: realpart,\n\treals: reals,\n\tRe: Re,\n\trect: rect,\n\treg: reg$1,\n\tREG: REG$1,\n\tReverseElement: ReverseElement,\n\tReverseEquilibrium: ReverseEquilibrium,\n\tReverseUpEquilibrium: ReverseUpEquilibrium,\n\trfisht: rfisht,\n\trfloor: rfloor,\n\trfr: rfr,\n\tRfr: Rfr,\n\trHar: rHar,\n\trhard: rhard,\n\trharu: rharu,\n\trharul: rharul,\n\tRho: Rho,\n\trho: rho,\n\trhov: rhov,\n\tRightAngleBracket: RightAngleBracket,\n\tRightArrowBar: RightArrowBar,\n\trightarrow: rightarrow,\n\tRightArrow: RightArrow,\n\tRightarrow: Rightarrow,\n\tRightArrowLeftArrow: RightArrowLeftArrow,\n\trightarrowtail: rightarrowtail,\n\tRightCeiling: RightCeiling,\n\tRightDoubleBracket: RightDoubleBracket,\n\tRightDownTeeVector: RightDownTeeVector,\n\tRightDownVectorBar: RightDownVectorBar,\n\tRightDownVector: RightDownVector,\n\tRightFloor: RightFloor,\n\trightharpoondown: rightharpoondown,\n\trightharpoonup: rightharpoonup,\n\trightleftarrows: rightleftarrows,\n\trightleftharpoons: rightleftharpoons,\n\trightrightarrows: rightrightarrows,\n\trightsquigarrow: rightsquigarrow,\n\tRightTeeArrow: RightTeeArrow,\n\tRightTee: RightTee,\n\tRightTeeVector: RightTeeVector,\n\trightthreetimes: rightthreetimes,\n\tRightTriangleBar: RightTriangleBar,\n\tRightTriangle: RightTriangle,\n\tRightTriangleEqual: RightTriangleEqual,\n\tRightUpDownVector: RightUpDownVector,\n\tRightUpTeeVector: RightUpTeeVector,\n\tRightUpVectorBar: RightUpVectorBar,\n\tRightUpVector: RightUpVector,\n\tRightVectorBar: RightVectorBar,\n\tRightVector: RightVector,\n\tring: ring,\n\trisingdotseq: risingdotseq,\n\trlarr: rlarr,\n\trlhar: rlhar,\n\trlm: rlm,\n\trmoustache: rmoustache,\n\trmoust: rmoust,\n\trnmid: rnmid,\n\troang: roang,\n\troarr: roarr,\n\trobrk: robrk,\n\tropar: ropar,\n\tropf: ropf,\n\tRopf: Ropf,\n\troplus: roplus,\n\trotimes: rotimes,\n\tRoundImplies: RoundImplies,\n\trpar: rpar,\n\trpargt: rpargt,\n\trppolint: rppolint,\n\trrarr: rrarr,\n\tRrightarrow: Rrightarrow,\n\trsaquo: rsaquo,\n\trscr: rscr,\n\tRscr: Rscr,\n\trsh: rsh,\n\tRsh: Rsh,\n\trsqb: rsqb,\n\trsquo: rsquo,\n\trsquor: rsquor,\n\trthree: rthree,\n\trtimes: rtimes,\n\trtri: rtri,\n\trtrie: rtrie,\n\trtrif: rtrif,\n\trtriltri: rtriltri,\n\tRuleDelayed: RuleDelayed,\n\truluhar: ruluhar,\n\trx: rx$1,\n\tSacute: Sacute,\n\tsacute: sacute,\n\tsbquo: sbquo,\n\tscap: scap,\n\tScaron: Scaron,\n\tscaron: scaron,\n\tSc: Sc,\n\tsc: sc,\n\tsccue: sccue,\n\tsce: sce,\n\tscE: scE,\n\tScedil: Scedil,\n\tscedil: scedil,\n\tScirc: Scirc,\n\tscirc: scirc,\n\tscnap: scnap,\n\tscnE: scnE,\n\tscnsim: scnsim,\n\tscpolint: scpolint,\n\tscsim: scsim,\n\tScy: Scy,\n\tscy: scy,\n\tsdotb: sdotb,\n\tsdot: sdot,\n\tsdote: sdote,\n\tsearhk: searhk,\n\tsearr: searr,\n\tseArr: seArr,\n\tsearrow: searrow,\n\tsect: sect$1,\n\tsemi: semi,\n\tseswar: seswar,\n\tsetminus: setminus,\n\tsetmn: setmn,\n\tsext: sext,\n\tSfr: Sfr,\n\tsfr: sfr,\n\tsfrown: sfrown,\n\tsharp: sharp,\n\tSHCHcy: SHCHcy,\n\tshchcy: shchcy,\n\tSHcy: SHcy,\n\tshcy: shcy,\n\tShortDownArrow: ShortDownArrow,\n\tShortLeftArrow: ShortLeftArrow,\n\tshortmid: shortmid,\n\tshortparallel: shortparallel,\n\tShortRightArrow: ShortRightArrow,\n\tShortUpArrow: ShortUpArrow,\n\tshy: shy$1,\n\tSigma: Sigma,\n\tsigma: sigma,\n\tsigmaf: sigmaf,\n\tsigmav: sigmav,\n\tsim: sim,\n\tsimdot: simdot,\n\tsime: sime,\n\tsimeq: simeq,\n\tsimg: simg,\n\tsimgE: simgE,\n\tsiml: siml,\n\tsimlE: simlE,\n\tsimne: simne,\n\tsimplus: simplus,\n\tsimrarr: simrarr,\n\tslarr: slarr,\n\tSmallCircle: SmallCircle,\n\tsmallsetminus: smallsetminus,\n\tsmashp: smashp,\n\tsmeparsl: smeparsl,\n\tsmid: smid,\n\tsmile: smile,\n\tsmt: smt,\n\tsmte: smte,\n\tsmtes: smtes,\n\tSOFTcy: SOFTcy,\n\tsoftcy: softcy,\n\tsolbar: solbar,\n\tsolb: solb,\n\tsol: sol,\n\tSopf: Sopf,\n\tsopf: sopf,\n\tspades: spades,\n\tspadesuit: spadesuit,\n\tspar: spar,\n\tsqcap: sqcap,\n\tsqcaps: sqcaps,\n\tsqcup: sqcup,\n\tsqcups: sqcups,\n\tSqrt: Sqrt,\n\tsqsub: sqsub,\n\tsqsube: sqsube,\n\tsqsubset: sqsubset,\n\tsqsubseteq: sqsubseteq,\n\tsqsup: sqsup,\n\tsqsupe: sqsupe,\n\tsqsupset: sqsupset,\n\tsqsupseteq: sqsupseteq,\n\tsquare: square,\n\tSquare: Square,\n\tSquareIntersection: SquareIntersection,\n\tSquareSubset: SquareSubset,\n\tSquareSubsetEqual: SquareSubsetEqual,\n\tSquareSuperset: SquareSuperset,\n\tSquareSupersetEqual: SquareSupersetEqual,\n\tSquareUnion: SquareUnion,\n\tsquarf: squarf,\n\tsqu: squ,\n\tsquf: squf,\n\tsrarr: srarr,\n\tSscr: Sscr,\n\tsscr: sscr,\n\tssetmn: ssetmn,\n\tssmile: ssmile,\n\tsstarf: sstarf,\n\tStar: Star,\n\tstar: star,\n\tstarf: starf,\n\tstraightepsilon: straightepsilon,\n\tstraightphi: straightphi,\n\tstrns: strns,\n\tsub: sub,\n\tSub: Sub,\n\tsubdot: subdot,\n\tsubE: subE,\n\tsube: sube,\n\tsubedot: subedot,\n\tsubmult: submult,\n\tsubnE: subnE,\n\tsubne: subne,\n\tsubplus: subplus,\n\tsubrarr: subrarr,\n\tsubset: subset,\n\tSubset: Subset,\n\tsubseteq: subseteq,\n\tsubseteqq: subseteqq,\n\tSubsetEqual: SubsetEqual,\n\tsubsetneq: subsetneq,\n\tsubsetneqq: subsetneqq,\n\tsubsim: subsim,\n\tsubsub: subsub,\n\tsubsup: subsup,\n\tsuccapprox: succapprox,\n\tsucc: succ,\n\tsucccurlyeq: succcurlyeq,\n\tSucceeds: Succeeds,\n\tSucceedsEqual: SucceedsEqual,\n\tSucceedsSlantEqual: SucceedsSlantEqual,\n\tSucceedsTilde: SucceedsTilde,\n\tsucceq: succeq,\n\tsuccnapprox: succnapprox,\n\tsuccneqq: succneqq,\n\tsuccnsim: succnsim,\n\tsuccsim: succsim,\n\tSuchThat: SuchThat,\n\tsum: sum,\n\tSum: Sum,\n\tsung: sung,\n\tsup1: sup1$1,\n\tsup2: sup2$1,\n\tsup3: sup3$1,\n\tsup: sup,\n\tSup: Sup,\n\tsupdot: supdot,\n\tsupdsub: supdsub,\n\tsupE: supE,\n\tsupe: supe,\n\tsupedot: supedot,\n\tSuperset: Superset,\n\tSupersetEqual: SupersetEqual,\n\tsuphsol: suphsol,\n\tsuphsub: suphsub,\n\tsuplarr: suplarr,\n\tsupmult: supmult,\n\tsupnE: supnE,\n\tsupne: supne,\n\tsupplus: supplus,\n\tsupset: supset,\n\tSupset: Supset,\n\tsupseteq: supseteq,\n\tsupseteqq: supseteqq,\n\tsupsetneq: supsetneq,\n\tsupsetneqq: supsetneqq,\n\tsupsim: supsim,\n\tsupsub: supsub,\n\tsupsup: supsup,\n\tswarhk: swarhk,\n\tswarr: swarr,\n\tswArr: swArr,\n\tswarrow: swarrow,\n\tswnwar: swnwar,\n\tszlig: szlig$1,\n\tTab: Tab,\n\ttarget: target$1,\n\tTau: Tau,\n\ttau: tau,\n\ttbrk: tbrk,\n\tTcaron: Tcaron,\n\ttcaron: tcaron,\n\tTcedil: Tcedil,\n\ttcedil: tcedil,\n\tTcy: Tcy,\n\ttcy: tcy,\n\ttdot: tdot,\n\ttelrec: telrec,\n\tTfr: Tfr,\n\ttfr: tfr,\n\tthere4: there4,\n\ttherefore: therefore,\n\tTherefore: Therefore,\n\tTheta: Theta,\n\ttheta: theta,\n\tthetasym: thetasym,\n\tthetav: thetav,\n\tthickapprox: thickapprox,\n\tthicksim: thicksim,\n\tThickSpace: ThickSpace,\n\tThinSpace: ThinSpace,\n\tthinsp: thinsp,\n\tthkap: thkap,\n\tthksim: thksim,\n\tTHORN: THORN$1,\n\tthorn: thorn$1,\n\ttilde: tilde,\n\tTilde: Tilde,\n\tTildeEqual: TildeEqual,\n\tTildeFullEqual: TildeFullEqual,\n\tTildeTilde: TildeTilde,\n\ttimesbar: timesbar,\n\ttimesb: timesb,\n\ttimes: times$1,\n\ttimesd: timesd,\n\ttint: tint,\n\ttoea: toea,\n\ttopbot: topbot,\n\ttopcir: topcir,\n\ttop: top,\n\tTopf: Topf,\n\ttopf: topf,\n\ttopfork: topfork,\n\ttosa: tosa,\n\ttprime: tprime,\n\ttrade: trade,\n\tTRADE: TRADE,\n\ttriangle: triangle,\n\ttriangledown: triangledown,\n\ttriangleleft: triangleleft,\n\ttrianglelefteq: trianglelefteq,\n\ttriangleq: triangleq,\n\ttriangleright: triangleright,\n\ttrianglerighteq: trianglerighteq,\n\ttridot: tridot,\n\ttrie: trie,\n\ttriminus: triminus,\n\tTripleDot: TripleDot,\n\ttriplus: triplus,\n\ttrisb: trisb,\n\ttritime: tritime,\n\ttrpezium: trpezium,\n\tTscr: Tscr,\n\ttscr: tscr,\n\tTScy: TScy,\n\ttscy: tscy,\n\tTSHcy: TSHcy,\n\ttshcy: tshcy,\n\tTstrok: Tstrok,\n\ttstrok: tstrok,\n\ttwixt: twixt,\n\ttwoheadleftarrow: twoheadleftarrow,\n\ttwoheadrightarrow: twoheadrightarrow,\n\tUacute: Uacute$1,\n\tuacute: uacute$1,\n\tuarr: uarr,\n\tUarr: Uarr,\n\tuArr: uArr,\n\tUarrocir: Uarrocir,\n\tUbrcy: Ubrcy,\n\tubrcy: ubrcy,\n\tUbreve: Ubreve,\n\tubreve: ubreve,\n\tUcirc: Ucirc$1,\n\tucirc: ucirc$1,\n\tUcy: Ucy,\n\tucy: ucy,\n\tudarr: udarr,\n\tUdblac: Udblac,\n\tudblac: udblac,\n\tudhar: udhar,\n\tufisht: ufisht,\n\tUfr: Ufr,\n\tufr: ufr,\n\tUgrave: Ugrave$1,\n\tugrave: ugrave$1,\n\tuHar: uHar,\n\tuharl: uharl,\n\tuharr: uharr,\n\tuhblk: uhblk,\n\tulcorn: ulcorn,\n\tulcorner: ulcorner,\n\tulcrop: ulcrop,\n\tultri: ultri,\n\tUmacr: Umacr,\n\tumacr: umacr,\n\tuml: uml$1,\n\tUnderBar: UnderBar,\n\tUnderBrace: UnderBrace,\n\tUnderBracket: UnderBracket,\n\tUnderParenthesis: UnderParenthesis,\n\tUnion: Union,\n\tUnionPlus: UnionPlus,\n\tUogon: Uogon,\n\tuogon: uogon,\n\tUopf: Uopf,\n\tuopf: uopf,\n\tUpArrowBar: UpArrowBar,\n\tuparrow: uparrow,\n\tUpArrow: UpArrow,\n\tUparrow: Uparrow,\n\tUpArrowDownArrow: UpArrowDownArrow,\n\tupdownarrow: updownarrow,\n\tUpDownArrow: UpDownArrow,\n\tUpdownarrow: Updownarrow,\n\tUpEquilibrium: UpEquilibrium,\n\tupharpoonleft: upharpoonleft,\n\tupharpoonright: upharpoonright,\n\tuplus: uplus,\n\tUpperLeftArrow: UpperLeftArrow,\n\tUpperRightArrow: UpperRightArrow,\n\tupsi: upsi,\n\tUpsi: Upsi,\n\tupsih: upsih,\n\tUpsilon: Upsilon,\n\tupsilon: upsilon,\n\tUpTeeArrow: UpTeeArrow,\n\tUpTee: UpTee,\n\tupuparrows: upuparrows,\n\turcorn: urcorn,\n\turcorner: urcorner,\n\turcrop: urcrop,\n\tUring: Uring,\n\turing: uring,\n\turtri: urtri,\n\tUscr: Uscr,\n\tuscr: uscr,\n\tutdot: utdot,\n\tUtilde: Utilde,\n\tutilde: utilde,\n\tutri: utri,\n\tutrif: utrif,\n\tuuarr: uuarr,\n\tUuml: Uuml$1,\n\tuuml: uuml$1,\n\tuwangle: uwangle,\n\tvangrt: vangrt,\n\tvarepsilon: varepsilon,\n\tvarkappa: varkappa,\n\tvarnothing: varnothing,\n\tvarphi: varphi,\n\tvarpi: varpi,\n\tvarpropto: varpropto,\n\tvarr: varr,\n\tvArr: vArr,\n\tvarrho: varrho,\n\tvarsigma: varsigma,\n\tvarsubsetneq: varsubsetneq,\n\tvarsubsetneqq: varsubsetneqq,\n\tvarsupsetneq: varsupsetneq,\n\tvarsupsetneqq: varsupsetneqq,\n\tvartheta: vartheta,\n\tvartriangleleft: vartriangleleft,\n\tvartriangleright: vartriangleright,\n\tvBar: vBar,\n\tVbar: Vbar,\n\tvBarv: vBarv,\n\tVcy: Vcy,\n\tvcy: vcy,\n\tvdash: vdash,\n\tvDash: vDash,\n\tVdash: Vdash,\n\tVDash: VDash,\n\tVdashl: Vdashl,\n\tveebar: veebar,\n\tvee: vee,\n\tVee: Vee,\n\tveeeq: veeeq,\n\tvellip: vellip,\n\tverbar: verbar,\n\tVerbar: Verbar,\n\tvert: vert,\n\tVert: Vert,\n\tVerticalBar: VerticalBar,\n\tVerticalLine: VerticalLine,\n\tVerticalSeparator: VerticalSeparator,\n\tVerticalTilde: VerticalTilde,\n\tVeryThinSpace: VeryThinSpace,\n\tVfr: Vfr,\n\tvfr: vfr,\n\tvltri: vltri,\n\tvnsub: vnsub,\n\tvnsup: vnsup,\n\tVopf: Vopf,\n\tvopf: vopf,\n\tvprop: vprop,\n\tvrtri: vrtri,\n\tVscr: Vscr,\n\tvscr: vscr,\n\tvsubnE: vsubnE,\n\tvsubne: vsubne,\n\tvsupnE: vsupnE,\n\tvsupne: vsupne,\n\tVvdash: Vvdash,\n\tvzigzag: vzigzag,\n\tWcirc: Wcirc,\n\twcirc: wcirc,\n\twedbar: wedbar,\n\twedge: wedge,\n\tWedge: Wedge,\n\twedgeq: wedgeq,\n\tweierp: weierp,\n\tWfr: Wfr,\n\twfr: wfr,\n\tWopf: Wopf,\n\twopf: wopf,\n\twp: wp,\n\twr: wr,\n\twreath: wreath,\n\tWscr: Wscr,\n\twscr: wscr,\n\txcap: xcap,\n\txcirc: xcirc,\n\txcup: xcup,\n\txdtri: xdtri,\n\tXfr: Xfr,\n\txfr: xfr,\n\txharr: xharr,\n\txhArr: xhArr,\n\tXi: Xi,\n\txi: xi,\n\txlarr: xlarr,\n\txlArr: xlArr,\n\txmap: xmap,\n\txnis: xnis,\n\txodot: xodot,\n\tXopf: Xopf,\n\txopf: xopf,\n\txoplus: xoplus,\n\txotime: xotime,\n\txrarr: xrarr,\n\txrArr: xrArr,\n\tXscr: Xscr,\n\txscr: xscr,\n\txsqcup: xsqcup,\n\txuplus: xuplus,\n\txutri: xutri,\n\txvee: xvee,\n\txwedge: xwedge,\n\tYacute: Yacute$1,\n\tyacute: yacute$1,\n\tYAcy: YAcy,\n\tyacy: yacy,\n\tYcirc: Ycirc,\n\tycirc: ycirc,\n\tYcy: Ycy,\n\tycy: ycy,\n\tyen: yen$1,\n\tYfr: Yfr,\n\tyfr: yfr,\n\tYIcy: YIcy,\n\tyicy: yicy,\n\tYopf: Yopf,\n\tyopf: yopf,\n\tYscr: Yscr,\n\tyscr: yscr,\n\tYUcy: YUcy,\n\tyucy: yucy,\n\tyuml: yuml$1,\n\tYuml: Yuml,\n\tZacute: Zacute,\n\tzacute: zacute,\n\tZcaron: Zcaron,\n\tzcaron: zcaron,\n\tZcy: Zcy,\n\tzcy: zcy,\n\tZdot: Zdot,\n\tzdot: zdot,\n\tzeetrf: zeetrf,\n\tZeroWidthSpace: ZeroWidthSpace,\n\tZeta: Zeta,\n\tzeta: zeta,\n\tzfr: zfr,\n\tZfr: Zfr,\n\tZHcy: ZHcy,\n\tzhcy: zhcy,\n\tzigrarr: zigrarr,\n\tzopf: zopf,\n\tZopf: Zopf,\n\tZscr: Zscr,\n\tzscr: zscr,\n\tzwj: zwj,\n\tzwnj: zwnj\n};\n\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1$1 = {\n\tAacute: Aacute,\n\taacute: aacute,\n\tAcirc: Acirc,\n\tacirc: acirc,\n\tacute: acute,\n\tAElig: AElig,\n\taelig: aelig,\n\tAgrave: Agrave,\n\tagrave: agrave,\n\tamp: amp$1,\n\tAMP: AMP,\n\tAring: Aring,\n\taring: aring,\n\tAtilde: Atilde,\n\tatilde: atilde,\n\tAuml: Auml,\n\tauml: auml,\n\tbrvbar: brvbar,\n\tCcedil: Ccedil,\n\tccedil: ccedil,\n\tcedil: cedil,\n\tcent: cent,\n\tcopy: copy,\n\tCOPY: COPY,\n\tcurren: curren,\n\tdeg: deg,\n\tdivide: divide,\n\tEacute: Eacute,\n\teacute: eacute,\n\tEcirc: Ecirc,\n\tecirc: ecirc,\n\tEgrave: Egrave,\n\tegrave: egrave,\n\tETH: ETH,\n\teth: eth,\n\tEuml: Euml,\n\teuml: euml,\n\tfrac12: frac12,\n\tfrac14: frac14,\n\tfrac34: frac34,\n\tgt: gt$1,\n\tGT: GT,\n\tIacute: Iacute,\n\tiacute: iacute,\n\tIcirc: Icirc,\n\ticirc: icirc,\n\tiexcl: iexcl,\n\tIgrave: Igrave,\n\tigrave: igrave,\n\tiquest: iquest,\n\tIuml: Iuml,\n\tiuml: iuml,\n\tlaquo: laquo,\n\tlt: lt$1,\n\tLT: LT,\n\tmacr: macr,\n\tmicro: micro,\n\tmiddot: middot,\n\tnbsp: nbsp,\n\tnot: not,\n\tNtilde: Ntilde,\n\tntilde: ntilde,\n\tOacute: Oacute,\n\toacute: oacute,\n\tOcirc: Ocirc,\n\tocirc: ocirc,\n\tOgrave: Ograve,\n\tograve: ograve,\n\tordf: ordf,\n\tordm: ordm,\n\tOslash: Oslash,\n\toslash: oslash,\n\tOtilde: Otilde,\n\totilde: otilde,\n\tOuml: Ouml,\n\touml: ouml,\n\tpara: para,\n\tplusmn: plusmn,\n\tpound: pound,\n\tquot: quot$1,\n\tQUOT: QUOT,\n\traquo: raquo,\n\treg: reg,\n\tREG: REG,\n\tsect: sect,\n\tshy: shy,\n\tsup1: sup1,\n\tsup2: sup2,\n\tsup3: sup3,\n\tszlig: szlig,\n\tTHORN: THORN,\n\tthorn: thorn,\n\ttimes: times,\n\tUacute: Uacute,\n\tuacute: uacute,\n\tUcirc: Ucirc,\n\tucirc: ucirc,\n\tUgrave: Ugrave,\n\tugrave: ugrave,\n\tuml: uml,\n\tUuml: Uuml,\n\tuuml: uuml,\n\tYacute: Yacute,\n\tyacute: yacute,\n\tyen: yen,\n\tyuml: yuml\n};\n\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n\tamp: amp,\n\tapos: apos,\n\tgt: gt,\n\tlt: lt,\n\tquot: quot\n};\n\nvar decode_codepoint = {};\n\nvar require$$0 = {\n\t\"0\": 65533,\n\t\"128\": 8364,\n\t\"130\": 8218,\n\t\"131\": 402,\n\t\"132\": 8222,\n\t\"133\": 8230,\n\t\"134\": 8224,\n\t\"135\": 8225,\n\t\"136\": 710,\n\t\"137\": 8240,\n\t\"138\": 352,\n\t\"139\": 8249,\n\t\"140\": 338,\n\t\"142\": 381,\n\t\"145\": 8216,\n\t\"146\": 8217,\n\t\"147\": 8220,\n\t\"148\": 8221,\n\t\"149\": 8226,\n\t\"150\": 8211,\n\t\"151\": 8212,\n\t\"152\": 732,\n\t\"153\": 8482,\n\t\"154\": 353,\n\t\"155\": 8250,\n\t\"156\": 339,\n\t\"158\": 382,\n\t\"159\": 376\n};\n\nvar hasRequiredDecode_codepoint;\nfunction requireDecode_codepoint() {\n  if (hasRequiredDecode_codepoint) return decode_codepoint;\n  hasRequiredDecode_codepoint = 1;\n  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n    return mod && mod.__esModule ? mod : {\n      \"default\": mod\n    };\n  };\n  Object.defineProperty(decode_codepoint, \"__esModule\", {\n    value: true\n  });\n  var decode_json_1 = __importDefault(require$$0);\n  // Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\n  var fromCodePoint =\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  String.fromCodePoint || function (codePoint) {\n    var output = \"\";\n    if (codePoint > 0xffff) {\n      codePoint -= 0x10000;\n      output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);\n      codePoint = 0xdc00 | codePoint & 0x3ff;\n    }\n    output += String.fromCharCode(codePoint);\n    return output;\n  };\n  function decodeCodePoint(codePoint) {\n    if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {\n      return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n      codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint(codePoint);\n  }\n  decode_codepoint.default = decodeCodePoint;\n  return decode_codepoint;\n}\n\nvar hasRequiredDecode;\nfunction requireDecode() {\n  if (hasRequiredDecode) return decode;\n  hasRequiredDecode = 1;\n  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n    return mod && mod.__esModule ? mod : {\n      \"default\": mod\n    };\n  };\n  Object.defineProperty(decode, \"__esModule\", {\n    value: true\n  });\n  decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\n  var entities_json_1 = __importDefault(require$$1$2);\n  var legacy_json_1 = __importDefault(require$$1$1);\n  var xml_json_1 = __importDefault(require$$0$1);\n  var decode_codepoint_1 = __importDefault(requireDecode_codepoint());\n  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\n  decode.decodeXML = getStrictDecoder(xml_json_1.default);\n  decode.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);\n  function getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) {\n      return String(str).replace(strictEntityRe, replace);\n    };\n  }\n  var sorter = function sorter(a, b) {\n    return a < b ? 1 : -1;\n  };\n  decode.decodeHTML = function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n      if (legacy[j] === keys[i]) {\n        keys[i] += \";?\";\n        j++;\n      } else {\n        keys[i] += \";\";\n      }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1.default);\n    function replacer(str) {\n      if (str.substr(-1) !== \";\") str += \";\";\n      return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) {\n      return String(str).replace(re, replacer);\n    };\n  }();\n  function getReplacer(map) {\n    return function replace(str) {\n      if (str.charAt(1) === \"#\") {\n        var secondChar = str.charAt(2);\n        if (secondChar === \"X\" || secondChar === \"x\") {\n          return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n        }\n        return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n      }\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      return map[str.slice(1, -1)] || str;\n    };\n  }\n  return decode;\n}\n\nvar encode = {};\n\nvar hasRequiredEncode;\nfunction requireEncode() {\n  if (hasRequiredEncode) return encode;\n  hasRequiredEncode = 1;\n  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n    return mod && mod.__esModule ? mod : {\n      \"default\": mod\n    };\n  };\n  Object.defineProperty(encode, \"__esModule\", {\n    value: true\n  });\n  encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\n  var xml_json_1 = __importDefault(require$$0$1);\n  var inverseXML = getInverseObj(xml_json_1.default);\n  var xmlReplacer = getInverseReplacer(inverseXML);\n  /**\n   * Encodes all non-ASCII characters, as well as characters not valid in XML\n   * documents using XML entities.\n   *\n   * If a character has no equivalent entity, a\n   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n   */\n  encode.encodeXML = getASCIIEncoder(inverseXML);\n  var entities_json_1 = __importDefault(require$$1$2);\n  var inverseHTML = getInverseObj(entities_json_1.default);\n  var htmlReplacer = getInverseReplacer(inverseHTML);\n  /**\n   * Encodes all entities and non-ASCII characters in the input.\n   *\n   * This includes characters that are valid ASCII characters in HTML documents.\n   * For example `#` will be encoded as `&num;`. To get a more compact output,\n   * consider using the `encodeNonAsciiHTML` function.\n   *\n   * If a character has no equivalent entity, a\n   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n   */\n  encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n  /**\n   * Encodes all non-ASCII characters, as well as characters not valid in HTML\n   * documents using HTML entities.\n   *\n   * If a character has no equivalent entity, a\n   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n   */\n  encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\n  function getInverseObj(obj) {\n    return Object.keys(obj).sort().reduce(function (inverse, name) {\n      inverse[obj[name]] = \"&\" + name + \";\";\n      return inverse;\n    }, {});\n  }\n  function getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n      var k = _a[_i];\n      if (k.length === 1) {\n        // Add value to single array\n        single.push(\"\\\\\" + k);\n      } else {\n        // Add value to multiple array\n        multiple.push(k);\n      }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n      // Find the end of a run of characters\n      var end = start;\n      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n        end += 1;\n      }\n      var count = 1 + end - start;\n      // We want to replace at least three characters\n      if (count < 3) continue;\n      single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n  }\n  // /[^\\0-\\x7F]/gu\n  var reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\n  var getCodePoint =\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  String.prototype.codePointAt != null ?\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  function (str) {\n    return str.codePointAt(0);\n  } :\n  // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n  function (c) {\n    return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;\n  };\n  function singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + \";\";\n  }\n  function getInverse(inverse, re) {\n    return function (data) {\n      return data.replace(re, function (name) {\n        return inverse[name];\n      }).replace(reNonASCII, singleCharReplacer);\n    };\n  }\n  var reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n  /**\n   * Encodes all non-ASCII characters, as well as characters not valid in XML\n   * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n   *\n   * Have a look at `escapeUTF8` if you want a more concise output at the expense\n   * of reduced transportability.\n   *\n   * @param data String to escape.\n   */\n  function escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n  }\n  encode.escape = escape;\n  /**\n   * Encodes all characters not valid in XML documents using numeric hexadecimal\n   * reference (eg. `&#xfc;`).\n   *\n   * Note that the output will be character-set dependent.\n   *\n   * @param data String to escape.\n   */\n  function escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n  }\n  encode.escapeUTF8 = escapeUTF8;\n  function getASCIIEncoder(obj) {\n    return function (data) {\n      return data.replace(reEscapeChars, function (c) {\n        return obj[c] || singleCharReplacer(c);\n      });\n    };\n  }\n  return encode;\n}\n\nvar hasRequiredLib$1;\nfunction requireLib$1() {\n  if (hasRequiredLib$1) return lib;\n  hasRequiredLib$1 = 1;\n  (function (exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\n    var decode_1 = requireDecode();\n    var encode_1 = requireEncode();\n    /**\n     * Decodes a string with entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeXML` or `decodeHTML` directly.\n     */\n    function decode(data, level) {\n      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n    }\n    exports.decode = decode;\n    /**\n     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n     */\n    function decodeStrict(data, level) {\n      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n    }\n    exports.decodeStrict = decodeStrict;\n    /**\n     * Encodes a string with entities.\n     *\n     * @param data String to encode.\n     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n     */\n    function encode(data, level) {\n      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n    }\n    exports.encode = encode;\n    var encode_2 = requireEncode();\n    Object.defineProperty(exports, \"encodeXML\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.encodeXML;\n      }\n    });\n    Object.defineProperty(exports, \"encodeHTML\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.encodeHTML;\n      }\n    });\n    Object.defineProperty(exports, \"encodeNonAsciiHTML\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.encodeNonAsciiHTML;\n      }\n    });\n    Object.defineProperty(exports, \"escape\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.escape;\n      }\n    });\n    Object.defineProperty(exports, \"escapeUTF8\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.escapeUTF8;\n      }\n    });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"encodeHTML4\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.encodeHTML;\n      }\n    });\n    Object.defineProperty(exports, \"encodeHTML5\", {\n      enumerable: true,\n      get: function get() {\n        return encode_2.encodeHTML;\n      }\n    });\n    var decode_2 = requireDecode();\n    Object.defineProperty(exports, \"decodeXML\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeXML;\n      }\n    });\n    Object.defineProperty(exports, \"decodeHTML\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTML;\n      }\n    });\n    Object.defineProperty(exports, \"decodeHTMLStrict\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTMLStrict;\n      }\n    });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"decodeHTML4\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTML;\n      }\n    });\n    Object.defineProperty(exports, \"decodeHTML5\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTML;\n      }\n    });\n    Object.defineProperty(exports, \"decodeHTML4Strict\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTMLStrict;\n      }\n    });\n    Object.defineProperty(exports, \"decodeHTML5Strict\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeHTMLStrict;\n      }\n    });\n    Object.defineProperty(exports, \"decodeXMLStrict\", {\n      enumerable: true,\n      get: function get() {\n        return decode_2.decodeXML;\n      }\n    });\n  })(lib);\n  return lib;\n}\n\nvar elementNames = {\n\taltglyph: \"altGlyph\",\n\taltglyphdef: \"altGlyphDef\",\n\taltglyphitem: \"altGlyphItem\",\n\tanimatecolor: \"animateColor\",\n\tanimatemotion: \"animateMotion\",\n\tanimatetransform: \"animateTransform\",\n\tclippath: \"clipPath\",\n\tfeblend: \"feBlend\",\n\tfecolormatrix: \"feColorMatrix\",\n\tfecomponenttransfer: \"feComponentTransfer\",\n\tfecomposite: \"feComposite\",\n\tfeconvolvematrix: \"feConvolveMatrix\",\n\tfediffuselighting: \"feDiffuseLighting\",\n\tfedisplacementmap: \"feDisplacementMap\",\n\tfedistantlight: \"feDistantLight\",\n\tfedropshadow: \"feDropShadow\",\n\tfeflood: \"feFlood\",\n\tfefunca: \"feFuncA\",\n\tfefuncb: \"feFuncB\",\n\tfefuncg: \"feFuncG\",\n\tfefuncr: \"feFuncR\",\n\tfegaussianblur: \"feGaussianBlur\",\n\tfeimage: \"feImage\",\n\tfemerge: \"feMerge\",\n\tfemergenode: \"feMergeNode\",\n\tfemorphology: \"feMorphology\",\n\tfeoffset: \"feOffset\",\n\tfepointlight: \"fePointLight\",\n\tfespecularlighting: \"feSpecularLighting\",\n\tfespotlight: \"feSpotLight\",\n\tfetile: \"feTile\",\n\tfeturbulence: \"feTurbulence\",\n\tforeignobject: \"foreignObject\",\n\tglyphref: \"glyphRef\",\n\tlineargradient: \"linearGradient\",\n\tradialgradient: \"radialGradient\",\n\ttextpath: \"textPath\"\n};\nvar attributeNames = {\n\tdefinitionurl: \"definitionURL\",\n\tattributename: \"attributeName\",\n\tattributetype: \"attributeType\",\n\tbasefrequency: \"baseFrequency\",\n\tbaseprofile: \"baseProfile\",\n\tcalcmode: \"calcMode\",\n\tclippathunits: \"clipPathUnits\",\n\tdiffuseconstant: \"diffuseConstant\",\n\tedgemode: \"edgeMode\",\n\tfilterunits: \"filterUnits\",\n\tglyphref: \"glyphRef\",\n\tgradienttransform: \"gradientTransform\",\n\tgradientunits: \"gradientUnits\",\n\tkernelmatrix: \"kernelMatrix\",\n\tkernelunitlength: \"kernelUnitLength\",\n\tkeypoints: \"keyPoints\",\n\tkeysplines: \"keySplines\",\n\tkeytimes: \"keyTimes\",\n\tlengthadjust: \"lengthAdjust\",\n\tlimitingconeangle: \"limitingConeAngle\",\n\tmarkerheight: \"markerHeight\",\n\tmarkerunits: \"markerUnits\",\n\tmarkerwidth: \"markerWidth\",\n\tmaskcontentunits: \"maskContentUnits\",\n\tmaskunits: \"maskUnits\",\n\tnumoctaves: \"numOctaves\",\n\tpathlength: \"pathLength\",\n\tpatterncontentunits: \"patternContentUnits\",\n\tpatterntransform: \"patternTransform\",\n\tpatternunits: \"patternUnits\",\n\tpointsatx: \"pointsAtX\",\n\tpointsaty: \"pointsAtY\",\n\tpointsatz: \"pointsAtZ\",\n\tpreservealpha: \"preserveAlpha\",\n\tpreserveaspectratio: \"preserveAspectRatio\",\n\tprimitiveunits: \"primitiveUnits\",\n\trefx: \"refX\",\n\trefy: \"refY\",\n\trepeatcount: \"repeatCount\",\n\trepeatdur: \"repeatDur\",\n\trequiredextensions: \"requiredExtensions\",\n\trequiredfeatures: \"requiredFeatures\",\n\tspecularconstant: \"specularConstant\",\n\tspecularexponent: \"specularExponent\",\n\tspreadmethod: \"spreadMethod\",\n\tstartoffset: \"startOffset\",\n\tstddeviation: \"stdDeviation\",\n\tstitchtiles: \"stitchTiles\",\n\tsurfacescale: \"surfaceScale\",\n\tsystemlanguage: \"systemLanguage\",\n\ttablevalues: \"tableValues\",\n\ttargetx: \"targetX\",\n\ttargety: \"targetY\",\n\ttextlength: \"textLength\",\n\tviewbox: \"viewBox\",\n\tviewtarget: \"viewTarget\",\n\txchannelselector: \"xChannelSelector\",\n\tychannelselector: \"yChannelSelector\",\n\tzoomandpan: \"zoomAndPan\"\n};\nvar require$$2$1 = {\n\telementNames: elementNames,\n\tattributeNames: attributeNames\n};\n\n/*\n  Module dependencies\n*/\nvar hasRequiredDomSerializer;\nfunction requireDomSerializer() {\n  if (hasRequiredDomSerializer) return domSerializer.exports;\n  hasRequiredDomSerializer = 1;\n  var ElementType = requireLib$2();\n  var entities = requireLib$1();\n\n  /* mixed-case SVG and MathML tags & attributes\n     recognized by the HTML parser, see\n     https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n  */\n  var foreignNames = require$$2$1;\n  foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */\n  foreignNames.attributeNames.__proto__ = null;\n  var unencodedElements = {\n    __proto__: null,\n    style: true,\n    script: true,\n    xmp: true,\n    iframe: true,\n    noembed: true,\n    noframes: true,\n    plaintext: true,\n    noscript: true\n  };\n\n  /*\n    Format attributes\n  */\n  function formatAttrs(attributes, opts) {\n    if (!attributes) return;\n    var output = '';\n    var value;\n\n    // Loop through the attributes\n    for (var key in attributes) {\n      value = attributes[key];\n      if (output) {\n        output += ' ';\n      }\n      if (opts.xmlMode === 'foreign') {\n        /* fix up mixed-case attribute names */\n        key = foreignNames.attributeNames[key] || key;\n      }\n      output += key;\n      if (value !== null && value !== '' || opts.xmlMode) {\n        output += '=\"' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\\\"/g, '&quot;')) + '\"';\n      }\n    }\n    return output;\n  }\n\n  /*\n    Self-enclosing tags (stolen from node-htmlparser)\n  */\n  var singleTag = {\n    __proto__: null,\n    area: true,\n    base: true,\n    basefont: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    frame: true,\n    hr: true,\n    img: true,\n    input: true,\n    isindex: true,\n    keygen: true,\n    link: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n  };\n  var render = domSerializer.exports = function (dom, opts) {\n    if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];\n    opts = opts || {};\n    var output = '';\n    for (var i = 0; i < dom.length; i++) {\n      var elem = dom[i];\n      if (elem.type === 'root') output += render(elem.children, opts);else if (ElementType.isTag(elem)) output += renderTag(elem, opts);else if (elem.type === ElementType.Directive) output += renderDirective(elem);else if (elem.type === ElementType.Comment) output += renderComment(elem);else if (elem.type === ElementType.CDATA) output += renderCdata(elem);else output += renderText(elem, opts);\n    }\n    return output;\n  };\n  var foreignModeIntegrationPoints = ['mi', 'mo', 'mn', 'ms', 'mtext', 'annotation-xml', 'foreignObject', 'desc', 'title'];\n  function renderTag(elem, opts) {\n    // Handle SVG / MathML in HTML\n    if (opts.xmlMode === 'foreign') {\n      /* fix up mixed-case element names */\n      elem.name = foreignNames.elementNames[elem.name] || elem.name;\n      /* exit foreign mode at integration points */\n      if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0) opts = Object.assign({}, opts, {\n        xmlMode: false\n      });\n    }\n    if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {\n      opts = Object.assign({}, opts, {\n        xmlMode: 'foreign'\n      });\n    }\n    var tag = '<' + elem.name;\n    var attribs = formatAttrs(elem.attribs, opts);\n    if (attribs) {\n      tag += ' ' + attribs;\n    }\n    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {\n      tag += '/>';\n    } else {\n      tag += '>';\n      if (elem.children) {\n        tag += render(elem.children, opts);\n      }\n      if (!singleTag[elem.name] || opts.xmlMode) {\n        tag += '</' + elem.name + '>';\n      }\n    }\n    return tag;\n  }\n  function renderDirective(elem) {\n    return '<' + elem.data + '>';\n  }\n  function renderText(elem, opts) {\n    var data = elem.data || '';\n\n    // if entities weren't decoded, no need to encode them back\n    if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {\n      data = entities.encodeXML(data);\n    }\n    return data;\n  }\n  function renderCdata(elem) {\n    return '<![CDATA[' + elem.children[0].data + ']]>';\n  }\n  function renderComment(elem) {\n    return '<!--' + elem.data + '-->';\n  }\n  return domSerializer.exports;\n}\n\nvar stringify;\nvar hasRequiredStringify;\nfunction requireStringify() {\n  if (hasRequiredStringify) return stringify;\n  hasRequiredStringify = 1;\n  var ElementType = domelementtype,\n    getOuterHTML = requireDomSerializer(),\n    isTag = ElementType.isTag;\n  stringify = {\n    getInnerHTML: getInnerHTML,\n    getOuterHTML: getOuterHTML,\n    getText: getText\n  };\n  function getInnerHTML(elem, opts) {\n    return elem.children ? elem.children.map(function (elem) {\n      return getOuterHTML(elem, opts);\n    }).join(\"\") : \"\";\n  }\n  function getText(elem) {\n    if (Array.isArray(elem)) return elem.map(getText).join(\"\");\n    if (isTag(elem)) return elem.name === \"br\" ? \"\\n\" : getText(elem.children);\n    if (elem.type === ElementType.CDATA) return getText(elem.children);\n    if (elem.type === ElementType.Text) return elem.data;\n    return \"\";\n  }\n  return stringify;\n}\n\nvar traversal = {};\n\nvar hasRequiredTraversal;\nfunction requireTraversal() {\n  if (hasRequiredTraversal) return traversal;\n  hasRequiredTraversal = 1;\n  var getChildren = traversal.getChildren = function (elem) {\n    return elem.children;\n  };\n  var getParent = traversal.getParent = function (elem) {\n    return elem.parent;\n  };\n  traversal.getSiblings = function (elem) {\n    var parent = getParent(elem);\n    return parent ? getChildren(parent) : [elem];\n  };\n  traversal.getAttributeValue = function (elem, name) {\n    return elem.attribs && elem.attribs[name];\n  };\n  traversal.hasAttrib = function (elem, name) {\n    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);\n  };\n  traversal.getName = function (elem) {\n    return elem.name;\n  };\n  return traversal;\n}\n\nvar manipulation = {};\n\nvar hasRequiredManipulation;\nfunction requireManipulation() {\n  if (hasRequiredManipulation) return manipulation;\n  hasRequiredManipulation = 1;\n  manipulation.removeElement = function (elem) {\n    if (elem.prev) elem.prev.next = elem.next;\n    if (elem.next) elem.next.prev = elem.prev;\n    if (elem.parent) {\n      var childs = elem.parent.children;\n      childs.splice(childs.lastIndexOf(elem), 1);\n    }\n  };\n  manipulation.replaceElement = function (elem, replacement) {\n    var prev = replacement.prev = elem.prev;\n    if (prev) {\n      prev.next = replacement;\n    }\n    var next = replacement.next = elem.next;\n    if (next) {\n      next.prev = replacement;\n    }\n    var parent = replacement.parent = elem.parent;\n    if (parent) {\n      var childs = parent.children;\n      childs[childs.lastIndexOf(elem)] = replacement;\n    }\n  };\n  manipulation.appendChild = function (elem, child) {\n    child.parent = elem;\n    if (elem.children.push(child) !== 1) {\n      var sibling = elem.children[elem.children.length - 2];\n      sibling.next = child;\n      child.prev = sibling;\n      child.next = null;\n    }\n  };\n  manipulation.append = function (elem, next) {\n    var parent = elem.parent,\n      currNext = elem.next;\n    next.next = currNext;\n    next.prev = elem;\n    elem.next = next;\n    next.parent = parent;\n    if (currNext) {\n      currNext.prev = next;\n      if (parent) {\n        var childs = parent.children;\n        childs.splice(childs.lastIndexOf(currNext), 0, next);\n      }\n    } else if (parent) {\n      parent.children.push(next);\n    }\n  };\n  manipulation.prepend = function (elem, prev) {\n    var parent = elem.parent;\n    if (parent) {\n      var childs = parent.children;\n      childs.splice(childs.lastIndexOf(elem), 0, prev);\n    }\n    if (elem.prev) {\n      elem.prev.next = prev;\n    }\n    prev.parent = parent;\n    prev.prev = elem.prev;\n    prev.next = elem;\n    elem.prev = prev;\n  };\n  return manipulation;\n}\n\nvar querying;\nvar hasRequiredQuerying;\nfunction requireQuerying() {\n  if (hasRequiredQuerying) return querying;\n  hasRequiredQuerying = 1;\n  var isTag = domelementtype.isTag;\n  querying = {\n    filter: filter,\n    find: find,\n    findOneChild: findOneChild,\n    findOne: findOne,\n    existsOne: existsOne,\n    findAll: findAll\n  };\n  function filter(test, element, recurse, limit) {\n    if (!Array.isArray(element)) element = [element];\n    if (typeof limit !== \"number\" || !isFinite(limit)) {\n      limit = Infinity;\n    }\n    return find(test, element, recurse !== false, limit);\n  }\n  function find(test, elems, recurse, limit) {\n    var result = [],\n      childs;\n    for (var i = 0, j = elems.length; i < j; i++) {\n      if (test(elems[i])) {\n        result.push(elems[i]);\n        if (--limit <= 0) break;\n      }\n      childs = elems[i].children;\n      if (recurse && childs && childs.length > 0) {\n        childs = find(test, childs, recurse, limit);\n        result = result.concat(childs);\n        limit -= childs.length;\n        if (limit <= 0) break;\n      }\n    }\n    return result;\n  }\n  function findOneChild(test, elems) {\n    for (var i = 0, l = elems.length; i < l; i++) {\n      if (test(elems[i])) return elems[i];\n    }\n    return null;\n  }\n  function findOne(test, elems) {\n    var elem = null;\n    for (var i = 0, l = elems.length; i < l && !elem; i++) {\n      if (!isTag(elems[i])) {\n        continue;\n      } else if (test(elems[i])) {\n        elem = elems[i];\n      } else if (elems[i].children.length > 0) {\n        elem = findOne(test, elems[i].children);\n      }\n    }\n    return elem;\n  }\n  function existsOne(test, elems) {\n    for (var i = 0, l = elems.length; i < l; i++) {\n      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function findAll(test, rootElems) {\n    var result = [];\n    var stack = rootElems.slice();\n    while (stack.length) {\n      var elem = stack.shift();\n      if (!isTag(elem)) continue;\n      if (elem.children && elem.children.length > 0) {\n        stack.unshift.apply(stack, elem.children);\n      }\n      if (test(elem)) result.push(elem);\n    }\n    return result;\n  }\n  return querying;\n}\n\nvar legacy = {};\n\nvar hasRequiredLegacy;\nfunction requireLegacy() {\n  if (hasRequiredLegacy) return legacy;\n  hasRequiredLegacy = 1;\n  var ElementType = domelementtype;\n  var isTag = legacy.isTag = ElementType.isTag;\n  legacy.testElement = function (options, element) {\n    for (var key in options) {\n      if (!options.hasOwnProperty(key)) ;else if (key === \"tag_name\") {\n        if (!isTag(element) || !options.tag_name(element.name)) {\n          return false;\n        }\n      } else if (key === \"tag_type\") {\n        if (!options.tag_type(element.type)) return false;\n      } else if (key === \"tag_contains\") {\n        if (isTag(element) || !options.tag_contains(element.data)) {\n          return false;\n        }\n      } else if (!element.attribs || !options[key](element.attribs[key])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var Checks = {\n    tag_name: function tag_name(name) {\n      if (typeof name === \"function\") {\n        return function (elem) {\n          return isTag(elem) && name(elem.name);\n        };\n      } else if (name === \"*\") {\n        return isTag;\n      } else {\n        return function (elem) {\n          return isTag(elem) && elem.name === name;\n        };\n      }\n    },\n    tag_type: function tag_type(type) {\n      if (typeof type === \"function\") {\n        return function (elem) {\n          return type(elem.type);\n        };\n      } else {\n        return function (elem) {\n          return elem.type === type;\n        };\n      }\n    },\n    tag_contains: function tag_contains(data) {\n      if (typeof data === \"function\") {\n        return function (elem) {\n          return !isTag(elem) && data(elem.data);\n        };\n      } else {\n        return function (elem) {\n          return !isTag(elem) && elem.data === data;\n        };\n      }\n    }\n  };\n  function getAttribCheck(attrib, value) {\n    if (typeof value === \"function\") {\n      return function (elem) {\n        return elem.attribs && value(elem.attribs[attrib]);\n      };\n    } else {\n      return function (elem) {\n        return elem.attribs && elem.attribs[attrib] === value;\n      };\n    }\n  }\n  function combineFuncs(a, b) {\n    return function (elem) {\n      return a(elem) || b(elem);\n    };\n  }\n  legacy.getElements = function (options, element, recurse, limit) {\n    var funcs = Object.keys(options).map(function (key) {\n      var value = options[key];\n      return key in Checks ? Checks[key](value) : getAttribCheck(key, value);\n    });\n    return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);\n  };\n  legacy.getElementById = function (id, element, recurse) {\n    if (!Array.isArray(element)) element = [element];\n    return this.findOne(getAttribCheck(\"id\", id), element, recurse !== false);\n  };\n  legacy.getElementsByTagName = function (name, element, recurse, limit) {\n    return this.filter(Checks.tag_name(name), element, recurse, limit);\n  };\n  legacy.getElementsByTagType = function (type, element, recurse, limit) {\n    return this.filter(Checks.tag_type(type), element, recurse, limit);\n  };\n  return legacy;\n}\n\nvar helpers = {};\n\nvar hasRequiredHelpers;\nfunction requireHelpers() {\n  if (hasRequiredHelpers) return helpers;\n  hasRequiredHelpers = 1;\n  // removeSubsets\n  // Given an array of nodes, remove any member that is contained by another.\n  helpers.removeSubsets = function (nodes) {\n    var idx = nodes.length,\n      node,\n      ancestor,\n      replace;\n\n    // Check if each node (or one of its ancestors) is already contained in the\n    // array.\n    while (--idx > -1) {\n      node = ancestor = nodes[idx];\n\n      // Temporarily remove the node under consideration\n      nodes[idx] = null;\n      replace = true;\n      while (ancestor) {\n        if (nodes.indexOf(ancestor) > -1) {\n          replace = false;\n          nodes.splice(idx, 1);\n          break;\n        }\n        ancestor = ancestor.parent;\n      }\n\n      // If the node has been found to be unique, re-insert it.\n      if (replace) {\n        nodes[idx] = node;\n      }\n    }\n    return nodes;\n  };\n\n  // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n  var POSITION = {\n    DISCONNECTED: 1,\n    PRECEDING: 2,\n    FOLLOWING: 4,\n    CONTAINS: 8,\n    CONTAINED_BY: 16\n  };\n\n  // Compare the position of one node against another node in any other document.\n  // The return value is a bitmask with the following values:\n  //\n  // document order:\n  // > There is an ordering, document order, defined on all the nodes in the\n  // > document corresponding to the order in which the first character of the\n  // > XML representation of each node occurs in the XML representation of the\n  // > document after expansion of general entities. Thus, the document element\n  // > node will be the first node. Element nodes occur before their children.\n  // > Thus, document order orders element nodes in order of the occurrence of\n  // > their start-tag in the XML (after expansion of entities). The attribute\n  // > nodes of an element occur after the element and before its children. The\n  // > relative order of attribute nodes is implementation-dependent./\n  // Source:\n  // http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n  //\n  // @argument {Node} nodaA The first node to use in the comparison\n  // @argument {Node} nodeB The second node to use in the comparison\n  //\n  // @return {Number} A bitmask describing the input nodes' relative position.\n  //         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n  //         a description of these values.\n  var comparePos = helpers.compareDocumentPosition = function (nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    var current, sharedParent, siblings, aSibling, bSibling, idx;\n    if (nodeA === nodeB) {\n      return 0;\n    }\n    current = nodeA;\n    while (current) {\n      aParents.unshift(current);\n      current = current.parent;\n    }\n    current = nodeB;\n    while (current) {\n      bParents.unshift(current);\n      current = current.parent;\n    }\n    idx = 0;\n    while (aParents[idx] === bParents[idx]) {\n      idx++;\n    }\n    if (idx === 0) {\n      return POSITION.DISCONNECTED;\n    }\n    sharedParent = aParents[idx - 1];\n    siblings = sharedParent.children;\n    aSibling = aParents[idx];\n    bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n      if (sharedParent === nodeB) {\n        return POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n      }\n      return POSITION.FOLLOWING;\n    } else {\n      if (sharedParent === nodeA) {\n        return POSITION.PRECEDING | POSITION.CONTAINS;\n      }\n      return POSITION.PRECEDING;\n    }\n  };\n\n  // Sort an array of nodes based on their relative position in the document and\n  // remove any duplicate nodes. If the array contains nodes that do not belong\n  // to the same document, sort order is unspecified.\n  //\n  // @argument {Array} nodes Array of DOM nodes\n  //\n  // @returns {Array} collection of unique nodes, sorted in document order\n  helpers.uniqueSort = function (nodes) {\n    var idx = nodes.length,\n      node,\n      position;\n    nodes = nodes.slice();\n    while (--idx > -1) {\n      node = nodes[idx];\n      position = nodes.indexOf(node);\n      if (position > -1 && position < idx) {\n        nodes.splice(idx, 1);\n      }\n    }\n    nodes.sort(function (a, b) {\n      var relative = comparePos(a, b);\n      if (relative & POSITION.PRECEDING) {\n        return -1;\n      } else if (relative & POSITION.FOLLOWING) {\n        return 1;\n      }\n      return 0;\n    });\n    return nodes;\n  };\n  return helpers;\n}\n\nvar hasRequiredDomutils;\nfunction requireDomutils() {\n  if (hasRequiredDomutils) return domutils.exports;\n  hasRequiredDomutils = 1;\n  (function (module) {\n    var DomUtils = module.exports;\n    [requireStringify(), requireTraversal(), requireManipulation(), requireQuerying(), requireLegacy(), requireHelpers()].forEach(function (ext) {\n      Object.keys(ext).forEach(function (key) {\n        DomUtils[key] = ext[key].bind(DomUtils);\n      });\n    });\n  })(domutils);\n  return domutils.exports;\n}\n\nvar FeedHandler_1;\nvar hasRequiredFeedHandler;\nfunction requireFeedHandler() {\n  if (hasRequiredFeedHandler) return FeedHandler_1;\n  hasRequiredFeedHandler = 1;\n  var DomHandler = domhandler;\n  var DomUtils = requireDomutils();\n\n  //TODO: make this a streamable handler\n  function FeedHandler(callback, options) {\n    this.init(callback, options);\n  }\n  require$$1$3(FeedHandler, DomHandler);\n  FeedHandler.prototype.init = DomHandler;\n  function getElements(what, where) {\n    return DomUtils.getElementsByTagName(what, where, true);\n  }\n  function getOneElement(what, where) {\n    return DomUtils.getElementsByTagName(what, where, true, 1)[0];\n  }\n  function fetch(what, where, recurse) {\n    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();\n  }\n  function addConditionally(obj, prop, what, where, recurse) {\n    var tmp = fetch(what, where, recurse);\n    if (tmp) obj[prop] = tmp;\n  }\n  var isValidFeed = function isValidFeed(value) {\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n  };\n  FeedHandler.prototype.onend = function () {\n    var feed = {},\n      feedRoot = getOneElement(isValidFeed, this.dom),\n      tmp,\n      childs;\n    if (feedRoot) {\n      if (feedRoot.name === \"feed\") {\n        childs = feedRoot.children;\n        feed.type = \"atom\";\n        addConditionally(feed, \"id\", \"id\", childs);\n        addConditionally(feed, \"title\", \"title\", childs);\n        if ((tmp = getOneElement(\"link\", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;\n        addConditionally(feed, \"description\", \"subtitle\", childs);\n        if (tmp = fetch(\"updated\", childs)) feed.updated = new Date(tmp);\n        addConditionally(feed, \"author\", \"email\", childs, true);\n        feed.items = getElements(\"entry\", childs).map(function (item) {\n          var entry = {},\n            tmp;\n          item = item.children;\n          addConditionally(entry, \"id\", \"id\", item);\n          addConditionally(entry, \"title\", \"title\", item);\n          if ((tmp = getOneElement(\"link\", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;\n          if (tmp = fetch(\"summary\", item) || fetch(\"content\", item)) entry.description = tmp;\n          if (tmp = fetch(\"updated\", item)) entry.pubDate = new Date(tmp);\n          return entry;\n        });\n      } else {\n        childs = getOneElement(\"channel\", feedRoot.children).children;\n        feed.type = feedRoot.name.substr(0, 3);\n        feed.id = \"\";\n        addConditionally(feed, \"title\", \"title\", childs);\n        addConditionally(feed, \"link\", \"link\", childs);\n        addConditionally(feed, \"description\", \"description\", childs);\n        if (tmp = fetch(\"lastBuildDate\", childs)) feed.updated = new Date(tmp);\n        addConditionally(feed, \"author\", \"managingEditor\", childs, true);\n        feed.items = getElements(\"item\", feedRoot.children).map(function (item) {\n          var entry = {},\n            tmp;\n          item = item.children;\n          addConditionally(entry, \"id\", \"guid\", item);\n          addConditionally(entry, \"title\", \"title\", item);\n          addConditionally(entry, \"link\", \"link\", item);\n          addConditionally(entry, \"description\", \"description\", item);\n          if (tmp = fetch(\"pubDate\", item)) entry.pubDate = new Date(tmp);\n          return entry;\n        });\n      }\n    }\n    this.dom = feed;\n    DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error(\"couldn't find root of feed\"));\n  };\n  FeedHandler_1 = FeedHandler;\n  return FeedHandler_1;\n}\n\nvar _nodeResolve_empty = {};\n\nvar _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  default: _nodeResolve_empty\n});\n\nvar require$$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);\n\nvar global$1 = (typeof global !== \"undefined\" ? global :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;\n}\n\nfunction toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = (tmp >> 16) & 0xFF;\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[L++] = (tmp >> 8) & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[(tmp << 4) & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n    output += lookup[tmp >> 10];\n    output += lookup[(tmp >> 4) & 0x3F];\n    output += lookup[(tmp << 2) & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('')\n}\n\nfunction read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n}\n\nvar toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\nvar INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n  ? global$1.TYPED_ARRAY_SUPPORT\n  : true;\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nvar _kMaxLength = kMaxLength();\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from$1(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr\n};\n\nfunction from$1 (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from$1(null, value, encodingOrOffset, length)\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) ;\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n};\n\nfunction allocUnsafe (that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n};\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n};\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer\n};\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap (b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this\n};\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this\n};\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this\n};\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0;\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n};\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n};\n\nBuffer.prototype.inspect = function inspect () {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>'\n};\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset;  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1);\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n};\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n};\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed;\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n};\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return fromByteArray(buf)\n  } else {\n    return fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    );\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val\n};\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset]\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8)\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1]\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n};\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val\n};\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, true, 23, 4)\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return read(this, offset, false, 23, 4)\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, true, 52, 8)\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return read(this, offset, false, 52, 8)\n};\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 1] = (value >>> 8);\n    this[offset] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength\n};\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = (value & 0xff);\n  return offset + 1\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8);\n    this[offset + 1] = (value & 0xff);\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff);\n    this[offset + 1] = (value >>> 8);\n    this[offset + 2] = (value >>> 16);\n    this[offset + 3] = (value >>> 24);\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24);\n    this[offset + 1] = (value >>> 16);\n    this[offset + 2] = (value >>> 8);\n    this[offset + 3] = (value & 0xff);\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4\n};\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4);\n  }\n  write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n};\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8);\n  }\n  write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    );\n  }\n\n  return len\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i];\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n\nvar _polyfillNode_buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Buffer: Buffer,\n  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,\n  SlowBuffer: SlowBuffer,\n  isBuffer: isBuffer,\n  kMaxLength: _kMaxLength\n});\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     };\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nfunction StringDecoder(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n}\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\nvar _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  StringDecoder: StringDecoder\n});\n\nvar require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);\n\nvar require$$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);\n\nvar WritableStream_1;\nvar hasRequiredWritableStream;\nfunction requireWritableStream() {\n  if (hasRequiredWritableStream) return WritableStream_1;\n  hasRequiredWritableStream = 1;\n  WritableStream_1 = Stream;\n  var Parser = Parser_1;\n  var WritableStream = require$$1.Writable;\n  var StringDecoder = require$$2.StringDecoder;\n  var Buffer = require$$3.Buffer;\n  function Stream(cbs, options) {\n    var parser = this._parser = new Parser(cbs, options);\n    var decoder = this._decoder = new StringDecoder();\n    WritableStream.call(this, {\n      decodeStrings: false\n    });\n    this.once(\"finish\", function () {\n      parser.end(decoder.end());\n    });\n  }\n  require$$1$3(Stream, WritableStream);\n  Stream.prototype._write = function (chunk, encoding, cb) {\n    if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);\n    this._parser.write(chunk);\n    cb();\n  };\n  return WritableStream_1;\n}\n\nvar Stream_1;\nvar hasRequiredStream;\nfunction requireStream() {\n  if (hasRequiredStream) return Stream_1;\n  hasRequiredStream = 1;\n  Stream_1 = Stream;\n  var Parser = requireWritableStream();\n  function Stream(options) {\n    Parser.call(this, new Cbs(this), options);\n  }\n  require$$1$3(Stream, Parser);\n  Stream.prototype.readable = true;\n  function Cbs(scope) {\n    this.scope = scope;\n  }\n  var EVENTS = requireLib().EVENTS;\n  Object.keys(EVENTS).forEach(function (name) {\n    if (EVENTS[name] === 0) {\n      Cbs.prototype[\"on\" + name] = function () {\n        this.scope.emit(name);\n      };\n    } else if (EVENTS[name] === 1) {\n      Cbs.prototype[\"on\" + name] = function (a) {\n        this.scope.emit(name, a);\n      };\n    } else if (EVENTS[name] === 2) {\n      Cbs.prototype[\"on\" + name] = function (a, b) {\n        this.scope.emit(name, a, b);\n      };\n    } else {\n      throw Error(\"wrong number of arguments!\");\n    }\n  });\n  return Stream_1;\n}\n\nvar ProxyHandler_1;\nvar hasRequiredProxyHandler;\nfunction requireProxyHandler() {\n  if (hasRequiredProxyHandler) return ProxyHandler_1;\n  hasRequiredProxyHandler = 1;\n  ProxyHandler_1 = ProxyHandler;\n  function ProxyHandler(cbs) {\n    this._cbs = cbs || {};\n  }\n  var EVENTS = requireLib().EVENTS;\n  Object.keys(EVENTS).forEach(function (name) {\n    if (EVENTS[name] === 0) {\n      name = \"on\" + name;\n      ProxyHandler.prototype[name] = function () {\n        if (this._cbs[name]) this._cbs[name]();\n      };\n    } else if (EVENTS[name] === 1) {\n      name = \"on\" + name;\n      ProxyHandler.prototype[name] = function (a) {\n        if (this._cbs[name]) this._cbs[name](a);\n      };\n    } else if (EVENTS[name] === 2) {\n      name = \"on\" + name;\n      ProxyHandler.prototype[name] = function (a, b) {\n        if (this._cbs[name]) this._cbs[name](a, b);\n      };\n    } else {\n      throw Error(\"wrong number of arguments\");\n    }\n  });\n  return ProxyHandler_1;\n}\n\nvar CollectingHandler_1;\nvar hasRequiredCollectingHandler;\nfunction requireCollectingHandler() {\n  if (hasRequiredCollectingHandler) return CollectingHandler_1;\n  hasRequiredCollectingHandler = 1;\n  CollectingHandler_1 = CollectingHandler;\n  function CollectingHandler(cbs) {\n    this._cbs = cbs || {};\n    this.events = [];\n  }\n  var EVENTS = requireLib().EVENTS;\n  Object.keys(EVENTS).forEach(function (name) {\n    if (EVENTS[name] === 0) {\n      name = \"on\" + name;\n      CollectingHandler.prototype[name] = function () {\n        this.events.push([name]);\n        if (this._cbs[name]) this._cbs[name]();\n      };\n    } else if (EVENTS[name] === 1) {\n      name = \"on\" + name;\n      CollectingHandler.prototype[name] = function (a) {\n        this.events.push([name, a]);\n        if (this._cbs[name]) this._cbs[name](a);\n      };\n    } else if (EVENTS[name] === 2) {\n      name = \"on\" + name;\n      CollectingHandler.prototype[name] = function (a, b) {\n        this.events.push([name, a, b]);\n        if (this._cbs[name]) this._cbs[name](a, b);\n      };\n    } else {\n      throw Error(\"wrong number of arguments\");\n    }\n  });\n  CollectingHandler.prototype.onreset = function () {\n    this.events = [];\n    if (this._cbs.onreset) this._cbs.onreset();\n  };\n  CollectingHandler.prototype.restart = function () {\n    if (this._cbs.onreset) this._cbs.onreset();\n    for (var i = 0, len = this.events.length; i < len; i++) {\n      if (this._cbs[this.events[i][0]]) {\n        var num = this.events[i].length;\n        if (num === 1) {\n          this._cbs[this.events[i][0]]();\n        } else if (num === 2) {\n          this._cbs[this.events[i][0]](this.events[i][1]);\n        } else {\n          this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);\n        }\n      }\n    }\n  };\n  return CollectingHandler_1;\n}\n\nvar hasRequiredLib;\nfunction requireLib() {\n  if (hasRequiredLib) return lib$2.exports;\n  hasRequiredLib = 1;\n  (function (module) {\n    var Parser = Parser_1;\n    var DomHandler = domhandler;\n    function defineProp(name, value) {\n      delete module.exports[name];\n      module.exports[name] = value;\n      return value;\n    }\n    module.exports = {\n      Parser: Parser,\n      Tokenizer: Tokenizer_1,\n      ElementType: domelementtype,\n      DomHandler: DomHandler,\n      get FeedHandler() {\n        return defineProp(\"FeedHandler\", requireFeedHandler());\n      },\n      get Stream() {\n        return defineProp(\"Stream\", requireStream());\n      },\n      get WritableStream() {\n        return defineProp(\"WritableStream\", requireWritableStream());\n      },\n      get ProxyHandler() {\n        return defineProp(\"ProxyHandler\", requireProxyHandler());\n      },\n      get DomUtils() {\n        return defineProp(\"DomUtils\", requireDomutils());\n      },\n      get CollectingHandler() {\n        return defineProp(\"CollectingHandler\", requireCollectingHandler());\n      },\n      // For legacy support\n      DefaultHandler: DomHandler,\n      get RssHandler() {\n        return defineProp(\"RssHandler\", this.FeedHandler);\n      },\n      //helper methods\n      parseDOM: function parseDOM(data, options) {\n        var handler = new DomHandler(options);\n        new Parser(handler, options).end(data);\n        return handler.dom;\n      },\n      parseFeed: function parseFeed(feed, options) {\n        var handler = new module.exports.FeedHandler(options);\n        new Parser(handler, options).end(feed);\n        return handler.dom;\n      },\n      createDomStream: function createDomStream(cb, options, elementCb) {\n        var handler = new DomHandler(cb, options, elementCb);\n        return new Parser(handler, options);\n      },\n      // List of all events that the parser emits\n      EVENTS: {\n        /* Format: eventname: number of arguments */\n        attribute: 2,\n        cdatastart: 0,\n        cdataend: 0,\n        text: 1,\n        processinginstruction: 2,\n        comment: 1,\n        commentend: 0,\n        closetag: 1,\n        opentag: 2,\n        opentagname: 1,\n        error: 1,\n        end: 0\n      }\n    };\n  })(lib$2);\n  return lib$2.exports;\n}\n\n// Store markers outside of the function scope,\n// not to recreate them on every call\nvar entities = {\n  'amp': '&',\n  'apos': '\\'',\n  'lt': '<',\n  'gt': '>',\n  'quot': '\"',\n  'nbsp': '\\xa0'\n};\nvar entityPattern = /&([a-z]+);/ig;\nvar decodeHtml$1 = function decodeHTMLEntities(text) {\n  // A single replace pass with a static RegExp is faster than a loop\n  return text.replace(entityPattern, function (match, entity) {\n    entity = entity.toLowerCase();\n    if (entities.hasOwnProperty(entity)) {\n      return entities[entity];\n    }\n    // return original string if there is no matching entity (no replace)\n    return match;\n  });\n};\n\nvar html$2 = requireLib();\nvar decodeHtml = decodeHtml$1;\n\n/**\n * Convert a part of a mutation DOM to a mutation VM object, recursively.\n * @param {object} dom DOM object for mutation tag.\n * @return {object} Object representing useful parts of this mutation.\n */\nvar mutatorTagToObject = function mutatorTagToObject(dom) {\n  var obj = Object.create(null);\n  obj.tagName = dom.name;\n  obj.children = [];\n  for (var prop in dom.attribs) {\n    if (prop === 'xmlns') continue;\n    obj[prop] = decodeHtml(dom.attribs[prop]);\n    // Note: the capitalization of block info in the following lines is important.\n    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.\n    if (prop === 'blockinfo') {\n      obj.blockInfo = JSON.parse(obj.blockinfo);\n      delete obj.blockinfo;\n    }\n  }\n  for (var i = 0; i < dom.children.length; i++) {\n    obj.children.push(mutatorTagToObject(dom.children[i]));\n  }\n  return obj;\n};\n\n/**\n * Adapter between mutator XML or DOM and block representation which can be\n * used by the Scratch runtime.\n * @param {(object|string)} mutation Mutation XML string or DOM.\n * @return {object} Object representing the mutation.\n */\nvar mutationAdpater = function mutationAdpater(mutation) {\n  var mutationParsed;\n  // Check if the mutation is already parsed; if not, parse it.\n  if (_typeof(mutation) === 'object') {\n    mutationParsed = mutation;\n  } else {\n    mutationParsed = html$2.parseDOM(mutation)[0];\n  }\n  return mutatorTagToObject(mutationParsed);\n};\nvar mutationAdapter$1 = mutationAdpater;\n\n/**\n * @fileoverview UID generator, from Blockly.\n */\n\n/**\n * Legal characters for the unique ID.\n * Should be all on a US keyboard.  No XML special characters or control codes.\n * Removed $ due to issue 251.\n * @private\n */\nvar soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n * @return {string} A globally unique ID string.\n */\nvar uid$4 = function uid() {\n  var length = 20;\n  var soupLength = soup_.length;\n  var id = [];\n  for (var i = 0; i < length; i++) {\n    id[i] = soup_.charAt(Math.random() * soupLength);\n  }\n  return id.join('');\n};\nvar uid_1 = uid$4;\n\nvar mutationAdapter = mutationAdapter$1;\nvar html$1 = requireLib();\nvar uid$3 = uid_1;\n\n/**\n * Convert and an individual block DOM to the representation tree.\n * Based on Blockly's `domToBlockHeadless_`.\n * @param {Element} blockDOM DOM tree for an individual block.\n * @param {object} blocks Collection of blocks to add to.\n * @param {boolean} isTopBlock Whether blocks at this level are \"top blocks.\"\n * @param {?string} parent Parent block ID.\n * @return {undefined}\n */\nvar domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {\n  if (!blockDOM.attribs.id) {\n    blockDOM.attribs.id = uid$3();\n  }\n\n  // Block skeleton.\n  var block = {\n    id: blockDOM.attribs.id,\n    // Block ID\n    opcode: blockDOM.attribs.type,\n    // For execution, \"event_whengreenflag\".\n    inputs: {},\n    // Inputs to this block and the blocks they point to.\n    fields: {},\n    // Fields on this block and their values.\n    next: null,\n    // Next block in the stack, if one exists.\n    topLevel: isTopBlock,\n    // If this block starts a stack.\n    parent: parent,\n    // Parent block ID, if available.\n    shadow: blockDOM.name === 'shadow',\n    // If this represents a shadow/slot.\n    x: blockDOM.attribs.x,\n    // X position of script, if top-level.\n    y: blockDOM.attribs.y // Y position of script, if top-level.\n  };\n\n  // Add the block to the representation tree.\n  blocks[block.id] = block;\n\n  // Process XML children and find enclosed blocks, fields, etc.\n  for (var i = 0; i < blockDOM.children.length; i++) {\n    var xmlChild = blockDOM.children[i];\n    // Enclosed blocks and shadows\n    var childBlockNode = null;\n    var childShadowNode = null;\n    for (var j = 0; j < xmlChild.children.length; j++) {\n      var grandChildNode = xmlChild.children[j];\n      if (!grandChildNode.name) {\n        // Non-XML tag node.\n        continue;\n      }\n      var grandChildNodeName = grandChildNode.name.toLowerCase();\n      if (grandChildNodeName === 'block') {\n        childBlockNode = grandChildNode;\n      } else if (grandChildNodeName === 'shadow') {\n        childShadowNode = grandChildNode;\n      }\n    }\n\n    // Use shadow block only if there's no real block node.\n    if (!childBlockNode && childShadowNode) {\n      childBlockNode = childShadowNode;\n    }\n\n    // Not all Blockly-type blocks are handled here,\n    // as we won't be using all of them for Scratch.\n    switch (xmlChild.name.toLowerCase()) {\n      case 'field':\n        {\n          // Add the field to this block.\n          var fieldName = xmlChild.attribs.name;\n          // Add id in case it is a variable field\n          var fieldId = xmlChild.attribs.id;\n          var fieldData = '';\n          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {\n            fieldData = xmlChild.children[0].data;\n          } else {\n            // If the child of the field with a data property\n            // doesn't exist, set the data to an empty string.\n            fieldData = '';\n          }\n          block.fields[fieldName] = {\n            name: fieldName,\n            id: fieldId,\n            value: fieldData\n          };\n          var fieldVarType = xmlChild.attribs.variabletype;\n          if (typeof fieldVarType === 'string') {\n            block.fields[fieldName].variableType = fieldVarType;\n          }\n          break;\n        }\n      case 'comment':\n        {\n          block.comment = xmlChild.attribs.id;\n          break;\n        }\n      case 'value':\n      case 'statement':\n        {\n          // Recursively generate block structure for input block.\n          domToBlock(childBlockNode, blocks, false, block.id);\n          if (childShadowNode && childBlockNode !== childShadowNode) {\n            // Also generate the shadow block.\n            domToBlock(childShadowNode, blocks, false, block.id);\n          }\n          // Link this block's input to the child block.\n          var inputName = xmlChild.attribs.name;\n          block.inputs[inputName] = {\n            name: inputName,\n            block: childBlockNode.attribs.id,\n            shadow: childShadowNode ? childShadowNode.attribs.id : null\n          };\n          break;\n        }\n      case 'next':\n        {\n          if (!childBlockNode || !childBlockNode.attribs) {\n            // Invalid child block.\n            continue;\n          }\n          // Recursively generate block structure for next block.\n          domToBlock(childBlockNode, blocks, false, block.id);\n          // Link next block to this block.\n          block.next = childBlockNode.attribs.id;\n          break;\n        }\n      case 'mutation':\n        {\n          block.mutation = mutationAdapter(xmlChild);\n          break;\n        }\n    }\n  }\n};\n\n/**\n * Convert outer blocks DOM from a Blockly CREATE event\n * to a usable form for the Scratch runtime.\n * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.\n * @param {Element} blocksDOM DOM tree for this event.\n * @return {Array.<object>} Usable list of blocks from this CREATE event.\n */\nvar domToBlocks = function domToBlocks(blocksDOM) {\n  // At this level, there could be multiple blocks adjacent in the DOM tree.\n  var blocks = {};\n  for (var i = 0; i < blocksDOM.length; i++) {\n    var block = blocksDOM[i];\n    if (!block.name || !block.attribs) {\n      continue;\n    }\n    var tagName = block.name.toLowerCase();\n    if (tagName === 'block' || tagName === 'shadow') {\n      domToBlock(block, blocks, true, null);\n    }\n  }\n  // Flatten blocks object into a list.\n  var blocksList = [];\n  for (var b in blocks) {\n    if (!Object.prototype.hasOwnProperty.call(blocks, b)) continue;\n    blocksList.push(blocks[b]);\n  }\n  return blocksList;\n};\n\n/**\n * Adapter between block creation events and block representation which can be\n * used by the Scratch runtime.\n * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`\n * @return {Array.<object>} List of blocks from this CREATE event.\n */\nvar adapter = function adapter(e) {\n  // Validate input\n  if (_typeof(e) !== 'object') return;\n  if (_typeof(e.xml) !== 'object') return;\n  return domToBlocks(html$1.parseDOM(e.xml.outerHTML, {\n    decodeEntities: true\n  }));\n};\nvar adapter_1 = adapter;\n\nvar log$1 = log$3;\n\n/**\n * Escape a string to be safe to use in XML content.\n * CC-BY-SA: hgoebl\n * https://stackoverflow.com/questions/7918868/\n * how-to-escape-xml-entities-in-javascript\n * @param {!string | !Array.<string>} unsafe Unsafe string.\n * @return {string} XML-escaped string, for use within an XML tag.\n */\nvar xmlEscape$2 = function xmlEscape(unsafe) {\n  if (typeof unsafe !== 'string') {\n    if (Array.isArray(unsafe)) {\n      // This happens when we have hacked blocks from 2.0\n      // See #1030\n      unsafe = String(unsafe);\n    } else {\n      log$1.error('Unexpected input recieved in replaceUnsafeChars');\n      return unsafe;\n    }\n  }\n  return unsafe.replace(/[<>&'\"]/g, function (c) {\n    switch (c) {\n      case '<':\n        return '&lt;';\n      case '>':\n        return '&gt;';\n      case '&':\n        return '&amp;';\n      case '\\'':\n        return '&apos;';\n      case '\"':\n        return '&quot;';\n    }\n  });\n};\nvar xmlEscape_1 = xmlEscape$2;\n\nvar immutable = {exports: {}};\n\n(function (module, exports) {\n  (function (global, factory) {\n    module.exports = factory() ;\n  })(commonjsGlobal, function () {\n\n    var SLICE$0 = Array.prototype.slice;\n    function createClass(ctor, superClass) {\n      if (superClass) {\n        ctor.prototype = Object.create(superClass.prototype);\n      }\n      ctor.prototype.constructor = ctor;\n    }\n    function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n    createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n    createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n    createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n    function isIterable(maybeIterable) {\n      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n    }\n    function isKeyed(maybeKeyed) {\n      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n    }\n    function isIndexed(maybeIndexed) {\n      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n    }\n    function isAssociative(maybeAssociative) {\n      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n    }\n    function isOrdered(maybeOrdered) {\n      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n    }\n    Iterable.isIterable = isIterable;\n    Iterable.isKeyed = isKeyed;\n    Iterable.isIndexed = isIndexed;\n    Iterable.isAssociative = isAssociative;\n    Iterable.isOrdered = isOrdered;\n    Iterable.Keyed = KeyedIterable;\n    Iterable.Indexed = IndexedIterable;\n    Iterable.Set = SetIterable;\n    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n    var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n    // Used for setting prototype methods that IE8 chokes on.\n    var DELETE = 'delete';\n\n    // Constants describing the size of trie nodes.\n    var SHIFT = 5; // Resulted in best performance after ______?\n    var SIZE = 1 << SHIFT;\n    var MASK = SIZE - 1;\n\n    // A consistent shared value representing \"not set\" which equals nothing other\n    // than itself, and nothing that could be provided externally.\n    var NOT_SET = {};\n\n    // Boolean references, Rough equivalent of `bool &`.\n    var CHANGE_LENGTH = {\n      value: false\n    };\n    var DID_ALTER = {\n      value: false\n    };\n    function MakeRef(ref) {\n      ref.value = false;\n      return ref;\n    }\n    function SetRef(ref) {\n      ref && (ref.value = true);\n    }\n\n    // A function which returns a value representing an \"owner\" for transient writes\n    // to tries. The return value will only ever equal itself, and will not equal\n    // the return of any subsequent call of this function.\n    function OwnerID() {}\n\n    // http://jsperf.com/copy-array-inline\n    function arrCopy(arr, offset) {\n      offset = offset || 0;\n      var len = Math.max(0, arr.length - offset);\n      var newArr = new Array(len);\n      for (var ii = 0; ii < len; ii++) {\n        newArr[ii] = arr[ii + offset];\n      }\n      return newArr;\n    }\n    function ensureSize(iter) {\n      if (iter.size === undefined) {\n        iter.size = iter.__iterate(returnTrue);\n      }\n      return iter.size;\n    }\n    function wrapIndex(iter, index) {\n      // This implements \"is array index\" which the ECMAString spec defines as:\n      //\n      //     A String property name P is an array index if and only if\n      //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n      //     to 2^32−1.\n      //\n      // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n      if (typeof index !== 'number') {\n        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n        if ('' + uint32Index !== index || uint32Index === 4294967295) {\n          return NaN;\n        }\n        index = uint32Index;\n      }\n      return index < 0 ? ensureSize(iter) + index : index;\n    }\n    function returnTrue() {\n      return true;\n    }\n    function wholeSlice(begin, end, size) {\n      return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n    }\n    function resolveBegin(begin, size) {\n      return resolveIndex(begin, size, 0);\n    }\n    function resolveEnd(end, size) {\n      return resolveIndex(end, size, size);\n    }\n    function resolveIndex(index, size, defaultIndex) {\n      return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);\n    }\n\n    /* global Symbol */\n\n    var ITERATE_KEYS = 0;\n    var ITERATE_VALUES = 1;\n    var ITERATE_ENTRIES = 2;\n    var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n    function Iterator(next) {\n      this.next = next;\n    }\n    Iterator.prototype.toString = function () {\n      return '[Iterator]';\n    };\n    Iterator.KEYS = ITERATE_KEYS;\n    Iterator.VALUES = ITERATE_VALUES;\n    Iterator.ENTRIES = ITERATE_ENTRIES;\n    Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n      return this.toString();\n    };\n    Iterator.prototype[ITERATOR_SYMBOL] = function () {\n      return this;\n    };\n    function iteratorValue(type, k, v, iteratorResult) {\n      var value = type === 0 ? k : type === 1 ? v : [k, v];\n      iteratorResult ? iteratorResult.value = value : iteratorResult = {\n        value: value,\n        done: false\n      };\n      return iteratorResult;\n    }\n    function iteratorDone() {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    function hasIterator(maybeIterable) {\n      return !!getIteratorFn(maybeIterable);\n    }\n    function isIterator(maybeIterator) {\n      return maybeIterator && typeof maybeIterator.next === 'function';\n    }\n    function getIterator(iterable) {\n      var iteratorFn = getIteratorFn(iterable);\n      return iteratorFn && iteratorFn.call(iterable);\n    }\n    function getIteratorFn(iterable) {\n      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n      if (typeof iteratorFn === 'function') {\n        return iteratorFn;\n      }\n    }\n    function isArrayLike(value) {\n      return value && typeof value.length === 'number';\n    }\n    createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n    Seq.of = function /*...values*/\n    () {\n      return Seq(arguments);\n    };\n    Seq.prototype.toSeq = function () {\n      return this;\n    };\n    Seq.prototype.toString = function () {\n      return this.__toString('Seq {', '}');\n    };\n    Seq.prototype.cacheResult = function () {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function (fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function (type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n    createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);\n    }\n    KeyedSeq.prototype.toKeyedSeq = function () {\n      return this;\n    };\n    createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n    IndexedSeq.of = function /*...values*/\n    () {\n      return IndexedSeq(arguments);\n    };\n    IndexedSeq.prototype.toIndexedSeq = function () {\n      return this;\n    };\n    IndexedSeq.prototype.toString = function () {\n      return this.__toString('Seq [', ']');\n    };\n    IndexedSeq.prototype.__iterate = function (fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n    IndexedSeq.prototype.__iterator = function (type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n    createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();\n    }\n    SetSeq.of = function /*...values*/\n    () {\n      return SetSeq(arguments);\n    };\n    SetSeq.prototype.toSetSeq = function () {\n      return this;\n    };\n    Seq.isSeq = isSeq;\n    Seq.Keyed = KeyedSeq;\n    Seq.Set = SetSeq;\n    Seq.Indexed = IndexedSeq;\n    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n    Seq.prototype[IS_SEQ_SENTINEL] = true;\n    createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n    ArraySeq.prototype.get = function (index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n    ArraySeq.prototype.__iterate = function (fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n    ArraySeq.prototype.__iterator = function (type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function () {\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);\n      });\n    };\n    createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n    ObjectSeq.prototype.get = function (key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n    ObjectSeq.prototype.has = function (key) {\n      return this._object.hasOwnProperty(key);\n    };\n    ObjectSeq.prototype.__iterate = function (fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n    ObjectSeq.prototype.__iterator = function (type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function () {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);\n      });\n    };\n    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n    createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n    IterableSeq.prototype.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n    IterableSeq.prototype.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n    createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n    IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function () {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n    // # pragma Helper functions\n\n    function isSeq(maybeSeq) {\n      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n    }\n    var EMPTY_SEQ;\n    function emptySequence() {\n      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n    }\n    function keyedSeqFromValue(value) {\n      var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : _typeof(value) === 'object' ? new ObjectSeq(value) : undefined;\n      if (!seq) {\n        throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);\n      }\n      return seq;\n    }\n    function indexedSeqFromValue(value) {\n      var seq = maybeIndexedSeqFromValue(value);\n      if (!seq) {\n        throw new TypeError('Expected Array or iterable object of values: ' + value);\n      }\n      return seq;\n    }\n    function seqFromValue(value) {\n      var seq = maybeIndexedSeqFromValue(value) || _typeof(value) === 'object' && new ObjectSeq(value);\n      if (!seq) {\n        throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);\n      }\n      return seq;\n    }\n    function maybeIndexedSeqFromValue(value) {\n      return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;\n    }\n    function seqIterate(seq, fn, reverse, useKeys) {\n      var cache = seq._cache;\n      if (cache) {\n        var maxIndex = cache.length - 1;\n        for (var ii = 0; ii <= maxIndex; ii++) {\n          var entry = cache[reverse ? maxIndex - ii : ii];\n          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n            return ii + 1;\n          }\n        }\n        return ii;\n      }\n      return seq.__iterateUncached(fn, reverse);\n    }\n    function seqIterator(seq, type, reverse, useKeys) {\n      var cache = seq._cache;\n      if (cache) {\n        var maxIndex = cache.length - 1;\n        var ii = 0;\n        return new Iterator(function () {\n          var entry = cache[reverse ? maxIndex - ii : ii];\n          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n        });\n      }\n      return seq.__iteratorUncached(type, reverse);\n    }\n    function fromJS(json, converter) {\n      return converter ? fromJSWith(converter, json, '', {\n        '': json\n      }) : fromJSDefault(json);\n    }\n    function fromJSWith(converter, json, key, parentJSON) {\n      if (Array.isArray(json)) {\n        return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {\n          return fromJSWith(converter, v, k, json);\n        }));\n      }\n      if (isPlainObj(json)) {\n        return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {\n          return fromJSWith(converter, v, k, json);\n        }));\n      }\n      return json;\n    }\n    function fromJSDefault(json) {\n      if (Array.isArray(json)) {\n        return IndexedSeq(json).map(fromJSDefault).toList();\n      }\n      if (isPlainObj(json)) {\n        return KeyedSeq(json).map(fromJSDefault).toMap();\n      }\n      return json;\n    }\n    function isPlainObj(value) {\n      return value && (value.constructor === Object || value.constructor === undefined);\n    }\n\n    /**\n     * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n     * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n     *\n     * NaN is considered the same as NaN, however -0 and 0 are considered the same\n     * value, which is different from the algorithm described by\n     * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n     *\n     * This is extended further to allow Objects to describe the values they\n     * represent, by way of `valueOf` or `equals` (and `hashCode`).\n     *\n     * Note: because of this extension, the key equality of Immutable.Map and the\n     * value equality of Immutable.Set will differ from ES6 Map and Set.\n     *\n     * ### Defining custom values\n     *\n     * The easiest way to describe the value an object represents is by implementing\n     * `valueOf`. For example, `Date` represents a value by returning a unix\n     * timestamp for `valueOf`:\n     *\n     *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n     *     var date2 = new Date(1234567890000);\n     *     date1.valueOf(); // 1234567890000\n     *     assert( date1 !== date2 );\n     *     assert( Immutable.is( date1, date2 ) );\n     *\n     * Note: overriding `valueOf` may have other implications if you use this object\n     * where JavaScript expects a primitive, such as implicit string coercion.\n     *\n     * For more complex types, especially collections, implementing `valueOf` may\n     * not be performant. An alternative is to implement `equals` and `hashCode`.\n     *\n     * `equals` takes another object, presumably of similar type, and returns true\n     * if the it is equal. Equality is symmetrical, so the same result should be\n     * returned if this and the argument are flipped.\n     *\n     *     assert( a.equals(b) === b.equals(a) );\n     *\n     * `hashCode` returns a 32bit integer number representing the object which will\n     * be used to determine how to store the value object in a Map or Set. You must\n     * provide both or neither methods, one must not exist without the other.\n     *\n     * Also, an important relationship between these methods must be upheld: if two\n     * values are equal, they *must* return the same hashCode. If the values are not\n     * equal, they might have the same hashCode; this is called a hash collision,\n     * and while undesirable for performance reasons, it is acceptable.\n     *\n     *     if (a.equals(b)) {\n     *       assert( a.hashCode() === b.hashCode() );\n     *     }\n     *\n     * All Immutable collections implement `equals` and `hashCode`.\n     *\n     */\n    function is(valueA, valueB) {\n      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n      if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {\n        valueA = valueA.valueOf();\n        valueB = valueB.valueOf();\n        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n          return true;\n        }\n        if (!valueA || !valueB) {\n          return false;\n        }\n      }\n      if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {\n        return true;\n      }\n      return false;\n    }\n    function deepEqual(a, b) {\n      if (a === b) {\n        return true;\n      }\n      if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n        return false;\n      }\n      if (a.size === 0 && b.size === 0) {\n        return true;\n      }\n      var notAssociative = !isAssociative(a);\n      if (isOrdered(a)) {\n        var entries = a.entries();\n        return b.every(function (v, k) {\n          var entry = entries.next().value;\n          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done;\n      }\n      var flipped = false;\n      if (a.size === undefined) {\n        if (b.size === undefined) {\n          if (typeof a.cacheResult === 'function') {\n            a.cacheResult();\n          }\n        } else {\n          flipped = true;\n          var _ = a;\n          a = b;\n          b = _;\n        }\n      }\n      var allEqual = true;\n      var bSize = b.__iterate(function (v, k) {\n        if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n          allEqual = false;\n          return false;\n        }\n      });\n      return allEqual && a.size === bSize;\n    }\n    createClass(Repeat, IndexedSeq);\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n    Repeat.prototype.toString = function () {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n    Repeat.prototype.get = function (index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n    Repeat.prototype.includes = function (searchValue) {\n      return is(this._value, searchValue);\n    };\n    Repeat.prototype.slice = function (begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n    Repeat.prototype.reverse = function () {\n      return this;\n    };\n    Repeat.prototype.indexOf = function (searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n    Repeat.prototype.lastIndexOf = function (searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n    Repeat.prototype.__iterate = function (fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n    Repeat.prototype.__iterator = function (type, reverse) {\n      var this$0 = this;\n      var ii = 0;\n      return new Iterator(function () {\n        return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();\n      });\n    };\n    Repeat.prototype.equals = function (other) {\n      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);\n    };\n    var EMPTY_REPEAT;\n    function invariant(condition, error) {\n      if (!condition) throw new Error(error);\n    }\n    createClass(Range, IndexedSeq);\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n    Range.prototype.toString = function () {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';\n    };\n    Range.prototype.get = function (index, notSetValue) {\n      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n    };\n    Range.prototype.includes = function (searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n    };\n    Range.prototype.slice = function (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n    Range.prototype.indexOf = function (searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n    Range.prototype.lastIndexOf = function (searchValue) {\n      return this.indexOf(searchValue);\n    };\n    Range.prototype.__iterate = function (fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n    Range.prototype.__iterator = function (type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function () {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n    Range.prototype.equals = function (other) {\n      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n    };\n    var EMPTY_RANGE;\n    createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n    createClass(KeyedCollection, Collection);\n    function KeyedCollection() {}\n    createClass(IndexedCollection, Collection);\n    function IndexedCollection() {}\n    createClass(SetCollection, Collection);\n    function SetCollection() {}\n    Collection.Keyed = KeyedCollection;\n    Collection.Indexed = IndexedCollection;\n    Collection.Set = SetCollection;\n    var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n    };\n\n    // v8 has an optimization for storing 31-bit signed numbers.\n    // Values which have either 00 or 11 as the high order bits qualify.\n    // This function drops the highest order bit in a signed number, maintaining\n    // the sign bit.\n    function smi(i32) {\n      return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;\n    }\n    function hash(o) {\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n      if (typeof o.valueOf === 'function') {\n        o = o.valueOf();\n        if (o === false || o === null || o === undefined) {\n          return 0;\n        }\n      }\n      if (o === true) {\n        return 1;\n      }\n      var type = _typeof(o);\n      if (type === 'number') {\n        if (o !== o || o === Infinity) {\n          return 0;\n        }\n        var h = o | 0;\n        if (h !== o) {\n          h ^= o * 0xFFFFFFFF;\n        }\n        while (o > 0xFFFFFFFF) {\n          o /= 0xFFFFFFFF;\n          h ^= o;\n        }\n        return smi(h);\n      }\n      if (type === 'string') {\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n      }\n      if (typeof o.hashCode === 'function') {\n        return o.hashCode();\n      }\n      if (type === 'object') {\n        return hashJSObj(o);\n      }\n      if (typeof o.toString === 'function') {\n        return hashString(o.toString());\n      }\n      throw new Error('Value type ' + type + ' cannot be hashed.');\n    }\n    function cachedHashString(string) {\n      var hash = stringHashCache[string];\n      if (hash === undefined) {\n        hash = hashString(string);\n        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n          STRING_HASH_CACHE_SIZE = 0;\n          stringHashCache = {};\n        }\n        STRING_HASH_CACHE_SIZE++;\n        stringHashCache[string] = hash;\n      }\n      return hash;\n    }\n\n    // http://jsperf.com/hashing-strings\n    function hashString(string) {\n      // This is the hash from JVM\n      // The hash code for a string is computed as\n      // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n      // where s[i] is the ith character of the string and n is the length of\n      // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n      // (exclusive) by dropping high bits.\n      var hash = 0;\n      for (var ii = 0; ii < string.length; ii++) {\n        hash = 31 * hash + string.charCodeAt(ii) | 0;\n      }\n      return smi(hash);\n    }\n    function hashJSObj(obj) {\n      var hash;\n      if (usingWeakMap) {\n        hash = weakMap.get(obj);\n        if (hash !== undefined) {\n          return hash;\n        }\n      }\n      hash = obj[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n      if (!canDefineProperty) {\n        hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n        if (hash !== undefined) {\n          return hash;\n        }\n        hash = getIENodeHash(obj);\n        if (hash !== undefined) {\n          return hash;\n        }\n      }\n      hash = ++objHashUID;\n      if (objHashUID & 0x40000000) {\n        objHashUID = 0;\n      }\n      if (usingWeakMap) {\n        weakMap.set(obj, hash);\n      } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      } else if (canDefineProperty) {\n        Object.defineProperty(obj, UID_HASH_KEY, {\n          'enumerable': false,\n          'configurable': false,\n          'writable': false,\n          'value': hash\n        });\n      } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n        // Since we can't define a non-enumerable property on the object\n        // we'll hijack one of the less-used non-enumerable properties to\n        // save our hash on it. Since this is a function it will not show up in\n        // `JSON.stringify` which is what we want.\n        obj.propertyIsEnumerable = function () {\n          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n        };\n        obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n      } else if (obj.nodeType !== undefined) {\n        // At this point we couldn't get the IE `uniqueID` to use as a hash\n        // and we couldn't use a non-enumerable property to exploit the\n        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n        // itself.\n        obj[UID_HASH_KEY] = hash;\n      } else {\n        throw new Error('Unable to set a non-enumerable property on object.');\n      }\n      return hash;\n    }\n\n    // Get references to ES5 object methods.\n    var isExtensible = Object.isExtensible;\n\n    // True if Object.defineProperty works as expected. IE8 fails this test.\n    var canDefineProperty = function () {\n      try {\n        Object.defineProperty({}, '@', {});\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }();\n\n    // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n    // and avoid memory leaks from the IE cloneNode bug.\n    function getIENodeHash(node) {\n      if (node && node.nodeType > 0) {\n        switch (node.nodeType) {\n          case 1:\n            // Element\n            return node.uniqueID;\n          case 9:\n            // Document\n            return node.documentElement && node.documentElement.uniqueID;\n        }\n      }\n    }\n\n    // If possible, use a WeakMap.\n    var usingWeakMap = typeof WeakMap === 'function';\n    var weakMap;\n    if (usingWeakMap) {\n      weakMap = new WeakMap();\n    }\n    var objHashUID = 0;\n    var UID_HASH_KEY = '__immutablehash__';\n    if (typeof Symbol === 'function') {\n      UID_HASH_KEY = Symbol(UID_HASH_KEY);\n    }\n    var STRING_HASH_CACHE_MIN_STRLEN = 16;\n    var STRING_HASH_CACHE_MAX_SIZE = 255;\n    var STRING_HASH_CACHE_SIZE = 0;\n    var stringHashCache = {};\n    function assertNotInfinite(size) {\n      invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');\n    }\n    createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {\n        var iter = KeyedIterable(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n    Map.of = function () {\n      var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n    Map.prototype.toString = function () {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function (k, notSetValue) {\n      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function (k, v) {\n      return updateMap(this, k, v);\n    };\n    Map.prototype.setIn = function (keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function () {\n        return v;\n      });\n    };\n    Map.prototype.remove = function (k) {\n      return updateMap(this, k, NOT_SET);\n    };\n    Map.prototype.deleteIn = function (keyPath) {\n      return this.updateIn(keyPath, function () {\n        return NOT_SET;\n      });\n    };\n    Map.prototype.update = function (k, notSetValue, updater) {\n      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);\n    };\n    Map.prototype.updateIn = function (keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n    Map.prototype.clear = function () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function /*...iters*/\n    () {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n    Map.prototype.mergeWith = function (merger) {\n      var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n    Map.prototype.mergeIn = function (keyPath) {\n      var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(keyPath, emptyMap(), function (m) {\n        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];\n      });\n    };\n    Map.prototype.mergeDeep = function /*...iters*/\n    () {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n    Map.prototype.mergeDeepWith = function (merger) {\n      var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n    Map.prototype.mergeDeepIn = function (keyPath) {\n      var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(keyPath, emptyMap(), function (m) {\n        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];\n      });\n    };\n    Map.prototype.sort = function (comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n    Map.prototype.sortBy = function (mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function (fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n    Map.prototype.asMutable = function () {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n    Map.prototype.asImmutable = function () {\n      return this.__ensureOwner();\n    };\n    Map.prototype.wasAltered = function () {\n      return this.__altered;\n    };\n    Map.prototype.__iterator = function (type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n    Map.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n    Map.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n    function isMap(maybeMap) {\n      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n    }\n    Map.isMap = isMap;\n    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n    var MapPrototype = Map.prototype;\n    MapPrototype[IS_MAP_SENTINEL] = true;\n    MapPrototype[DELETE] = MapPrototype.remove;\n    MapPrototype.removeIn = MapPrototype.deleteIn;\n\n    // #pragma Trie Nodes\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n    ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n    ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n    BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n    BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n      var idx = popCount(bitmap & bit - 1);\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n    HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n    HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n      if (removed && !node) {\n        return this;\n      }\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n    HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n    HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var removed = value === NOT_SET;\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n    ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n    ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n    // #pragma Iterators\n\n    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {\n      var entries = this.entries;\n      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n          return false;\n        }\n      }\n    };\n    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n      var nodes = this.nodes;\n      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n        var node = nodes[reverse ? maxIndex - ii : ii];\n        if (node && node.iterate(fn, reverse) === false) {\n          return false;\n        }\n      }\n    };\n    ValueNode.prototype.iterate = function (fn, reverse) {\n      return fn(this.entry);\n    };\n    createClass(MapIterator, Iterator);\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n    MapIterator.prototype.next = function () {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n    function mapIteratorValue(type, entry) {\n      return iteratorValue(type, entry[0], entry[1]);\n    }\n    function mapIteratorFrame(node, prev) {\n      return {\n        node: node,\n        index: 0,\n        __prev: prev\n      };\n    }\n    function makeMap(size, root, ownerID, hash) {\n      var map = Object.create(MapPrototype);\n      map.size = size;\n      map._root = root;\n      map.__ownerID = ownerID;\n      map.__hash = hash;\n      map.__altered = false;\n      return map;\n    }\n    var EMPTY_MAP;\n    function emptyMap() {\n      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n    }\n    function updateMap(map, k, v) {\n      var newRoot;\n      var newSize;\n      if (!map._root) {\n        if (v === NOT_SET) {\n          return map;\n        }\n        newSize = 1;\n        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n      } else {\n        var didChangeSize = MakeRef(CHANGE_LENGTH);\n        var didAlter = MakeRef(DID_ALTER);\n        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n        if (!didAlter.value) {\n          return map;\n        }\n        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n      }\n      if (map.__ownerID) {\n        map.size = newSize;\n        map._root = newRoot;\n        map.__hash = undefined;\n        map.__altered = true;\n        return map;\n      }\n      return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n    }\n    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (!node) {\n        if (value === NOT_SET) {\n          return node;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return new ValueNode(ownerID, keyHash, [key, value]);\n      }\n      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n    }\n    function isLeafNode(node) {\n      return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n    }\n    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n      if (node.keyHash === keyHash) {\n        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n      }\n      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var newNode;\n      var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n      return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n    }\n    function createNodes(ownerID, entries, key, value) {\n      if (!ownerID) {\n        ownerID = new OwnerID();\n      }\n      var node = new ValueNode(ownerID, hash(key), [key, value]);\n      for (var ii = 0; ii < entries.length; ii++) {\n        var entry = entries[ii];\n        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n      }\n      return node;\n    }\n    function packNodes(ownerID, nodes, count, excluding) {\n      var bitmap = 0;\n      var packedII = 0;\n      var packedNodes = new Array(count);\n      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n        var node = nodes[ii];\n        if (node !== undefined && ii !== excluding) {\n          bitmap |= bit;\n          packedNodes[packedII++] = node;\n        }\n      }\n      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n    }\n    function expandNodes(ownerID, nodes, bitmap, including, node) {\n      var count = 0;\n      var expandedNodes = new Array(SIZE);\n      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n      }\n      expandedNodes[including] = node;\n      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n    }\n    function mergeIntoMapWith(map, merger, iterables) {\n      var iters = [];\n      for (var ii = 0; ii < iterables.length; ii++) {\n        var value = iterables[ii];\n        var iter = KeyedIterable(value);\n        if (!isIterable(value)) {\n          iter = iter.map(function (v) {\n            return fromJS(v);\n          });\n        }\n        iters.push(iter);\n      }\n      return mergeIntoCollectionWith(map, merger, iters);\n    }\n    function deepMerger(existing, value, key) {\n      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;\n    }\n    function deepMergerWith(merger) {\n      return function (existing, value, key) {\n        if (existing && existing.mergeDeepWith && isIterable(value)) {\n          return existing.mergeDeepWith(merger, value);\n        }\n        var nextValue = merger(existing, value, key);\n        return is(existing, nextValue) ? existing : nextValue;\n      };\n    }\n    function mergeIntoCollectionWith(collection, merger, iters) {\n      iters = iters.filter(function (x) {\n        return x.size !== 0;\n      });\n      if (iters.length === 0) {\n        return collection;\n      }\n      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n        return collection.constructor(iters[0]);\n      }\n      return collection.withMutations(function (collection) {\n        var mergeIntoMap = merger ? function (value, key) {\n          collection.update(key, NOT_SET, function (existing) {\n            return existing === NOT_SET ? value : merger(existing, value, key);\n          });\n        } : function (value, key) {\n          collection.set(key, value);\n        };\n        for (var ii = 0; ii < iters.length; ii++) {\n          iters[ii].forEach(mergeIntoMap);\n        }\n      });\n    }\n    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n      var isNotSet = existing === NOT_SET;\n      var step = keyPathIter.next();\n      if (step.done) {\n        var existingValue = isNotSet ? notSetValue : existing;\n        var newValue = updater(existingValue);\n        return newValue === existingValue ? existing : newValue;\n      }\n      invariant(isNotSet || existing && existing.set, 'invalid keyPath');\n      var key = step.value;\n      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);\n      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n    }\n    function popCount(x) {\n      x = x - (x >> 1 & 0x55555555);\n      x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n      x = x + (x >> 4) & 0x0f0f0f0f;\n      x = x + (x >> 8);\n      x = x + (x >> 16);\n      return x & 0x7f;\n    }\n    function setIn(array, idx, val, canEdit) {\n      var newArray = canEdit ? array : arrCopy(array);\n      newArray[idx] = val;\n      return newArray;\n    }\n    function spliceIn(array, idx, val, canEdit) {\n      var newLen = array.length + 1;\n      if (canEdit && idx + 1 === newLen) {\n        array[idx] = val;\n        return array;\n      }\n      var newArray = new Array(newLen);\n      var after = 0;\n      for (var ii = 0; ii < newLen; ii++) {\n        if (ii === idx) {\n          newArray[ii] = val;\n          after = -1;\n        } else {\n          newArray[ii] = array[ii + after];\n        }\n      }\n      return newArray;\n    }\n    function spliceOut(array, idx, canEdit) {\n      var newLen = array.length - 1;\n      if (canEdit && idx === newLen) {\n        array.pop();\n        return array;\n      }\n      var newArray = new Array(newLen);\n      var after = 0;\n      for (var ii = 0; ii < newLen; ii++) {\n        if (ii === idx) {\n          after = 1;\n        }\n        newArray[ii] = array[ii + after];\n      }\n      return newArray;\n    }\n    var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n    createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) {\n          return list.set(i, v);\n        });\n      });\n    }\n    List.of = function /*...values*/\n    () {\n      return this(arguments);\n    };\n    List.prototype.toString = function () {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function (index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function (index, value) {\n      return updateList(this, index, value);\n    };\n    List.prototype.remove = function (index) {\n      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n    };\n    List.prototype.insert = function (index, value) {\n      return this.splice(index, 0, value);\n    };\n    List.prototype.clear = function () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n    List.prototype.push = function /*...values*/\n    () {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n    List.prototype.pop = function () {\n      return setListBounds(this, 0, -1);\n    };\n    List.prototype.unshift = function /*...values*/\n    () {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n    List.prototype.shift = function () {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function /*...iters*/\n    () {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n    List.prototype.mergeWith = function (merger) {\n      var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n    List.prototype.mergeDeep = function /*...iters*/\n    () {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n    List.prototype.mergeDeepWith = function (merger) {\n      var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n    List.prototype.setSize = function (size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function (begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n    };\n    List.prototype.__iterator = function (type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);\n      });\n    };\n    List.prototype.__iterate = function (fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n    List.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n    function isList(maybeList) {\n      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n    }\n    List.isList = isList;\n    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n    var ListPrototype = List.prototype;\n    ListPrototype[IS_LIST_SENTINEL] = true;\n    ListPrototype[DELETE] = ListPrototype.remove;\n    ListPrototype.setIn = MapPrototype.setIn;\n    ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;\n    ListPrototype.update = MapPrototype.update;\n    ListPrototype.updateIn = MapPrototype.updateIn;\n    ListPrototype.mergeIn = MapPrototype.mergeIn;\n    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n    ListPrototype.withMutations = MapPrototype.withMutations;\n    ListPrototype.asMutable = MapPrototype.asMutable;\n    ListPrototype.asImmutable = MapPrototype.asImmutable;\n    ListPrototype.wasAltered = MapPrototype.wasAltered;\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function (ownerID, level, index) {\n      if (index === level ? 1 << level : this.array.length === 0) {\n        return this;\n      }\n      var originIndex = index >>> level & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n    VNode.prototype.removeAfter = function (ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = index - 1 >>> level & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n    var DONE = {};\n    function iterateList(list, reverse) {\n      var left = list._origin;\n      var right = list._capacity;\n      var tailPos = getTailOffset(right);\n      var tail = list._tail;\n      return iterateNodeOrLeaf(list._root, list._level, 0);\n      function iterateNodeOrLeaf(node, level, offset) {\n        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n      }\n      function iterateLeaf(node, offset) {\n        var array = offset === tailPos ? tail && tail.array : node && node.array;\n        var from = offset > left ? 0 : left - offset;\n        var to = right - offset;\n        if (to > SIZE) {\n          to = SIZE;\n        }\n        return function () {\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          return array && array[idx];\n        };\n      }\n      function iterateNode(node, level, offset) {\n        var values;\n        var array = node && node.array;\n        var from = offset > left ? 0 : left - offset >> level;\n        var to = (right - offset >> level) + 1;\n        if (to > SIZE) {\n          to = SIZE;\n        }\n        return function () {\n          do {\n            if (values) {\n              var value = values();\n              if (value !== DONE) {\n                return value;\n              }\n              values = null;\n            }\n            if (from === to) {\n              return DONE;\n            }\n            var idx = reverse ? --to : from++;\n            values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n          } while (true);\n        };\n      }\n    }\n    function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n      var list = Object.create(ListPrototype);\n      list.size = capacity - origin;\n      list._origin = origin;\n      list._capacity = capacity;\n      list._level = level;\n      list._root = root;\n      list._tail = tail;\n      list.__ownerID = ownerID;\n      list.__hash = hash;\n      list.__altered = false;\n      return list;\n    }\n    var EMPTY_LIST;\n    function emptyList() {\n      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n    }\n    function updateList(list, index, value) {\n      index = wrapIndex(list, index);\n      if (index !== index) {\n        return list;\n      }\n      if (index >= list.size || index < 0) {\n        return list.withMutations(function (list) {\n          index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n        });\n      }\n      index += list._origin;\n      var newTail = list._tail;\n      var newRoot = list._root;\n      var didAlter = MakeRef(DID_ALTER);\n      if (index >= getTailOffset(list._capacity)) {\n        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n      } else {\n        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n      }\n      if (!didAlter.value) {\n        return list;\n      }\n      if (list.__ownerID) {\n        list._root = newRoot;\n        list._tail = newTail;\n        list.__hash = undefined;\n        list.__altered = true;\n        return list;\n      }\n      return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n    }\n    function updateVNode(node, ownerID, level, index, value, didAlter) {\n      var idx = index >>> level & MASK;\n      var nodeHas = node && idx < node.array.length;\n      if (!nodeHas && value === undefined) {\n        return node;\n      }\n      var newNode;\n      if (level > 0) {\n        var lowerNode = node && node.array[idx];\n        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n        if (newLowerNode === lowerNode) {\n          return node;\n        }\n        newNode = editableVNode(node, ownerID);\n        newNode.array[idx] = newLowerNode;\n        return newNode;\n      }\n      if (nodeHas && node.array[idx] === value) {\n        return node;\n      }\n      SetRef(didAlter);\n      newNode = editableVNode(node, ownerID);\n      if (value === undefined && idx === newNode.array.length - 1) {\n        newNode.array.pop();\n      } else {\n        newNode.array[idx] = value;\n      }\n      return newNode;\n    }\n    function editableVNode(node, ownerID) {\n      if (ownerID && node && ownerID === node.ownerID) {\n        return node;\n      }\n      return new VNode(node ? node.array.slice() : [], ownerID);\n    }\n    function listNodeFor(list, rawIndex) {\n      if (rawIndex >= getTailOffset(list._capacity)) {\n        return list._tail;\n      }\n      if (rawIndex < 1 << list._level + SHIFT) {\n        var node = list._root;\n        var level = list._level;\n        while (node && level > 0) {\n          node = node.array[rawIndex >>> level & MASK];\n          level -= SHIFT;\n        }\n        return node;\n      }\n    }\n    function setListBounds(list, begin, end) {\n      // Sanitize begin & end using this shorthand for ToInt32(argument)\n      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n      if (begin !== undefined) {\n        begin = begin | 0;\n      }\n      if (end !== undefined) {\n        end = end | 0;\n      }\n      var owner = list.__ownerID || new OwnerID();\n      var oldOrigin = list._origin;\n      var oldCapacity = list._capacity;\n      var newOrigin = oldOrigin + begin;\n      var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n        return list;\n      }\n\n      // If it's going to end after it starts, it's empty.\n      if (newOrigin >= newCapacity) {\n        return list.clear();\n      }\n      var newLevel = list._level;\n      var newRoot = list._root;\n\n      // New origin might need creating a higher root.\n      var offsetShift = 0;\n      while (newOrigin + offsetShift < 0) {\n        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n        newLevel += SHIFT;\n        offsetShift += 1 << newLevel;\n      }\n      if (offsetShift) {\n        newOrigin += offsetShift;\n        oldOrigin += offsetShift;\n        newCapacity += offsetShift;\n        oldCapacity += offsetShift;\n      }\n      var oldTailOffset = getTailOffset(oldCapacity);\n      var newTailOffset = getTailOffset(newCapacity);\n\n      // New size might need creating a higher root.\n      while (newTailOffset >= 1 << newLevel + SHIFT) {\n        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n        newLevel += SHIFT;\n      }\n\n      // Locate or create the new tail.\n      var oldTail = list._tail;\n      var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n      // Merge Tail into tree.\n      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n        newRoot = editableVNode(newRoot, owner);\n        var node = newRoot;\n        for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n          var idx = oldTailOffset >>> level & MASK;\n          node = node.array[idx] = editableVNode(node.array[idx], owner);\n        }\n        node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n      }\n\n      // If the size has been reduced, there's a chance the tail needs to be trimmed.\n      if (newCapacity < oldCapacity) {\n        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n      }\n\n      // If the new origin is within the tail, then we do not need a root.\n      if (newOrigin >= newTailOffset) {\n        newOrigin -= newTailOffset;\n        newCapacity -= newTailOffset;\n        newLevel = SHIFT;\n        newRoot = null;\n        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n        // Otherwise, if the root has been trimmed, garbage collect.\n      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n        offsetShift = 0;\n\n        // Identify the new top root node of the subtree of the old root.\n        while (newRoot) {\n          var beginIndex = newOrigin >>> newLevel & MASK;\n          if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n            break;\n          }\n          if (beginIndex) {\n            offsetShift += (1 << newLevel) * beginIndex;\n          }\n          newLevel -= SHIFT;\n          newRoot = newRoot.array[beginIndex];\n        }\n\n        // Trim the new sides of the new root.\n        if (newRoot && newOrigin > oldOrigin) {\n          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n        }\n        if (newRoot && newTailOffset < oldTailOffset) {\n          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n        }\n        if (offsetShift) {\n          newOrigin -= offsetShift;\n          newCapacity -= offsetShift;\n        }\n      }\n      if (list.__ownerID) {\n        list.size = newCapacity - newOrigin;\n        list._origin = newOrigin;\n        list._capacity = newCapacity;\n        list._level = newLevel;\n        list._root = newRoot;\n        list._tail = newTail;\n        list.__hash = undefined;\n        list.__altered = true;\n        return list;\n      }\n      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n    }\n    function mergeIntoListWith(list, merger, iterables) {\n      var iters = [];\n      var maxSize = 0;\n      for (var ii = 0; ii < iterables.length; ii++) {\n        var value = iterables[ii];\n        var iter = IndexedIterable(value);\n        if (iter.size > maxSize) {\n          maxSize = iter.size;\n        }\n        if (!isIterable(value)) {\n          iter = iter.map(function (v) {\n            return fromJS(v);\n          });\n        }\n        iters.push(iter);\n      }\n      if (maxSize > list.size) {\n        list = list.setSize(maxSize);\n      }\n      return mergeIntoCollectionWith(list, merger, iters);\n    }\n    function getTailOffset(size) {\n      return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n    }\n    createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {\n        var iter = KeyedIterable(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n    OrderedMap.of = function /*...values*/\n    () {\n      return this(arguments);\n    };\n    OrderedMap.prototype.toString = function () {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function (k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n    OrderedMap.prototype.set = function (k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n    OrderedMap.prototype.remove = function (k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n    OrderedMap.prototype.wasAltered = function () {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n    OrderedMap.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return this._list.__iterate(function (entry) {\n        return entry && fn(entry[1], entry[0], this$0);\n      }, reverse);\n    };\n    OrderedMap.prototype.__iterator = function (type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n    OrderedMap.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n    function isOrderedMap(maybeOrderedMap) {\n      return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n    }\n    OrderedMap.isOrderedMap = isOrderedMap;\n    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n    function makeOrderedMap(map, list, ownerID, hash) {\n      var omap = Object.create(OrderedMap.prototype);\n      omap.size = map ? map.size : 0;\n      omap._map = map;\n      omap._list = list;\n      omap.__ownerID = ownerID;\n      omap.__hash = hash;\n      return omap;\n    }\n    var EMPTY_ORDERED_MAP;\n    function emptyOrderedMap() {\n      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n    }\n    function updateOrderedMap(omap, k, v) {\n      var map = omap._map;\n      var list = omap._list;\n      var i = map.get(k);\n      var has = i !== undefined;\n      var newMap;\n      var newList;\n      if (v === NOT_SET) {\n        // removed\n        if (!has) {\n          return omap;\n        }\n        if (list.size >= SIZE && list.size >= map.size * 2) {\n          newList = list.filter(function (entry, idx) {\n            return entry !== undefined && i !== idx;\n          });\n          newMap = newList.toKeyedSeq().map(function (entry) {\n            return entry[0];\n          }).flip().toMap();\n          if (omap.__ownerID) {\n            newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n          }\n        } else {\n          newMap = map.remove(k);\n          newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n        }\n      } else {\n        if (has) {\n          if (v === list.get(i)[1]) {\n            return omap;\n          }\n          newMap = map;\n          newList = list.set(i, [k, v]);\n        } else {\n          newMap = map.set(k, list.size);\n          newList = list.set(list.size, [k, v]);\n        }\n      }\n      if (omap.__ownerID) {\n        omap.size = newMap.size;\n        omap._map = newMap;\n        omap._list = newList;\n        omap.__hash = undefined;\n        return omap;\n      }\n      return makeOrderedMap(newMap, newList);\n    }\n    createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n    ToKeyedSequence.prototype.get = function (key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n    ToKeyedSequence.prototype.has = function (key) {\n      return this._iter.has(key);\n    };\n    ToKeyedSequence.prototype.valueSeq = function () {\n      return this._iter.valueSeq();\n    };\n    ToKeyedSequence.prototype.reverse = function () {\n      var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () {\n          return this$0._iter.toSeq().reverse();\n        };\n      }\n      return reversedSequence;\n    };\n    ToKeyedSequence.prototype.map = function (mapper, context) {\n      var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () {\n          return this$0._iter.toSeq().map(mapper, context);\n        };\n      }\n      return mappedSequence;\n    };\n    ToKeyedSequence.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      var ii;\n      return this._iter.__iterate(this._useKeys ? function (v, k) {\n        return fn(v, k, this$0);\n      } : (ii = reverse ? resolveSize(this) : 0, function (v) {\n        return fn(v, reverse ? --ii : ii++, this$0);\n      }), reverse);\n    };\n    ToKeyedSequence.prototype.__iterator = function (type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n    createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n    ToIndexedSequence.prototype.includes = function (value) {\n      return this._iter.includes(value);\n    };\n    ToIndexedSequence.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function (v) {\n        return fn(v, iterations++, this$0);\n      }, reverse);\n    };\n    ToIndexedSequence.prototype.__iterator = function (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n    ToSetSequence.prototype.has = function (key) {\n      return this._iter.includes(key);\n    };\n    ToSetSequence.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return this._iter.__iterate(function (v) {\n        return fn(v, v, this$0);\n      }, reverse);\n    };\n    ToSetSequence.prototype.__iterator = function (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n    createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n    FromEntriesSequence.prototype.entrySeq = function () {\n      return this._iter.toSeq();\n    };\n    FromEntriesSequence.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);\n        }\n      }, reverse);\n    };\n    FromEntriesSequence.prototype.__iterator = function (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);\n          }\n        }\n      });\n    };\n    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n    function flipFactory(iterable) {\n      var flipSequence = makeSequence(iterable);\n      flipSequence._iter = iterable;\n      flipSequence.size = iterable.size;\n      flipSequence.flip = function () {\n        return iterable;\n      };\n      flipSequence.reverse = function () {\n        var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n        reversedSequence.flip = function () {\n          return iterable.reverse();\n        };\n        return reversedSequence;\n      };\n      flipSequence.has = function (key) {\n        return iterable.includes(key);\n      };\n      flipSequence.includes = function (key) {\n        return iterable.has(key);\n      };\n      flipSequence.cacheResult = cacheResultThrough;\n      flipSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        return iterable.__iterate(function (v, k) {\n          return fn(k, v, this$0) !== false;\n        }, reverse);\n      };\n      flipSequence.__iteratorUncached = function (type, reverse) {\n        if (type === ITERATE_ENTRIES) {\n          var iterator = iterable.__iterator(type, reverse);\n          return new Iterator(function () {\n            var step = iterator.next();\n            if (!step.done) {\n              var k = step.value[0];\n              step.value[0] = step.value[1];\n              step.value[1] = k;\n            }\n            return step;\n          });\n        }\n        return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n      };\n      return flipSequence;\n    }\n    function mapFactory(iterable, mapper, context) {\n      var mappedSequence = makeSequence(iterable);\n      mappedSequence.size = iterable.size;\n      mappedSequence.has = function (key) {\n        return iterable.has(key);\n      };\n      mappedSequence.get = function (key, notSetValue) {\n        var v = iterable.get(key, NOT_SET);\n        return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);\n      };\n      mappedSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        return iterable.__iterate(function (v, k, c) {\n          return fn(mapper.call(context, v, k, c), k, this$0) !== false;\n        }, reverse);\n      };\n      mappedSequence.__iteratorUncached = function (type, reverse) {\n        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);\n        });\n      };\n      return mappedSequence;\n    }\n    function reverseFactory(iterable, useKeys) {\n      var reversedSequence = makeSequence(iterable);\n      reversedSequence._iter = iterable;\n      reversedSequence.size = iterable.size;\n      reversedSequence.reverse = function () {\n        return iterable;\n      };\n      if (iterable.flip) {\n        reversedSequence.flip = function () {\n          var flipSequence = flipFactory(iterable);\n          flipSequence.reverse = function () {\n            return iterable.flip();\n          };\n          return flipSequence;\n        };\n      }\n      reversedSequence.get = function (key, notSetValue) {\n        return iterable.get(useKeys ? key : -1 - key, notSetValue);\n      };\n      reversedSequence.has = function (key) {\n        return iterable.has(useKeys ? key : -1 - key);\n      };\n      reversedSequence.includes = function (value) {\n        return iterable.includes(value);\n      };\n      reversedSequence.cacheResult = cacheResultThrough;\n      reversedSequence.__iterate = function (fn, reverse) {\n        var this$0 = this;\n        return iterable.__iterate(function (v, k) {\n          return fn(v, k, this$0);\n        }, !reverse);\n      };\n      reversedSequence.__iterator = function (type, reverse) {\n        return iterable.__iterator(type, !reverse);\n      };\n      return reversedSequence;\n    }\n    function filterFactory(iterable, predicate, context, useKeys) {\n      var filterSequence = makeSequence(iterable);\n      if (useKeys) {\n        filterSequence.has = function (key) {\n          var v = iterable.get(key, NOT_SET);\n          return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n        };\n        filterSequence.get = function (key, notSetValue) {\n          var v = iterable.get(key, NOT_SET);\n          return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;\n        };\n      }\n      filterSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        var iterations = 0;\n        iterable.__iterate(function (v, k, c) {\n          if (predicate.call(context, v, k, c)) {\n            iterations++;\n            return fn(v, useKeys ? k : iterations - 1, this$0);\n          }\n        }, reverse);\n        return iterations;\n      };\n      filterSequence.__iteratorUncached = function (type, reverse) {\n        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n        var iterations = 0;\n        return new Iterator(function () {\n          while (true) {\n            var step = iterator.next();\n            if (step.done) {\n              return step;\n            }\n            var entry = step.value;\n            var key = entry[0];\n            var value = entry[1];\n            if (predicate.call(context, value, key, iterable)) {\n              return iteratorValue(type, useKeys ? key : iterations++, value, step);\n            }\n          }\n        });\n      };\n      return filterSequence;\n    }\n    function countByFactory(iterable, grouper, context) {\n      var groups = Map().asMutable();\n      iterable.__iterate(function (v, k) {\n        groups.update(grouper.call(context, v, k, iterable), 0, function (a) {\n          return a + 1;\n        });\n      });\n      return groups.asImmutable();\n    }\n    function groupByFactory(iterable, grouper, context) {\n      var isKeyedIter = isKeyed(iterable);\n      var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n      iterable.__iterate(function (v, k) {\n        groups.update(grouper.call(context, v, k, iterable), function (a) {\n          return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;\n        });\n      });\n      var coerce = iterableClass(iterable);\n      return groups.map(function (arr) {\n        return reify(iterable, coerce(arr));\n      });\n    }\n    function sliceFactory(iterable, begin, end, useKeys) {\n      var originalSize = iterable.size;\n\n      // Sanitize begin & end using this shorthand for ToInt32(argument)\n      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n      if (begin !== undefined) {\n        begin = begin | 0;\n      }\n      if (end !== undefined) {\n        if (end === Infinity) {\n          end = originalSize;\n        } else {\n          end = end | 0;\n        }\n      }\n      if (wholeSlice(begin, end, originalSize)) {\n        return iterable;\n      }\n      var resolvedBegin = resolveBegin(begin, originalSize);\n      var resolvedEnd = resolveEnd(end, originalSize);\n\n      // begin or end will be NaN if they were provided as negative numbers and\n      // this iterable's size is unknown. In that case, cache first so there is\n      // a known size and these do not resolve to NaN.\n      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n      }\n\n      // Note: resolvedEnd is undefined when the original sequence's length is\n      // unknown and this slice did not supply an end and should contain all\n      // elements after resolvedBegin.\n      // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n      var resolvedSize = resolvedEnd - resolvedBegin;\n      var sliceSize;\n      if (resolvedSize === resolvedSize) {\n        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n      }\n      var sliceSeq = makeSequence(iterable);\n\n      // If iterable.size is undefined, the size of the realized sliceSeq is\n      // unknown at this point unless the number of items to slice is 0\n      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n        sliceSeq.get = function (index, notSetValue) {\n          index = wrapIndex(this, index);\n          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;\n        };\n      }\n      sliceSeq.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        if (sliceSize === 0) {\n          return 0;\n        }\n        if (reverse) {\n          return this.cacheResult().__iterate(fn, reverse);\n        }\n        var skipped = 0;\n        var isSkipping = true;\n        var iterations = 0;\n        iterable.__iterate(function (v, k) {\n          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n            iterations++;\n            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;\n          }\n        });\n        return iterations;\n      };\n      sliceSeq.__iteratorUncached = function (type, reverse) {\n        if (sliceSize !== 0 && reverse) {\n          return this.cacheResult().__iterator(type, reverse);\n        }\n        // Don't bother instantiating parent iterator if taking 0.\n        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n        var skipped = 0;\n        var iterations = 0;\n        return new Iterator(function () {\n          while (skipped++ < resolvedBegin) {\n            iterator.next();\n          }\n          if (++iterations > sliceSize) {\n            return iteratorDone();\n          }\n          var step = iterator.next();\n          if (useKeys || type === ITERATE_VALUES) {\n            return step;\n          } else if (type === ITERATE_KEYS) {\n            return iteratorValue(type, iterations - 1, undefined, step);\n          } else {\n            return iteratorValue(type, iterations - 1, step.value[1], step);\n          }\n        });\n      };\n      return sliceSeq;\n    }\n    function takeWhileFactory(iterable, predicate, context) {\n      var takeSequence = makeSequence(iterable);\n      takeSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        if (reverse) {\n          return this.cacheResult().__iterate(fn, reverse);\n        }\n        var iterations = 0;\n        iterable.__iterate(function (v, k, c) {\n          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);\n        });\n        return iterations;\n      };\n      takeSequence.__iteratorUncached = function (type, reverse) {\n        var this$0 = this;\n        if (reverse) {\n          return this.cacheResult().__iterator(type, reverse);\n        }\n        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n        var iterating = true;\n        return new Iterator(function () {\n          if (!iterating) {\n            return iteratorDone();\n          }\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var k = entry[0];\n          var v = entry[1];\n          if (!predicate.call(context, v, k, this$0)) {\n            iterating = false;\n            return iteratorDone();\n          }\n          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n        });\n      };\n      return takeSequence;\n    }\n    function skipWhileFactory(iterable, predicate, context, useKeys) {\n      var skipSequence = makeSequence(iterable);\n      skipSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        if (reverse) {\n          return this.cacheResult().__iterate(fn, reverse);\n        }\n        var isSkipping = true;\n        var iterations = 0;\n        iterable.__iterate(function (v, k, c) {\n          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n            iterations++;\n            return fn(v, useKeys ? k : iterations - 1, this$0);\n          }\n        });\n        return iterations;\n      };\n      skipSequence.__iteratorUncached = function (type, reverse) {\n        var this$0 = this;\n        if (reverse) {\n          return this.cacheResult().__iterator(type, reverse);\n        }\n        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n        var skipping = true;\n        var iterations = 0;\n        return new Iterator(function () {\n          var step, k, v;\n          do {\n            step = iterator.next();\n            if (step.done) {\n              if (useKeys || type === ITERATE_VALUES) {\n                return step;\n              } else if (type === ITERATE_KEYS) {\n                return iteratorValue(type, iterations++, undefined, step);\n              } else {\n                return iteratorValue(type, iterations++, step.value[1], step);\n              }\n            }\n            var entry = step.value;\n            k = entry[0];\n            v = entry[1];\n            skipping && (skipping = predicate.call(context, v, k, this$0));\n          } while (skipping);\n          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n        });\n      };\n      return skipSequence;\n    }\n    function concatFactory(iterable, values) {\n      var isKeyedIterable = isKeyed(iterable);\n      var iters = [iterable].concat(values).map(function (v) {\n        if (!isIterable(v)) {\n          v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n        } else if (isKeyedIterable) {\n          v = KeyedIterable(v);\n        }\n        return v;\n      }).filter(function (v) {\n        return v.size !== 0;\n      });\n      if (iters.length === 0) {\n        return iterable;\n      }\n      if (iters.length === 1) {\n        var singleton = iters[0];\n        if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {\n          return singleton;\n        }\n      }\n      var concatSeq = new ArraySeq(iters);\n      if (isKeyedIterable) {\n        concatSeq = concatSeq.toKeyedSeq();\n      } else if (!isIndexed(iterable)) {\n        concatSeq = concatSeq.toSetSeq();\n      }\n      concatSeq = concatSeq.flatten(true);\n      concatSeq.size = iters.reduce(function (sum, seq) {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      }, 0);\n      return concatSeq;\n    }\n    function flattenFactory(iterable, depth, useKeys) {\n      var flatSequence = makeSequence(iterable);\n      flatSequence.__iterateUncached = function (fn, reverse) {\n        var iterations = 0;\n        var stopped = false;\n        function flatDeep(iter, currentDepth) {\n          var this$0 = this;\n          iter.__iterate(function (v, k) {\n            if ((!depth || currentDepth < depth) && isIterable(v)) {\n              flatDeep(v, currentDepth + 1);\n            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n              stopped = true;\n            }\n            return !stopped;\n          }, reverse);\n        }\n        flatDeep(iterable, 0);\n        return iterations;\n      };\n      flatSequence.__iteratorUncached = function (type, reverse) {\n        var iterator = iterable.__iterator(type, reverse);\n        var stack = [];\n        var iterations = 0;\n        return new Iterator(function () {\n          while (iterator) {\n            var step = iterator.next();\n            if (step.done !== false) {\n              iterator = stack.pop();\n              continue;\n            }\n            var v = step.value;\n            if (type === ITERATE_ENTRIES) {\n              v = v[1];\n            }\n            if ((!depth || stack.length < depth) && isIterable(v)) {\n              stack.push(iterator);\n              iterator = v.__iterator(type, reverse);\n            } else {\n              return useKeys ? step : iteratorValue(type, iterations++, v, step);\n            }\n          }\n          return iteratorDone();\n        });\n      };\n      return flatSequence;\n    }\n    function flatMapFactory(iterable, mapper, context) {\n      var coerce = iterableClass(iterable);\n      return iterable.toSeq().map(function (v, k) {\n        return coerce(mapper.call(context, v, k, iterable));\n      }).flatten(true);\n    }\n    function interposeFactory(iterable, separator) {\n      var interposedSequence = makeSequence(iterable);\n      interposedSequence.size = iterable.size && iterable.size * 2 - 1;\n      interposedSequence.__iterateUncached = function (fn, reverse) {\n        var this$0 = this;\n        var iterations = 0;\n        iterable.__iterate(function (v, k) {\n          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;\n        }, reverse);\n        return iterations;\n      };\n      interposedSequence.__iteratorUncached = function (type, reverse) {\n        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n        var iterations = 0;\n        var step;\n        return new Iterator(function () {\n          if (!step || iterations % 2) {\n            step = iterator.next();\n            if (step.done) {\n              return step;\n            }\n          }\n          return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n        });\n      };\n      return interposedSequence;\n    }\n    function sortFactory(iterable, comparator, mapper) {\n      if (!comparator) {\n        comparator = defaultComparator;\n      }\n      var isKeyedIterable = isKeyed(iterable);\n      var index = 0;\n      var entries = iterable.toSeq().map(function (v, k) {\n        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];\n      }).toArray();\n      entries.sort(function (a, b) {\n        return comparator(a[3], b[3]) || a[2] - b[2];\n      }).forEach(isKeyedIterable ? function (v, i) {\n        entries[i].length = 2;\n      } : function (v, i) {\n        entries[i] = v[1];\n      });\n      return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);\n    }\n    function maxFactory(iterable, comparator, mapper) {\n      if (!comparator) {\n        comparator = defaultComparator;\n      }\n      if (mapper) {\n        var entry = iterable.toSeq().map(function (v, k) {\n          return [v, mapper(v, k, iterable)];\n        }).reduce(function (a, b) {\n          return maxCompare(comparator, a[1], b[1]) ? b : a;\n        });\n        return entry && entry[0];\n      } else {\n        return iterable.reduce(function (a, b) {\n          return maxCompare(comparator, a, b) ? b : a;\n        });\n      }\n    }\n    function maxCompare(comparator, a, b) {\n      var comp = comparator(b, a);\n      // b is considered the new max if the comparator declares them equal, but\n      // they are not equal and b is in fact a nullish value.\n      return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n    }\n    function zipWithFactory(keyIter, zipper, iters) {\n      var zipSequence = makeSequence(keyIter);\n      zipSequence.size = new ArraySeq(iters).map(function (i) {\n        return i.size;\n      }).min();\n      // Note: this a generic base implementation of __iterate in terms of\n      // __iterator which may be more generically useful in the future.\n      zipSequence.__iterate = function (fn, reverse) {\n        /* generic:\n        var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n        var step;\n        var iterations = 0;\n        while (!(step = iterator.next()).done) {\n          iterations++;\n          if (fn(step.value[1], step.value[0], this) === false) {\n            break;\n          }\n        }\n        return iterations;\n        */\n        // indexed:\n        var iterator = this.__iterator(ITERATE_VALUES, reverse);\n        var step;\n        var iterations = 0;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n        return iterations;\n      };\n      zipSequence.__iteratorUncached = function (type, reverse) {\n        var iterators = iters.map(function (i) {\n          return i = Iterable(i), getIterator(reverse ? i.reverse() : i);\n        });\n        var iterations = 0;\n        var isDone = false;\n        return new Iterator(function () {\n          var steps;\n          if (!isDone) {\n            steps = iterators.map(function (i) {\n              return i.next();\n            });\n            isDone = steps.some(function (s) {\n              return s.done;\n            });\n          }\n          if (isDone) {\n            return iteratorDone();\n          }\n          return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {\n            return s.value;\n          })));\n        });\n      };\n      return zipSequence;\n    }\n\n    // #pragma Helper Functions\n\n    function reify(iter, seq) {\n      return isSeq(iter) ? seq : iter.constructor(seq);\n    }\n    function validateEntry(entry) {\n      if (entry !== Object(entry)) {\n        throw new TypeError('Expected [K, V] tuple: ' + entry);\n      }\n    }\n    function resolveSize(iter) {\n      assertNotInfinite(iter.size);\n      return ensureSize(iter);\n    }\n    function iterableClass(iterable) {\n      return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;\n    }\n    function makeSequence(iterable) {\n      return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);\n    }\n    function cacheResultThrough() {\n      if (this._iter.cacheResult) {\n        this._iter.cacheResult();\n        this.size = this._iter.size;\n        return this;\n      } else {\n        return Seq.prototype.cacheResult.call(this);\n      }\n    }\n    function defaultComparator(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n    function forceIterator(keyPath) {\n      var iter = getIterator(keyPath);\n      if (!iter) {\n        // Array might not be iterable in this environment, so we need a fallback\n        // to our wrapped type.\n        if (!isArrayLike(keyPath)) {\n          throw new TypeError('Expected iterable or array-like: ' + keyPath);\n        }\n        iter = getIterator(Iterable(keyPath));\n      }\n      return iter;\n    }\n    createClass(Record, KeyedCollection);\n    function Record(defaultValues, name) {\n      var hasInitialized;\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n      return RecordType;\n    }\n    Record.prototype.toString = function () {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function (k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n    Record.prototype.get = function (k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function () {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n    Record.prototype.set = function (k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n    Record.prototype.remove = function (k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n    Record.prototype.wasAltered = function () {\n      return this._map.wasAltered();\n    };\n    Record.prototype.__iterator = function (type, reverse) {\n      var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function (_, k) {\n        return this$0.get(k);\n      }).__iterator(type, reverse);\n    };\n    Record.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function (_, k) {\n        return this$0.get(k);\n      }).__iterate(fn, reverse);\n    };\n    Record.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n    var RecordPrototype = Record.prototype;\n    RecordPrototype[DELETE] = RecordPrototype.remove;\n    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;\n    RecordPrototype.merge = MapPrototype.merge;\n    RecordPrototype.mergeWith = MapPrototype.mergeWith;\n    RecordPrototype.mergeIn = MapPrototype.mergeIn;\n    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n    RecordPrototype.setIn = MapPrototype.setIn;\n    RecordPrototype.update = MapPrototype.update;\n    RecordPrototype.updateIn = MapPrototype.updateIn;\n    RecordPrototype.withMutations = MapPrototype.withMutations;\n    RecordPrototype.asMutable = MapPrototype.asMutable;\n    RecordPrototype.asImmutable = MapPrototype.asImmutable;\n    function makeRecord(likeRecord, map, ownerID) {\n      var record = Object.create(Object.getPrototypeOf(likeRecord));\n      record._map = map;\n      record.__ownerID = ownerID;\n      return record;\n    }\n    function recordName(record) {\n      return record._name || record.constructor.name || 'Record';\n    }\n    function setProps(prototype, names) {\n      try {\n        names.forEach(setProp.bind(undefined, prototype));\n      } catch (error) {\n        // Object.defineProperty failed. Probably IE8.\n      }\n    }\n    function setProp(prototype, name) {\n      Object.defineProperty(prototype, name, {\n        get: function get() {\n          return this.get(name);\n        },\n        set: function set(value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        }\n      });\n    }\n    createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {\n        var iter = SetIterable(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n    Set.of = function /*...values*/\n    () {\n      return this(arguments);\n    };\n    Set.fromKeys = function (value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n    Set.prototype.toString = function () {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function (value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function (value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n    Set.prototype.remove = function (value) {\n      return updateSet(this, this._map.remove(value));\n    };\n    Set.prototype.clear = function () {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function () {\n      var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function (x) {\n        return x.size !== 0;\n      });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function (value) {\n            return set.add(value);\n          });\n        }\n      });\n    };\n    Set.prototype.intersect = function () {\n      var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) {\n        return SetIterable(iter);\n      });\n      var originalSet = this;\n      return this.withMutations(function (set) {\n        originalSet.forEach(function (value) {\n          if (!iters.every(function (iter) {\n            return iter.includes(value);\n          })) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n    Set.prototype.subtract = function () {\n      var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) {\n        return SetIterable(iter);\n      });\n      var originalSet = this;\n      return this.withMutations(function (set) {\n        originalSet.forEach(function (value) {\n          if (iters.some(function (iter) {\n            return iter.includes(value);\n          })) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n    Set.prototype.merge = function () {\n      return this.union.apply(this, arguments);\n    };\n    Set.prototype.mergeWith = function (merger) {\n      var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n    Set.prototype.sort = function (comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n    Set.prototype.sortBy = function (mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n    Set.prototype.wasAltered = function () {\n      return this._map.wasAltered();\n    };\n    Set.prototype.__iterate = function (fn, reverse) {\n      var this$0 = this;\n      return this._map.__iterate(function (_, k) {\n        return fn(k, k, this$0);\n      }, reverse);\n    };\n    Set.prototype.__iterator = function (type, reverse) {\n      return this._map.map(function (_, k) {\n        return k;\n      }).__iterator(type, reverse);\n    };\n    Set.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n    function isSet(maybeSet) {\n      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n    }\n    Set.isSet = isSet;\n    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n    var SetPrototype = Set.prototype;\n    SetPrototype[IS_SET_SENTINEL] = true;\n    SetPrototype[DELETE] = SetPrototype.remove;\n    SetPrototype.mergeDeep = SetPrototype.merge;\n    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n    SetPrototype.withMutations = MapPrototype.withMutations;\n    SetPrototype.asMutable = MapPrototype.asMutable;\n    SetPrototype.asImmutable = MapPrototype.asImmutable;\n    SetPrototype.__empty = emptySet;\n    SetPrototype.__make = makeSet;\n    function updateSet(set, newMap) {\n      if (set.__ownerID) {\n        set.size = newMap.size;\n        set._map = newMap;\n        return set;\n      }\n      return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n    }\n    function makeSet(map, ownerID) {\n      var set = Object.create(SetPrototype);\n      set.size = map ? map.size : 0;\n      set._map = map;\n      set.__ownerID = ownerID;\n      return set;\n    }\n    var EMPTY_SET;\n    function emptySet() {\n      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n    }\n    createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {\n        var iter = SetIterable(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n    OrderedSet.of = function /*...values*/\n    () {\n      return this(arguments);\n    };\n    OrderedSet.fromKeys = function (value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n    OrderedSet.prototype.toString = function () {\n      return this.__toString('OrderedSet {', '}');\n    };\n    function isOrderedSet(maybeOrderedSet) {\n      return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n    }\n    OrderedSet.isOrderedSet = isOrderedSet;\n    var OrderedSetPrototype = OrderedSet.prototype;\n    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n    OrderedSetPrototype.__empty = emptyOrderedSet;\n    OrderedSetPrototype.__make = makeOrderedSet;\n    function makeOrderedSet(map, ownerID) {\n      var set = Object.create(OrderedSetPrototype);\n      set.size = map ? map.size : 0;\n      set._map = map;\n      set.__ownerID = ownerID;\n      return set;\n    }\n    var EMPTY_ORDERED_SET;\n    function emptyOrderedSet() {\n      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n    }\n    createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);\n    }\n    Stack.of = function /*...values*/\n    () {\n      return this(arguments);\n    };\n    Stack.prototype.toString = function () {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function (index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n    Stack.prototype.peek = function () {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function /*...values*/\n    () {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n    Stack.prototype.pushAll = function (iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n    Stack.prototype.pop = function () {\n      return this.slice(1);\n    };\n    Stack.prototype.unshift = function /*...values*/\n    () {\n      return this.push.apply(this, arguments);\n    };\n    Stack.prototype.unshiftAll = function (iter) {\n      return this.pushAll(iter);\n    };\n    Stack.prototype.shift = function () {\n      return this.pop.apply(this, arguments);\n    };\n    Stack.prototype.clear = function () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n    Stack.prototype.slice = function (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function (fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n    Stack.prototype.__iterator = function (type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n    function isStack(maybeStack) {\n      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n    }\n    Stack.isStack = isStack;\n    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n    var StackPrototype = Stack.prototype;\n    StackPrototype[IS_STACK_SENTINEL] = true;\n    StackPrototype.withMutations = MapPrototype.withMutations;\n    StackPrototype.asMutable = MapPrototype.asMutable;\n    StackPrototype.asImmutable = MapPrototype.asImmutable;\n    StackPrototype.wasAltered = MapPrototype.wasAltered;\n    function makeStack(size, head, ownerID, hash) {\n      var map = Object.create(StackPrototype);\n      map.size = size;\n      map._head = head;\n      map.__ownerID = ownerID;\n      map.__hash = hash;\n      map.__altered = false;\n      return map;\n    }\n    var EMPTY_STACK;\n    function emptyStack() {\n      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n    }\n\n    /**\n     * Contributes additional methods to a constructor\n     */\n    function mixin(ctor, methods) {\n      var keyCopier = function keyCopier(key) {\n        ctor.prototype[key] = methods[key];\n      };\n      Object.keys(methods).forEach(keyCopier);\n      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n      return ctor;\n    }\n    Iterable.Iterator = Iterator;\n    mixin(Iterable, {\n      // ### Conversion to other types\n\n      toArray: function toArray() {\n        assertNotInfinite(this.size);\n        var array = new Array(this.size || 0);\n        this.valueSeq().__iterate(function (v, i) {\n          array[i] = v;\n        });\n        return array;\n      },\n      toIndexedSeq: function toIndexedSeq() {\n        return new ToIndexedSequence(this);\n      },\n      toJS: function toJS() {\n        return this.toSeq().map(function (value) {\n          return value && typeof value.toJS === 'function' ? value.toJS() : value;\n        }).__toJS();\n      },\n      toJSON: function toJSON() {\n        return this.toSeq().map(function (value) {\n          return value && typeof value.toJSON === 'function' ? value.toJSON() : value;\n        }).__toJS();\n      },\n      toKeyedSeq: function toKeyedSeq() {\n        return new ToKeyedSequence(this, true);\n      },\n      toMap: function toMap() {\n        // Use Late Binding here to solve the circular dependency.\n        return Map(this.toKeyedSeq());\n      },\n      toObject: function toObject() {\n        assertNotInfinite(this.size);\n        var object = {};\n        this.__iterate(function (v, k) {\n          object[k] = v;\n        });\n        return object;\n      },\n      toOrderedMap: function toOrderedMap() {\n        // Use Late Binding here to solve the circular dependency.\n        return OrderedMap(this.toKeyedSeq());\n      },\n      toOrderedSet: function toOrderedSet() {\n        // Use Late Binding here to solve the circular dependency.\n        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n      },\n      toSet: function toSet() {\n        // Use Late Binding here to solve the circular dependency.\n        return Set(isKeyed(this) ? this.valueSeq() : this);\n      },\n      toSetSeq: function toSetSeq() {\n        return new ToSetSequence(this);\n      },\n      toSeq: function toSeq() {\n        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n      },\n      toStack: function toStack() {\n        // Use Late Binding here to solve the circular dependency.\n        return Stack(isKeyed(this) ? this.valueSeq() : this);\n      },\n      toList: function toList() {\n        // Use Late Binding here to solve the circular dependency.\n        return List(isKeyed(this) ? this.valueSeq() : this);\n      },\n      // ### Common JavaScript methods and properties\n\n      toString: function toString() {\n        return '[Iterable]';\n      },\n      __toString: function __toString(head, tail) {\n        if (this.size === 0) {\n          return head + tail;\n        }\n        return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n      },\n      // ### ES6 Collection methods (ES6 Array and Map)\n\n      concat: function concat() {\n        var values = SLICE$0.call(arguments, 0);\n        return reify(this, concatFactory(this, values));\n      },\n      includes: function includes(searchValue) {\n        return this.some(function (value) {\n          return is(value, searchValue);\n        });\n      },\n      entries: function entries() {\n        return this.__iterator(ITERATE_ENTRIES);\n      },\n      every: function every(predicate, context) {\n        assertNotInfinite(this.size);\n        var returnValue = true;\n        this.__iterate(function (v, k, c) {\n          if (!predicate.call(context, v, k, c)) {\n            returnValue = false;\n            return false;\n          }\n        });\n        return returnValue;\n      },\n      filter: function filter(predicate, context) {\n        return reify(this, filterFactory(this, predicate, context, true));\n      },\n      find: function find(predicate, context, notSetValue) {\n        var entry = this.findEntry(predicate, context);\n        return entry ? entry[1] : notSetValue;\n      },\n      forEach: function forEach(sideEffect, context) {\n        assertNotInfinite(this.size);\n        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n      },\n      join: function join(separator) {\n        assertNotInfinite(this.size);\n        separator = separator !== undefined ? '' + separator : ',';\n        var joined = '';\n        var isFirst = true;\n        this.__iterate(function (v) {\n          isFirst ? isFirst = false : joined += separator;\n          joined += v !== null && v !== undefined ? v.toString() : '';\n        });\n        return joined;\n      },\n      keys: function keys() {\n        return this.__iterator(ITERATE_KEYS);\n      },\n      map: function map(mapper, context) {\n        return reify(this, mapFactory(this, mapper, context));\n      },\n      reduce: function reduce(reducer, initialReduction, context) {\n        assertNotInfinite(this.size);\n        var reduction;\n        var useFirst;\n        if (arguments.length < 2) {\n          useFirst = true;\n        } else {\n          reduction = initialReduction;\n        }\n        this.__iterate(function (v, k, c) {\n          if (useFirst) {\n            useFirst = false;\n            reduction = v;\n          } else {\n            reduction = reducer.call(context, reduction, v, k, c);\n          }\n        });\n        return reduction;\n      },\n      reduceRight: function reduceRight(reducer, initialReduction, context) {\n        var reversed = this.toKeyedSeq().reverse();\n        return reversed.reduce.apply(reversed, arguments);\n      },\n      reverse: function reverse() {\n        return reify(this, reverseFactory(this, true));\n      },\n      slice: function slice(begin, end) {\n        return reify(this, sliceFactory(this, begin, end, true));\n      },\n      some: function some(predicate, context) {\n        return !this.every(not(predicate), context);\n      },\n      sort: function sort(comparator) {\n        return reify(this, sortFactory(this, comparator));\n      },\n      values: function values() {\n        return this.__iterator(ITERATE_VALUES);\n      },\n      // ### More sequential methods\n\n      butLast: function butLast() {\n        return this.slice(0, -1);\n      },\n      isEmpty: function isEmpty() {\n        return this.size !== undefined ? this.size === 0 : !this.some(function () {\n          return true;\n        });\n      },\n      count: function count(predicate, context) {\n        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n      },\n      countBy: function countBy(grouper, context) {\n        return countByFactory(this, grouper, context);\n      },\n      equals: function equals(other) {\n        return deepEqual(this, other);\n      },\n      entrySeq: function entrySeq() {\n        var iterable = this;\n        if (iterable._cache) {\n          // We cache as an entries array, so we can just return the cache!\n          return new ArraySeq(iterable._cache);\n        }\n        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n        entriesSequence.fromEntrySeq = function () {\n          return iterable.toSeq();\n        };\n        return entriesSequence;\n      },\n      filterNot: function filterNot(predicate, context) {\n        return this.filter(not(predicate), context);\n      },\n      findEntry: function findEntry(predicate, context, notSetValue) {\n        var found = notSetValue;\n        this.__iterate(function (v, k, c) {\n          if (predicate.call(context, v, k, c)) {\n            found = [k, v];\n            return false;\n          }\n        });\n        return found;\n      },\n      findKey: function findKey(predicate, context) {\n        var entry = this.findEntry(predicate, context);\n        return entry && entry[0];\n      },\n      findLast: function findLast(predicate, context, notSetValue) {\n        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n      },\n      findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n      },\n      findLastKey: function findLastKey(predicate, context) {\n        return this.toKeyedSeq().reverse().findKey(predicate, context);\n      },\n      first: function first() {\n        return this.find(returnTrue);\n      },\n      flatMap: function flatMap(mapper, context) {\n        return reify(this, flatMapFactory(this, mapper, context));\n      },\n      flatten: function flatten(depth) {\n        return reify(this, flattenFactory(this, depth, true));\n      },\n      fromEntrySeq: function fromEntrySeq() {\n        return new FromEntriesSequence(this);\n      },\n      get: function get(searchKey, notSetValue) {\n        return this.find(function (_, key) {\n          return is(key, searchKey);\n        }, undefined, notSetValue);\n      },\n      getIn: function getIn(searchKeyPath, notSetValue) {\n        var nested = this;\n        // Note: in an ES6 environment, we would prefer:\n        // for (var key of searchKeyPath) {\n        var iter = forceIterator(searchKeyPath);\n        var step;\n        while (!(step = iter.next()).done) {\n          var key = step.value;\n          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n          if (nested === NOT_SET) {\n            return notSetValue;\n          }\n        }\n        return nested;\n      },\n      groupBy: function groupBy(grouper, context) {\n        return groupByFactory(this, grouper, context);\n      },\n      has: function has(searchKey) {\n        return this.get(searchKey, NOT_SET) !== NOT_SET;\n      },\n      hasIn: function hasIn(searchKeyPath) {\n        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n      },\n      isSubset: function isSubset(iter) {\n        iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n        return this.every(function (value) {\n          return iter.includes(value);\n        });\n      },\n      isSuperset: function isSuperset(iter) {\n        iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n        return iter.isSubset(this);\n      },\n      keyOf: function keyOf(searchValue) {\n        return this.findKey(function (value) {\n          return is(value, searchValue);\n        });\n      },\n      keySeq: function keySeq() {\n        return this.toSeq().map(keyMapper).toIndexedSeq();\n      },\n      last: function last() {\n        return this.toSeq().reverse().first();\n      },\n      lastKeyOf: function lastKeyOf(searchValue) {\n        return this.toKeyedSeq().reverse().keyOf(searchValue);\n      },\n      max: function max(comparator) {\n        return maxFactory(this, comparator);\n      },\n      maxBy: function maxBy(mapper, comparator) {\n        return maxFactory(this, comparator, mapper);\n      },\n      min: function min(comparator) {\n        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n      },\n      minBy: function minBy(mapper, comparator) {\n        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n      },\n      rest: function rest() {\n        return this.slice(1);\n      },\n      skip: function skip(amount) {\n        return this.slice(Math.max(0, amount));\n      },\n      skipLast: function skipLast(amount) {\n        return reify(this, this.toSeq().reverse().skip(amount).reverse());\n      },\n      skipWhile: function skipWhile(predicate, context) {\n        return reify(this, skipWhileFactory(this, predicate, context, true));\n      },\n      skipUntil: function skipUntil(predicate, context) {\n        return this.skipWhile(not(predicate), context);\n      },\n      sortBy: function sortBy(mapper, comparator) {\n        return reify(this, sortFactory(this, comparator, mapper));\n      },\n      take: function take(amount) {\n        return this.slice(0, Math.max(0, amount));\n      },\n      takeLast: function takeLast(amount) {\n        return reify(this, this.toSeq().reverse().take(amount).reverse());\n      },\n      takeWhile: function takeWhile(predicate, context) {\n        return reify(this, takeWhileFactory(this, predicate, context));\n      },\n      takeUntil: function takeUntil(predicate, context) {\n        return this.takeWhile(not(predicate), context);\n      },\n      valueSeq: function valueSeq() {\n        return this.toIndexedSeq();\n      },\n      // ### Hashable Object\n\n      hashCode: function hashCode() {\n        return this.__hash || (this.__hash = hashIterable(this));\n      }\n\n      // ### Internal\n\n      // abstract __iterate(fn, reverse)\n\n      // abstract __iterator(type, reverse)\n    });\n\n    // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n    // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n    // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n    // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n    var IterablePrototype = Iterable.prototype;\n    IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n    IterablePrototype.__toJS = IterablePrototype.toArray;\n    IterablePrototype.__toStringMapper = quoteString;\n    IterablePrototype.inspect = IterablePrototype.toSource = function () {\n      return this.toString();\n    };\n    IterablePrototype.chain = IterablePrototype.flatMap;\n    IterablePrototype.contains = IterablePrototype.includes;\n    mixin(KeyedIterable, {\n      // ### More sequential methods\n\n      flip: function flip() {\n        return reify(this, flipFactory(this));\n      },\n      mapEntries: function mapEntries(mapper, context) {\n        var this$0 = this;\n        var iterations = 0;\n        return reify(this, this.toSeq().map(function (v, k) {\n          return mapper.call(context, [k, v], iterations++, this$0);\n        }).fromEntrySeq());\n      },\n      mapKeys: function mapKeys(mapper, context) {\n        var this$0 = this;\n        return reify(this, this.toSeq().flip().map(function (k, v) {\n          return mapper.call(context, k, v, this$0);\n        }).flip());\n      }\n    });\n    var KeyedIterablePrototype = KeyedIterable.prototype;\n    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n    KeyedIterablePrototype.__toStringMapper = function (v, k) {\n      return JSON.stringify(k) + ': ' + quoteString(v);\n    };\n    mixin(IndexedIterable, {\n      // ### Conversion to other types\n\n      toKeyedSeq: function toKeyedSeq() {\n        return new ToKeyedSequence(this, false);\n      },\n      // ### ES6 Collection methods (ES6 Array and Map)\n\n      filter: function filter(predicate, context) {\n        return reify(this, filterFactory(this, predicate, context, false));\n      },\n      findIndex: function findIndex(predicate, context) {\n        var entry = this.findEntry(predicate, context);\n        return entry ? entry[0] : -1;\n      },\n      indexOf: function indexOf(searchValue) {\n        var key = this.keyOf(searchValue);\n        return key === undefined ? -1 : key;\n      },\n      lastIndexOf: function lastIndexOf(searchValue) {\n        var key = this.lastKeyOf(searchValue);\n        return key === undefined ? -1 : key;\n      },\n      reverse: function reverse() {\n        return reify(this, reverseFactory(this, false));\n      },\n      slice: function slice(begin, end) {\n        return reify(this, sliceFactory(this, begin, end, false));\n      },\n      splice: function splice(index, removeNum /*, ...values*/) {\n        var numArgs = arguments.length;\n        removeNum = Math.max(removeNum | 0, 0);\n        if (numArgs === 0 || numArgs === 2 && !removeNum) {\n          return this;\n        }\n        // If index is negative, it should resolve relative to the size of the\n        // collection. However size may be expensive to compute if not cached, so\n        // only call count() if the number is in fact negative.\n        index = resolveBegin(index, index < 0 ? this.count() : this.size);\n        var spliced = this.slice(0, index);\n        return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n      },\n      // ### More collection methods\n\n      findLastIndex: function findLastIndex(predicate, context) {\n        var entry = this.findLastEntry(predicate, context);\n        return entry ? entry[0] : -1;\n      },\n      first: function first() {\n        return this.get(0);\n      },\n      flatten: function flatten(depth) {\n        return reify(this, flattenFactory(this, depth, false));\n      },\n      get: function get(index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {\n          return key === index;\n        }, undefined, notSetValue);\n      },\n      has: function has(index) {\n        index = wrapIndex(this, index);\n        return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n      },\n      interpose: function interpose(separator) {\n        return reify(this, interposeFactory(this, separator));\n      },\n      interleave: function interleave( /*...iterables*/\n      ) {\n        var iterables = [this].concat(arrCopy(arguments));\n        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n        var interleaved = zipped.flatten(true);\n        if (zipped.size) {\n          interleaved.size = zipped.size * iterables.length;\n        }\n        return reify(this, interleaved);\n      },\n      keySeq: function keySeq() {\n        return Range(0, this.size);\n      },\n      last: function last() {\n        return this.get(-1);\n      },\n      skipWhile: function skipWhile(predicate, context) {\n        return reify(this, skipWhileFactory(this, predicate, context, false));\n      },\n      zip: function zip( /*, ...iterables */\n      ) {\n        var iterables = [this].concat(arrCopy(arguments));\n        return reify(this, zipWithFactory(this, defaultZipper, iterables));\n      },\n      zipWith: function zipWith(zipper /*, ...iterables */) {\n        var iterables = arrCopy(arguments);\n        iterables[0] = this;\n        return reify(this, zipWithFactory(this, zipper, iterables));\n      }\n    });\n    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n    mixin(SetIterable, {\n      // ### ES6 Collection methods (ES6 Array and Map)\n\n      get: function get(value, notSetValue) {\n        return this.has(value) ? value : notSetValue;\n      },\n      includes: function includes(value) {\n        return this.has(value);\n      },\n      // ### More sequential methods\n\n      keySeq: function keySeq() {\n        return this.valueSeq();\n      }\n    });\n    SetIterable.prototype.has = IterablePrototype.includes;\n    SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n    // Mixin subclasses\n\n    mixin(KeyedSeq, KeyedIterable.prototype);\n    mixin(IndexedSeq, IndexedIterable.prototype);\n    mixin(SetSeq, SetIterable.prototype);\n    mixin(KeyedCollection, KeyedIterable.prototype);\n    mixin(IndexedCollection, IndexedIterable.prototype);\n    mixin(SetCollection, SetIterable.prototype);\n\n    // #pragma Helper functions\n\n    function keyMapper(v, k) {\n      return k;\n    }\n    function entryMapper(v, k) {\n      return [k, v];\n    }\n    function not(predicate) {\n      return function () {\n        return !predicate.apply(this, arguments);\n      };\n    }\n    function neg(predicate) {\n      return function () {\n        return -predicate.apply(this, arguments);\n      };\n    }\n    function quoteString(value) {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    }\n    function defaultZipper() {\n      return arrCopy(arguments);\n    }\n    function defaultNegComparator(a, b) {\n      return a < b ? 1 : a > b ? -1 : 0;\n    }\n    function hashIterable(iterable) {\n      if (iterable.size === Infinity) {\n        return 0;\n      }\n      var ordered = isOrdered(iterable);\n      var keyed = isKeyed(iterable);\n      var h = ordered ? 1 : 0;\n      var size = iterable.__iterate(keyed ? ordered ? function (v, k) {\n        h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n      } : function (v, k) {\n        h = h + hashMerge(hash(v), hash(k)) | 0;\n      } : ordered ? function (v) {\n        h = 31 * h + hash(v) | 0;\n      } : function (v) {\n        h = h + hash(v) | 0;\n      });\n      return murmurHashOfSize(size, h);\n    }\n    function murmurHashOfSize(size, h) {\n      h = imul(h, 0xCC9E2D51);\n      h = imul(h << 15 | h >>> -15, 0x1B873593);\n      h = imul(h << 13 | h >>> -13, 5);\n      h = (h + 0xE6546B64 | 0) ^ size;\n      h = imul(h ^ h >>> 16, 0x85EBCA6B);\n      h = imul(h ^ h >>> 13, 0xC2B2AE35);\n      h = smi(h ^ h >>> 16);\n      return h;\n    }\n    function hashMerge(a, b) {\n      return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n    }\n    var Immutable = {\n      Iterable: Iterable,\n      Seq: Seq,\n      Collection: Collection,\n      Map: Map,\n      OrderedMap: OrderedMap,\n      List: List,\n      Stack: Stack,\n      Set: Set,\n      OrderedSet: OrderedSet,\n      Record: Record,\n      Range: Range,\n      Repeat: Repeat,\n      is: is,\n      fromJS: fromJS\n    };\n    return Immutable;\n  });\n})(immutable);\nvar immutableExports = immutable.exports;\n\nvar Record = immutableExports.Record;\nvar MonitorRecord = Record({\n  id: null,\n  // Block Id\n  /** Present only if the monitor is sprite-specific, such as x position */\n  spriteName: null,\n  /** Present only if the monitor is sprite-specific, such as x position */\n  targetId: null,\n  opcode: null,\n  value: null,\n  params: null,\n  mode: 'default',\n  sliderMin: 0,\n  sliderMax: 100,\n  isDiscrete: true,\n  x: null,\n  // (x: null, y: null) Indicates that the monitor should be auto-positioned\n  y: null,\n  width: 0,\n  height: 0,\n  visible: true\n});\nvar monitorRecord = MonitorRecord;\n\nvar blocksExecuteCache = {};\n\n/**\n * @fileoverview\n * Access point for private method shared between blocks.js and execute.js for\n * caching execute information.\n */\nvar hasRequiredBlocksExecuteCache;\nfunction requireBlocksExecuteCache() {\n  if (hasRequiredBlocksExecuteCache) return blocksExecuteCache;\n  hasRequiredBlocksExecuteCache = 1;\n  /**\n   * A private method shared with execute to build an object containing the block\n   * information execute needs and that is reset when other cached Blocks info is\n   * reset.\n   * @param {Blocks} blocks Blocks containing the expected blockId\n   * @param {string} blockId blockId for the desired execute cache\n   */\n  blocksExecuteCache.getCached = function () {\n    throw new Error('blocks.js has not initialized BlocksExecuteCache');\n  };\n\n  // Call after the default throwing getCached is assigned for Blocks to replace.\n  requireBlocks();\n  return blocksExecuteCache;\n}\n\nvar blocksRuntimeCache = {};\n\nvar hasRequiredBlocksRuntimeCache;\nfunction requireBlocksRuntimeCache() {\n  if (hasRequiredBlocksRuntimeCache) return blocksRuntimeCache;\n  hasRequiredBlocksRuntimeCache = 1;\n  /**\n   * A set of cached data about the top block of a script.\n   * @param {Blocks} container - Container holding the block and related data\n   * @param {string} blockId - Id for whose block data is cached in this instance\n   */\n  var RuntimeScriptCache = /*#__PURE__*/_createClass(function RuntimeScriptCache(container, blockId) {\n    _classCallCheck(this, RuntimeScriptCache);\n    /**\n     * Container with block data for blockId.\n     * @type {Blocks}\n     */\n    this.container = container;\n\n    /**\n     * ID for block this instance caches.\n     * @type {string}\n     */\n    this.blockId = blockId;\n    var block = container.getBlock(blockId);\n    var fields = container.getFields(block);\n\n    /**\n     * Formatted fields or fields of input blocks ready for comparison in\n     * runtime.\n     *\n     * This is a clone of parts of the targeted blocks. Changes to these\n     * clones are limited to copies under RuntimeScriptCache and will not\n     * appear in the original blocks in their container. This copy is\n     * modified changing the case of strings to uppercase. These uppercase\n     * values will be compared later by the VM.\n     * @type {object}\n     */\n    this.fieldsOfInputs = Object.assign({}, fields);\n    if (Object.keys(fields).length === 0) {\n      var inputs = container.getInputs(block);\n      for (var input in inputs) {\n        if (!Object.prototype.hasOwnProperty.call(inputs, input)) continue;\n        var id = inputs[input].block;\n        var inputBlock = container.getBlock(id);\n        var inputFields = container.getFields(inputBlock);\n        Object.assign(this.fieldsOfInputs, inputFields);\n      }\n    }\n    for (var key in this.fieldsOfInputs) {\n      var field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);\n      if (field.value.toUpperCase) {\n        field.value = field.value.toUpperCase();\n      }\n    }\n  });\n  /**\n   * Get an array of scripts from a block container prefiltered to match opcode.\n   * @param {Blocks} container - Container of blocks\n   * @param {string} opcode - Opcode to filter top blocks by\n   */\n  blocksRuntimeCache.getScripts = function () {\n    throw new Error('blocks.js has not initialized BlocksRuntimeCache');\n  };\n\n  /**\n   * Exposed RuntimeScriptCache class used by integration in blocks.js.\n   * @private\n   */\n  blocksRuntimeCache._RuntimeScriptCache = RuntimeScriptCache;\n  requireBlocks();\n  return blocksRuntimeCache;\n}\n\nvar uid$2 = uid_1;\nvar xmlEscape$1 = xmlEscape_1;\nvar Variable$1 = /*#__PURE__*/function () {\n  /**\n   * @param {string} id Id of the variable.\n   * @param {string} name Name of the variable.\n   * @param {string} type Type of the variable, one of '' or 'list'\n   * @param {boolean} isCloud Whether the variable is stored in the cloud.\n   * @constructor\n   */\n  function Variable(id, name, type, isCloud) {\n    _classCallCheck(this, Variable);\n    this.id = id || uid$2();\n    this.name = name;\n    this.type = type;\n    this.isCloud = isCloud;\n    switch (this.type) {\n      case Variable.SCALAR_TYPE:\n        this.value = 0;\n        break;\n      case Variable.LIST_TYPE:\n        this.value = [];\n        break;\n      case Variable.BROADCAST_MESSAGE_TYPE:\n        this.value = this.name;\n        break;\n      default:\n        throw new Error(\"Invalid variable type: \".concat(this.type));\n    }\n  }\n  return _createClass(Variable, [{\n    key: \"toXML\",\n    value: function toXML(isLocal) {\n      isLocal = isLocal === true;\n      return \"<variable type=\\\"\".concat(this.type, \"\\\" id=\\\"\").concat(this.id, \"\\\" islocal=\\\"\").concat(isLocal, \"\\\" iscloud=\\\"\").concat(this.isCloud, \"\\\">\").concat(xmlEscape$1(this.name), \"</variable>\");\n    }\n\n    /**\n     * Type representation for scalar variables.\n     * This is currently represented as ''\n     * for compatibility with blockly.\n     * @const {string}\n     */\n  }], [{\n    key: \"SCALAR_TYPE\",\n    get: function get() {\n      return '';\n    }\n\n    /**\n     * Type representation for list variables.\n     * @const {string}\n     */\n  }, {\n    key: \"LIST_TYPE\",\n    get: function get() {\n      return 'list';\n    }\n\n    /**\n     * Type representation for list variables.\n     * @const {string}\n     */\n  }, {\n    key: \"BROADCAST_MESSAGE_TYPE\",\n    get: function get() {\n      return 'broadcast_msg';\n    }\n  }]);\n}();\nvar variable = Variable$1;\n\n/**\n * Returns a string representing a unique id for a monitored block\n * where a single reporter block can have more than one monitor\n * (and therefore more than one monitor block) associated\n * with it (e.g. when reporter blocks have inputs).\n * @param {string} baseId The base id to use for the different monitor blocks\n * @param {object} fields The monitor block's fields object.\n */\n\n// TODO this function should eventually be the single place where all monitor\n// IDs are obtained given an opcode for the reporter block and the list of\n// selected parameters.\nvar getMonitorIdForBlockWithArgs = function getMonitorIdForBlockWithArgs(id, fields) {\n  var fieldString = '';\n  for (var fieldKey in fields) {\n    var fieldValue = fields[fieldKey].value;\n    if (fieldKey === 'CURRENTMENU') {\n      // The 'sensing_current' block has field values in all caps.\n      // However, when importing from scratch 2.0, these\n      // could have gotten imported as lower case field values.\n      // Normalize the field value here so that we don't ever\n      // end up with a different monitor ID representing the same\n      // block configuration\n      // Note: we are not doing this for every block field that comes into\n      // this function so as not to make the faulty assumption that block\n      // field values coming in would be unique after being made lower case\n      fieldValue = fieldValue.toLowerCase();\n    }\n    fieldString += \"_\".concat(fieldValue);\n  }\n  return \"\".concat(id).concat(fieldString);\n};\nvar getMonitorId = getMonitorIdForBlockWithArgs;\n\nfunction _createForOfIteratorHelper$5(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$5(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray$5(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$5(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0; } }\nfunction _arrayLikeToArray$5(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar blocks;\nvar hasRequiredBlocks;\nfunction requireBlocks() {\n  if (hasRequiredBlocks) return blocks;\n  hasRequiredBlocks = 1;\n  var adapter = adapter_1;\n  var mutationAdapter = mutationAdapter$1;\n  var xmlEscape = xmlEscape_1;\n  var MonitorRecord = monitorRecord;\n  var Clone = clone;\n  var Map = immutableExports.Map;\n  var BlocksExecuteCache = requireBlocksExecuteCache();\n  var BlocksRuntimeCache = requireBlocksRuntimeCache();\n  var log = log$3;\n  var Variable = variable;\n  var getMonitorIdForBlockWithArgs = getMonitorId;\n\n  /**\n   * @fileoverview\n   * Store and mutate the VM block representation,\n   * and handle updates from Scratch Blocks events.\n   */\n\n  /**\n   * Create a block container.\n   * @param {Runtime} runtime The runtime this block container operates within\n   * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container\n   * should not request glows. This does not affect glows when clicking on a block to execute it.\n   */\n  var Blocks = /*#__PURE__*/function () {\n    function Blocks(runtime, optNoGlow) {\n      _classCallCheck(this, Blocks);\n      this.runtime = runtime;\n\n      /**\n       * All blocks in the workspace.\n       * Keys are block IDs, values are metadata about the block.\n       * @type {Object.<string, Object>}\n       */\n      this._blocks = {};\n\n      /**\n       * All top-level scripts in the workspace.\n       * A list of block IDs that represent scripts (i.e., first block in script).\n       * @type {Array.<String>}\n       */\n      this._scripts = [];\n\n      /**\n       * Runtime Cache\n       * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}\n       * @private\n       */\n      Object.defineProperty(this, '_cache', {\n        writable: true,\n        enumerable: false\n      });\n      this._cache = {\n        /**\n         * Cache block inputs by block id\n         * @type {object.<string, !Array.<object>>}\n         */\n        inputs: {},\n        /**\n         * Cache procedure Param Names by block id\n         * @type {object.<string, ?Array.<string>>}\n         */\n        procedureParamNames: {},\n        /**\n         * Cache procedure definitions by block id\n         * @type {object.<string, ?string>}\n         */\n        procedureDefinitions: {},\n        /**\n         * A cache for execute to use and store on. Only available to\n         * execute.\n         * @type {object.<string, object>}\n         */\n        _executeCached: {},\n        /**\n         * A cache of block IDs and targets to start threads on as they are\n         * actively monitored.\n         * @type {Array<{blockId: string, target: Target}>}\n         */\n        _monitored: null,\n        /**\n         * A cache of hat opcodes to collection of theads to execute.\n         * @type {object.<string, object>}\n         */\n        scripts: {}\n      };\n\n      /**\n       * Flag which indicates that blocks in this container should not glow.\n       * Blocks will still glow when clicked on, but this flag is used to control\n       * whether the blocks in this container can request a glow as part of\n       * a running stack. E.g. the flyout block container and the monitor block container\n       * should not be able to request a glow, but blocks containers belonging to\n       * sprites should.\n       * @type {boolean}\n       */\n      this.forceNoGlow = optNoGlow || false;\n    }\n\n    /**\n     * Blockly inputs that represent statements/branch.\n     * are prefixed with this string.\n     * @const{string}\n     */\n    return _createClass(Blocks, [{\n      key: \"getBlock\",\n      value:\n      /**\n       * Provide an object with metadata for the requested block ID.\n       * @param {!string} blockId ID of block we have stored.\n       * @return {?object} Metadata about the block, if it exists.\n       */\n      function getBlock(blockId) {\n        return this._blocks[blockId];\n      }\n\n      /**\n       * Get all known top-level blocks that start scripts.\n       * @return {Array.<string>} List of block IDs.\n       */\n    }, {\n      key: \"getScripts\",\n      value: function getScripts() {\n        return this._scripts;\n      }\n\n      /**\n        * Get the next block for a particular block\n        * @param {?string} id ID of block to get the next block for\n        * @return {?string} ID of next block in the sequence\n        */\n    }, {\n      key: \"getNextBlock\",\n      value: function getNextBlock(id) {\n        var block = this._blocks[id];\n        return typeof block === 'undefined' ? null : block.next;\n      }\n\n      /**\n       * Get the branch for a particular C-shaped block.\n       * @param {?string} id ID for block to get the branch for.\n       * @param {?number} branchNum Which branch to select (e.g. for if-else).\n       * @return {?string} ID of block in the branch.\n       */\n    }, {\n      key: \"getBranch\",\n      value: function getBranch(id, branchNum) {\n        var block = this._blocks[id];\n        if (typeof block === 'undefined') return null;\n        if (!branchNum) branchNum = 1;\n        var inputName = Blocks.BRANCH_INPUT_PREFIX;\n        if (branchNum > 1) {\n          inputName += branchNum;\n        }\n\n        // Empty C-block?\n        var input = block.inputs[inputName];\n        return typeof input === 'undefined' ? null : input.block;\n      }\n\n      /**\n       * Get the opcode for a particular block\n       * @param {?object} block The block to query\n       * @return {?string} the opcode corresponding to that block\n       */\n    }, {\n      key: \"getOpcode\",\n      value: function getOpcode(block) {\n        return typeof block === 'undefined' ? null : block.opcode;\n      }\n\n      /**\n       * Get all fields and their values for a block.\n       * @param {?object} block The block to query.\n       * @return {?object} All fields and their values.\n       */\n    }, {\n      key: \"getFields\",\n      value: function getFields(block) {\n        return typeof block === 'undefined' ? null : block.fields;\n      }\n\n      /**\n       * Get all non-branch inputs for a block.\n       * @param {?object} block the block to query.\n       * @return {?Array.<object>} All non-branch inputs and their associated blocks.\n       */\n    }, {\n      key: \"getInputs\",\n      value: function getInputs(block) {\n        if (typeof block === 'undefined') return null;\n        var inputs = this._cache.inputs[block.id];\n        if (typeof inputs !== 'undefined') {\n          return inputs;\n        }\n        inputs = {};\n        for (var input in block.inputs) {\n          // Ignore blocks prefixed with branch prefix.\n          if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {\n            inputs[input] = block.inputs[input];\n          }\n        }\n        this._cache.inputs[block.id] = inputs;\n        return inputs;\n      }\n\n      /**\n       * Get mutation data for a block.\n       * @param {?object} block The block to query.\n       * @return {?object} Mutation for the block.\n       */\n    }, {\n      key: \"getMutation\",\n      value: function getMutation(block) {\n        return typeof block === 'undefined' ? null : block.mutation;\n      }\n\n      /**\n       * Get the top-level script for a given block.\n       * @param {?string} id ID of block to query.\n       * @return {?string} ID of top-level script block.\n       */\n    }, {\n      key: \"getTopLevelScript\",\n      value: function getTopLevelScript(id) {\n        var block = this._blocks[id];\n        if (typeof block === 'undefined') return null;\n        while (block.parent !== null) {\n          block = this._blocks[block.parent];\n        }\n        return block.id;\n      }\n\n      /**\n       * Get the procedure definition for a given name.\n       * @param {?string} name Name of procedure to query.\n       * @return {?string} ID of procedure definition.\n       */\n    }, {\n      key: \"getProcedureDefinition\",\n      value: function getProcedureDefinition(name) {\n        var blockID = this._cache.procedureDefinitions[name];\n        if (typeof blockID !== 'undefined') {\n          return blockID;\n        }\n        for (var id in this._blocks) {\n          if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;\n          var block = this._blocks[id];\n          if (block.opcode === 'procedures_definition') {\n            var internal = this._getCustomBlockInternal(block);\n            if (internal && internal.mutation.proccode === name) {\n              this._cache.procedureDefinitions[name] = id; // The outer define block id\n              return id;\n            }\n          }\n        }\n        this._cache.procedureDefinitions[name] = null;\n        return null;\n      }\n\n      /**\n       * Get names and ids of parameters for the given procedure.\n       * @param {?string} name Name of procedure to query.\n       * @return {?Array.<string>} List of param names for a procedure.\n       */\n    }, {\n      key: \"getProcedureParamNamesAndIds\",\n      value: function getProcedureParamNamesAndIds(name) {\n        return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);\n      }\n\n      /**\n       * Get names, ids, and defaults of parameters for the given procedure.\n       * @param {?string} name Name of procedure to query.\n       * @return {?Array.<string>} List of param names for a procedure.\n       */\n    }, {\n      key: \"getProcedureParamNamesIdsAndDefaults\",\n      value: function getProcedureParamNamesIdsAndDefaults(name) {\n        var cachedNames = this._cache.procedureParamNames[name];\n        if (typeof cachedNames !== 'undefined') {\n          return cachedNames;\n        }\n        for (var id in this._blocks) {\n          if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;\n          var block = this._blocks[id];\n          if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {\n            var names = JSON.parse(block.mutation.argumentnames);\n            var ids = JSON.parse(block.mutation.argumentids);\n            var defaults = JSON.parse(block.mutation.argumentdefaults);\n            this._cache.procedureParamNames[name] = [names, ids, defaults];\n            return this._cache.procedureParamNames[name];\n          }\n        }\n        this._cache.procedureParamNames[name] = null;\n        return null;\n      }\n    }, {\n      key: \"duplicate\",\n      value: function duplicate() {\n        var newBlocks = new Blocks(this.runtime, this.forceNoGlow);\n        newBlocks._blocks = Clone.simple(this._blocks);\n        newBlocks._scripts = Clone.simple(this._scripts);\n        return newBlocks;\n      }\n      // ---------------------------------------------------------------------\n\n      /**\n       * Create event listener for blocks, variables, and comments. Handles validation and\n       * serves as a generic adapter between the blocks, variables, and the\n       * runtime interface.\n       * @param {object} e Blockly \"block\" or \"variable\" event\n       */\n    }, {\n      key: \"blocklyListen\",\n      value: function blocklyListen(e) {\n        // Validate event\n        if (_typeof(e) !== 'object') return;\n        if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {\n          return;\n        }\n        var stage = this.runtime.getTargetForStage();\n        var editingTarget = this.runtime.getEditingTarget();\n\n        // UI event: clicked scripts toggle in the runtime.\n        if (e.element === 'stackclick') {\n          this.runtime.toggleScript(e.blockId, {\n            stackClick: true\n          });\n          return;\n        }\n\n        // Block create/update/destroy\n        switch (e.type) {\n          case 'create':\n            {\n              var newBlocks = adapter(e);\n              // A create event can create many blocks. Add them all.\n              for (var i = 0; i < newBlocks.length; i++) {\n                this.createBlock(newBlocks[i]);\n              }\n              break;\n            }\n          case 'change':\n            this.changeBlock({\n              id: e.blockId,\n              element: e.element,\n              name: e.name,\n              value: e.newValue\n            });\n            break;\n          case 'move':\n            this.moveBlock({\n              id: e.blockId,\n              oldParent: e.oldParentId,\n              oldInput: e.oldInputName,\n              newParent: e.newParentId,\n              newInput: e.newInputName,\n              newCoordinate: e.newCoordinate\n            });\n            break;\n          case 'dragOutside':\n            this.runtime.emitBlockDragUpdate(e.isOutside);\n            break;\n          case 'endDrag':\n            this.runtime.emitBlockDragUpdate(false /* areBlocksOverGui */);\n\n            // Drag blocks onto another sprite\n            if (e.isOutside) {\n              var _newBlocks = adapter(e);\n              this.runtime.emitBlockEndDrag(_newBlocks, e.blockId);\n            }\n            break;\n          case 'delete':\n            // Don't accept delete events for missing blocks,\n            // or shadow blocks being obscured.\n            if (!Object.prototype.hasOwnProperty.call(this._blocks, e.blockId) || this._blocks[e.blockId].shadow) {\n              return;\n            }\n            // Inform any runtime to forget about glows on this script.\n            if (this._blocks[e.blockId].topLevel) {\n              this.runtime.quietGlow(e.blockId);\n            }\n            this.deleteBlock(e.blockId);\n            break;\n          case 'var_create':\n            // Check if the variable being created is global or local\n            // If local, create a local var on the current editing target, as long\n            // as there are no conflicts, and the current target is actually a sprite\n            // If global or if the editing target is not present or we somehow got\n            // into a state where a local var was requested for the stage,\n            // create a stage (global) var after checking for name conflicts\n            // on all the sprites.\n            if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {\n              if (!editingTarget.lookupVariableById(e.varId)) {\n                editingTarget.createVariable(e.varId, e.varName, e.varType);\n                this.emitProjectChanged();\n              }\n            } else {\n              if (stage.lookupVariableById(e.varId)) {\n                // Do not re-create a variable if it already exists\n                return;\n              }\n              // Check for name conflicts in all of the targets\n              var allTargets = this.runtime.targets.filter(function (t) {\n                return t.isOriginal;\n              });\n              var _iterator = _createForOfIteratorHelper$5(allTargets),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var target = _step.value;\n                  if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {\n                    return;\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);\n              this.emitProjectChanged();\n            }\n            break;\n          case 'var_rename':\n            if (editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId)) {\n              // This is a local variable, rename on the current target\n              editingTarget.renameVariable(e.varId, e.newName);\n              // Update all the blocks on the current target that use\n              // this variable\n              editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n            } else {\n              // This is a global variable\n              stage.renameVariable(e.varId, e.newName);\n              // Update all blocks on all targets that use the renamed variable\n              var targets = this.runtime.targets;\n              for (var _i = 0; _i < targets.length; _i++) {\n                var currTarget = targets[_i];\n                currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);\n              }\n            }\n            this.emitProjectChanged();\n            break;\n          case 'var_delete':\n            {\n              var _target = editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId) ? editingTarget : stage;\n              _target.deleteVariable(e.varId);\n              this.emitProjectChanged();\n              break;\n            }\n          case 'comment_create':\n            if (this.runtime.getEditingTarget()) {\n              var _currTarget = this.runtime.getEditingTarget();\n              _currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);\n              if (_currTarget.comments[e.commentId].x === null && _currTarget.comments[e.commentId].y === null) {\n                // Block comments imported from 2.0 projects are imported with their\n                // x and y coordinates set to null so that scratch-blocks can\n                // auto-position them. If we are receiving a create event for these\n                // comments, then the auto positioning should have taken place.\n                // Update the x and y position of these comments to match the\n                // one from the event.\n                _currTarget.comments[e.commentId].x = e.xy.x;\n                _currTarget.comments[e.commentId].y = e.xy.y;\n              }\n            }\n            this.emitProjectChanged();\n            break;\n          case 'comment_change':\n            if (this.runtime.getEditingTarget()) {\n              var _currTarget2 = this.runtime.getEditingTarget();\n              if (!Object.prototype.hasOwnProperty.call(_currTarget2.comments, e.commentId)) {\n                log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n                return;\n              }\n              var comment = _currTarget2.comments[e.commentId];\n              var change = e.newContents_;\n              if (Object.prototype.hasOwnProperty.call(change, 'minimized')) {\n                comment.minimized = change.minimized;\n              }\n              if (Object.prototype.hasOwnProperty.call(change, 'width') && Object.prototype.hasOwnProperty.call(change, 'height')) {\n                comment.width = change.width;\n                comment.height = change.height;\n              }\n              if (Object.prototype.hasOwnProperty.call(change, 'text')) {\n                comment.text = change.text;\n              }\n              this.emitProjectChanged();\n            }\n            break;\n          case 'comment_move':\n            if (this.runtime.getEditingTarget()) {\n              var _currTarget3 = this.runtime.getEditingTarget();\n              if (_currTarget3 && !Object.prototype.hasOwnProperty.call(_currTarget3.comments, e.commentId)) {\n                log.warn(\"Cannot change comment with id \".concat(e.commentId, \" because it does not exist.\"));\n                return;\n              }\n              var _comment = _currTarget3.comments[e.commentId];\n              var newCoord = e.newCoordinate_;\n              _comment.x = newCoord.x;\n              _comment.y = newCoord.y;\n              this.emitProjectChanged();\n            }\n            break;\n          case 'comment_delete':\n            if (this.runtime.getEditingTarget()) {\n              var _currTarget4 = this.runtime.getEditingTarget();\n              if (!Object.prototype.hasOwnProperty.call(_currTarget4.comments, e.commentId)) {\n                // If we're in this state, we have probably received\n                // a delete event from a workspace that we switched from\n                // (e.g. a delete event for a comment on sprite a's workspace\n                // when switching from sprite a to sprite b)\n                return;\n              }\n              delete _currTarget4.comments[e.commentId];\n              if (e.blockId) {\n                var block = _currTarget4.blocks.getBlock(e.blockId);\n                if (!block) {\n                  log.warn(\"Could not find block referenced by comment with id: \".concat(e.commentId));\n                  return;\n                }\n                delete block.comment;\n              }\n              this.emitProjectChanged();\n            }\n            break;\n        }\n      }\n\n      // ---------------------------------------------------------------------\n\n      /**\n       * Reset all runtime caches.\n       */\n    }, {\n      key: \"resetCache\",\n      value: function resetCache() {\n        this._cache.inputs = {};\n        this._cache.procedureParamNames = {};\n        this._cache.procedureDefinitions = {};\n        this._cache._executeCached = {};\n        this._cache._monitored = null;\n        this._cache.scripts = {};\n      }\n\n      /**\n       * Emit a project changed event if this is a block container\n       * that can affect the project state.\n       */\n    }, {\n      key: \"emitProjectChanged\",\n      value: function emitProjectChanged() {\n        if (!this.forceNoGlow) {\n          this.runtime.emitProjectChanged();\n        }\n      }\n\n      /**\n       * Block management: create blocks and scripts from a `create` event\n       * @param {!object} block Blockly create event to be processed\n       */\n    }, {\n      key: \"createBlock\",\n      value: function createBlock(block) {\n        // Does the block already exist?\n        // Could happen, e.g., for an unobscured shadow.\n        if (Object.prototype.hasOwnProperty.call(this._blocks, block.id)) {\n          return;\n        }\n        // Create new block.\n        this._blocks[block.id] = block;\n        // Push block id to scripts array.\n        // Blocks are added as a top-level stack if they are marked as a top-block\n        // (if they were top-level XML in the event).\n        if (block.topLevel) {\n          this._addScript(block.id);\n        }\n        this.resetCache();\n\n        // A new block was actually added to the block container,\n        // emit a project changed event\n        this.emitProjectChanged();\n      }\n\n      /**\n       * Block management: change block field values\n       * @param {!object} args Blockly change event to be processed\n       */\n    }, {\n      key: \"changeBlock\",\n      value: function changeBlock(args) {\n        // Validate\n        if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;\n        var block = this._blocks[args.id];\n        if (typeof block === 'undefined') return;\n        switch (args.element) {\n          case 'field':\n            // TODO when the field of a monitored block changes,\n            // update the checkbox in the flyout based on whether\n            // a monitor for that current combination of selected parameters exists\n            // e.g.\n            // 1. check (current [v year])\n            // 2. switch dropdown in flyout block to (current [v minute])\n            // 3. the checkbox should become unchecked if we're not already\n            //    monitoring current minute\n\n            // Update block value\n            if (!block.fields[args.name]) return;\n            if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {\n              // Get variable name using the id in args.value.\n              var variable = this.runtime.getEditingTarget().lookupVariableById(args.value);\n              if (variable) {\n                block.fields[args.name].value = variable.name;\n                block.fields[args.name].id = args.value;\n              }\n            } else {\n              // Changing the value in a dropdown\n              block.fields[args.name].value = args.value;\n\n              // The selected item in the sensing of block menu needs to change based on the\n              // selected target.  Set it to the first item in the menu list.\n              // TODO: (#1787)\n              if (block.opcode === 'sensing_of_object_menu') {\n                if (block.fields.OBJECT.value === '_stage_') {\n                  this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';\n                } else {\n                  this._blocks[block.parent].fields.PROPERTY.value = 'x position';\n                }\n                this.runtime.requestBlocksUpdate();\n              }\n              var flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;\n              if (flyoutBlock.isMonitored) {\n                this.runtime.requestUpdateMonitor(Map({\n                  id: flyoutBlock.id,\n                  params: this._getBlockParams(flyoutBlock)\n                }));\n              }\n            }\n            break;\n          case 'mutation':\n            block.mutation = mutationAdapter(args.value);\n            break;\n          case 'checkbox':\n            {\n              // A checkbox usually has a one to one correspondence with the monitor\n              // block but in the case of monitored reporters that have arguments,\n              // map the old id to a new id, creating a new monitor block if necessary\n              if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {\n                // This block has an argument which needs to get separated out into\n                // multiple monitor blocks with ids based on the selected argument\n                var newId = getMonitorIdForBlockWithArgs(block.id, block.fields);\n                // Note: we're not just constantly creating a longer and longer id everytime we check\n                // the checkbox because we're using the id of the block in the flyout as the base\n\n                // check if a block with the new id already exists, otherwise create\n                var newBlock = this.runtime.monitorBlocks.getBlock(newId);\n                if (!newBlock) {\n                  newBlock = JSON.parse(JSON.stringify(block));\n                  newBlock.id = newId;\n                  this.runtime.monitorBlocks.createBlock(newBlock);\n                }\n                block = newBlock; // Carry on through the rest of this code with newBlock\n              }\n              var wasMonitored = block.isMonitored;\n              block.isMonitored = args.value;\n\n              // Variable blocks may be sprite specific depending on the owner of the variable\n              var isSpriteLocalVariable = false;\n              if (block.opcode === 'data_variable') {\n                isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];\n              } else if (block.opcode === 'data_listcontents') {\n                isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];\n              }\n              var isSpriteSpecific = isSpriteLocalVariable || Object.prototype.hasOwnProperty.call(this.runtime.monitorBlockInfo, block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;\n              if (isSpriteSpecific) {\n                // If creating a new sprite specific monitor, the only possible target is\n                // the current editing one b/c you cannot dynamically create monitors.\n                // Also, do not change the targetId if it has already been assigned\n                block.targetId = block.targetId || this.runtime.getEditingTarget().id;\n              } else {\n                block.targetId = null;\n              }\n              if (wasMonitored && !block.isMonitored) {\n                this.runtime.requestHideMonitor(block.id);\n              } else if (!wasMonitored && block.isMonitored) {\n                // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.\n                if (!this.runtime.requestShowMonitor(block.id)) {\n                  this.runtime.requestAddMonitor(MonitorRecord({\n                    id: block.id,\n                    targetId: block.targetId,\n                    spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,\n                    opcode: block.opcode,\n                    params: this._getBlockParams(block),\n                    // @todo(vm#565) for numerical values with decimals, some countries use comma\n                    value: '',\n                    mode: block.opcode === 'data_listcontents' ? 'list' : 'default'\n                  }));\n                }\n              }\n              break;\n            }\n        }\n        this.emitProjectChanged();\n        this.resetCache();\n      }\n\n      /**\n       * Block management: move blocks from parent to parent\n       * @param {!object} e Blockly move event to be processed\n       */\n    }, {\n      key: \"moveBlock\",\n      value: function moveBlock(e) {\n        if (!Object.prototype.hasOwnProperty.call(this._blocks, e.id)) {\n          return;\n        }\n        var block = this._blocks[e.id];\n        // Track whether a change actually occurred\n        // ignoring changes like routine re-positioning\n        // of a block when loading a workspace\n        var didChange = false;\n\n        // Move coordinate changes.\n        if (e.newCoordinate) {\n          didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;\n          block.x = e.newCoordinate.x;\n          block.y = e.newCoordinate.y;\n        }\n\n        // Remove from any old parent.\n        if (typeof e.oldParent !== 'undefined') {\n          var oldParent = this._blocks[e.oldParent];\n          if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {\n            // This block was connected to the old parent's input.\n            oldParent.inputs[e.oldInput].block = null;\n          } else if (oldParent.next === e.id) {\n            // This block was connected to the old parent's next connection.\n            oldParent.next = null;\n          }\n          this._blocks[e.id].parent = null;\n          didChange = true;\n        }\n\n        // Is this block a top-level block?\n        if (typeof e.newParent === 'undefined') {\n          this._addScript(e.id);\n        } else {\n          // Remove script, if one exists.\n          this._deleteScript(e.id);\n          // Otherwise, try to connect it in its new place.\n          if (typeof e.newInput === 'undefined') {\n            // Moved to the new parent's next connection.\n            this._blocks[e.newParent].next = e.id;\n          } else {\n            // Moved to the new parent's input.\n            // Don't obscure the shadow block.\n            var oldShadow = null;\n            if (Object.prototype.hasOwnProperty.call(this._blocks[e.newParent].inputs, e.newInput)) {\n              oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;\n            }\n\n            // If the block being attached is itself a shadow, make sure to set\n            // both block and shadow to that blocks ID. This happens when adding\n            // inputs to a custom procedure.\n            if (this._blocks[e.id].shadow) oldShadow = e.id;\n            this._blocks[e.newParent].inputs[e.newInput] = {\n              name: e.newInput,\n              block: e.id,\n              shadow: oldShadow\n            };\n          }\n          this._blocks[e.id].parent = e.newParent;\n          didChange = true;\n        }\n        this.resetCache();\n        if (didChange) this.emitProjectChanged();\n      }\n\n      /**\n       * Block management: run all blocks.\n       * @param {!object} runtime Runtime to run all blocks in.\n       */\n    }, {\n      key: \"runAllMonitored\",\n      value: function runAllMonitored(runtime) {\n        var _this = this;\n        if (this._cache._monitored === null) {\n          this._cache._monitored = Object.keys(this._blocks).filter(function (blockId) {\n            return _this.getBlock(blockId).isMonitored;\n          }).map(function (blockId) {\n            var targetId = _this.getBlock(blockId).targetId;\n            return {\n              blockId: blockId,\n              target: targetId ? runtime.getTargetById(targetId) : null\n            };\n          });\n        }\n        var monitored = this._cache._monitored;\n        for (var i = 0; i < monitored.length; i++) {\n          var _monitored$i = monitored[i],\n            blockId = _monitored$i.blockId,\n            target = _monitored$i.target;\n          runtime.addMonitorScript(blockId, target);\n        }\n      }\n\n      /**\n       * Block management: delete blocks and their associated scripts. Does nothing if a block\n       * with the given ID does not exist.\n       * @param {!string} blockId Id of block to delete\n       */\n    }, {\n      key: \"deleteBlock\",\n      value: function deleteBlock(blockId) {\n        // @todo In runtime, stop threads running on this script.\n\n        // Get block\n        var block = this._blocks[blockId];\n        if (!block) {\n          // No block with the given ID exists\n          return;\n        }\n\n        // Delete children\n        if (block.next !== null) {\n          this.deleteBlock(block.next);\n        }\n\n        // Delete inputs (including branches)\n        for (var input in block.inputs) {\n          // If it's null, the block in this input moved away.\n          if (block.inputs[input].block !== null) {\n            this.deleteBlock(block.inputs[input].block);\n          }\n          // Delete obscured shadow blocks.\n          if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {\n            this.deleteBlock(block.inputs[input].shadow);\n          }\n        }\n\n        // Delete any script starting with this block.\n        this._deleteScript(blockId);\n\n        // Delete block itself.\n        delete this._blocks[blockId];\n        this.resetCache();\n        this.emitProjectChanged();\n      }\n\n      /**\n       * Delete all blocks and their associated scripts.\n       */\n    }, {\n      key: \"deleteAllBlocks\",\n      value: function deleteAllBlocks() {\n        var _this2 = this;\n        var blockIds = Object.keys(this._blocks);\n        blockIds.forEach(function (blockId) {\n          return _this2.deleteBlock(blockId);\n        });\n      }\n\n      /**\n       * Returns a map of all references to variables or lists from blocks\n       * in this block container.\n       * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.\n       * This is useful for getting variable/list references for a stack of blocks instead\n       * of all blocks on the workspace\n       * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.\n       * @return {object} A map of variable ID to a list of all variable references\n       * for that ID. A variable reference contains the field referencing that variable\n       * and also the type of the variable being referenced.\n       */\n    }, {\n      key: \"getAllVariableAndListReferences\",\n      value: function getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {\n        var blocks = optBlocks ? optBlocks : this._blocks;\n        var allReferences = Object.create(null);\n        for (var blockId in blocks) {\n          var varOrListField = null;\n          var varType = null;\n          if (blocks[blockId].fields.VARIABLE) {\n            varOrListField = blocks[blockId].fields.VARIABLE;\n            varType = Variable.SCALAR_TYPE;\n          } else if (blocks[blockId].fields.LIST) {\n            varOrListField = blocks[blockId].fields.LIST;\n            varType = Variable.LIST_TYPE;\n          } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {\n            varOrListField = blocks[blockId].fields.BROADCAST_OPTION;\n            varType = Variable.BROADCAST_MESSAGE_TYPE;\n          }\n          if (varOrListField) {\n            var currVarId = varOrListField.id;\n            if (allReferences[currVarId]) {\n              allReferences[currVarId].push({\n                referencingField: varOrListField,\n                type: varType\n              });\n            } else {\n              allReferences[currVarId] = [{\n                referencingField: varOrListField,\n                type: varType\n              }];\n            }\n          }\n        }\n        return allReferences;\n      }\n\n      /**\n       * Keep blocks up to date after a variable gets renamed.\n       * @param {string} varId The id of the variable that was renamed\n       * @param {string} newName The new name of the variable that was renamed\n       */\n    }, {\n      key: \"updateBlocksAfterVarRename\",\n      value: function updateBlocksAfterVarRename(varId, newName) {\n        var blocks = this._blocks;\n        for (var blockId in blocks) {\n          var varOrListField = null;\n          if (blocks[blockId].fields.VARIABLE) {\n            varOrListField = blocks[blockId].fields.VARIABLE;\n          } else if (blocks[blockId].fields.LIST) {\n            varOrListField = blocks[blockId].fields.LIST;\n          }\n          if (varOrListField) {\n            var currFieldId = varOrListField.id;\n            if (varId === currFieldId) {\n              varOrListField.value = newName;\n            }\n          }\n        }\n      }\n\n      /**\n       * Keep blocks up to date after they are shared between targets.\n       * @param {boolean} isStage If the new target is a stage.\n       */\n    }, {\n      key: \"updateTargetSpecificBlocks\",\n      value: function updateTargetSpecificBlocks(isStage) {\n        var blocks = this._blocks;\n        for (var blockId in blocks) {\n          if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {\n            blocks[blockId].opcode = 'event_whenstageclicked';\n          } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {\n            blocks[blockId].opcode = 'event_whenthisspriteclicked';\n          }\n        }\n      }\n\n      /**\n       * Update blocks after a sound, costume, or backdrop gets renamed.\n       * Any block referring to the old name of the asset should get updated\n       * to refer to the new name.\n       * @param {string} oldName The old name of the asset that was renamed.\n       * @param {string} newName The new name of the asset that was renamed.\n       * @param {string} assetType String representation of the kind of asset\n       * that was renamed. This can be one of 'sprite','costume', 'sound', or\n       * 'backdrop'.\n       */\n    }, {\n      key: \"updateAssetName\",\n      value: function updateAssetName(oldName, newName, assetType) {\n        var getAssetField;\n        if (assetType === 'costume') {\n          getAssetField = this._getCostumeField.bind(this);\n        } else if (assetType === 'sound') {\n          getAssetField = this._getSoundField.bind(this);\n        } else if (assetType === 'backdrop') {\n          getAssetField = this._getBackdropField.bind(this);\n        } else if (assetType === 'sprite') {\n          getAssetField = this._getSpriteField.bind(this);\n        } else {\n          return;\n        }\n        var blocks = this._blocks;\n        for (var blockId in blocks) {\n          var assetField = getAssetField(blockId);\n          if (assetField && assetField.value === oldName) {\n            assetField.value = newName;\n          }\n        }\n      }\n\n      /**\n       * Update sensing_of blocks after a variable gets renamed.\n       * @param {string} oldName The old name of the variable that was renamed.\n       * @param {string} newName The new name of the variable that was renamed.\n       * @param {string} targetName The name of the target the variable belongs to.\n       * @return {boolean} Returns true if any of the blocks were updated.\n       */\n    }, {\n      key: \"updateSensingOfReference\",\n      value: function updateSensingOfReference(oldName, newName, targetName) {\n        var blocks = this._blocks;\n        var blockUpdated = false;\n        for (var blockId in blocks) {\n          var block = blocks[blockId];\n          if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName &&\n          // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.\n          block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {\n            var inputBlock = this.getBlock(block.inputs.OBJECT.block);\n            if (inputBlock.fields.OBJECT.value === targetName) {\n              block.fields.PROPERTY.value = newName;\n              blockUpdated = true;\n            }\n          }\n        }\n        if (blockUpdated) this.resetCache();\n        return blockUpdated;\n      }\n\n      /**\n       * Helper function to retrieve a costume menu field from a block given its id.\n       * @param {string} blockId A unique identifier for a block\n       * @return {?object} The costume menu field of the block with the given block id.\n       * Null if either a block with the given id doesn't exist or if a costume menu field\n       * does not exist on the block with the given id.\n       */\n    }, {\n      key: \"_getCostumeField\",\n      value: function _getCostumeField(blockId) {\n        var block = this.getBlock(blockId);\n        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'COSTUME')) {\n          return block.fields.COSTUME;\n        }\n        return null;\n      }\n\n      /**\n       * Helper function to retrieve a sound menu field from a block given its id.\n       * @param {string} blockId A unique identifier for a block\n       * @return {?object} The sound menu field of the block with the given block id.\n       * Null, if either a block with the given id doesn't exist or if a sound menu field\n       * does not exist on the block with the given id.\n       */\n    }, {\n      key: \"_getSoundField\",\n      value: function _getSoundField(blockId) {\n        var block = this.getBlock(blockId);\n        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'SOUND_MENU')) {\n          return block.fields.SOUND_MENU;\n        }\n        return null;\n      }\n\n      /**\n       * Helper function to retrieve a backdrop menu field from a block given its id.\n       * @param {string} blockId A unique identifier for a block\n       * @return {?object} The backdrop menu field of the block with the given block id.\n       * Null, if either a block with the given id doesn't exist or if a backdrop menu field\n       * does not exist on the block with the given id.\n       */\n    }, {\n      key: \"_getBackdropField\",\n      value: function _getBackdropField(blockId) {\n        var block = this.getBlock(blockId);\n        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'BACKDROP')) {\n          return block.fields.BACKDROP;\n        }\n        return null;\n      }\n\n      /**\n       * Helper function to retrieve a sprite menu field from a block given its id.\n       * @param {string} blockId A unique identifier for a block\n       * @return {?object} The sprite menu field of the block with the given block id.\n       * Null, if either a block with the given id doesn't exist or if a sprite menu field\n       * does not exist on the block with the given id.\n       */\n    }, {\n      key: \"_getSpriteField\",\n      value: function _getSpriteField(blockId) {\n        var block = this.getBlock(blockId);\n        if (!block) {\n          return null;\n        }\n        var spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];\n        for (var i = 0; i < spriteMenuNames.length; i++) {\n          var menuName = spriteMenuNames[i];\n          if (Object.prototype.hasOwnProperty.call(block.fields, menuName)) {\n            return block.fields[menuName];\n          }\n        }\n        return null;\n      }\n\n      // ---------------------------------------------------------------------\n\n      /**\n       * Encode all of `this._blocks` as an XML string usable\n       * by a Blockly/scratch-blocks workspace.\n       * @param {object<string, Comment>} comments Map of comments referenced by id\n       * @return {string} String of XML representing this object's blocks.\n       */\n    }, {\n      key: \"toXML\",\n      value: function toXML(comments) {\n        var _this3 = this;\n        return this._scripts.map(function (script) {\n          return _this3.blockToXML(script, comments);\n        }).join();\n      }\n\n      /**\n       * Recursively encode an individual block and its children\n       * into a Blockly/scratch-blocks XML string.\n       * @param {!string} blockId ID of block to encode.\n       * @param {object<string, Comment>} comments Map of comments referenced by id\n       * @return {string} String of XML representing this block and any children.\n       */\n    }, {\n      key: \"blockToXML\",\n      value: function blockToXML(blockId, comments) {\n        var block = this._blocks[blockId];\n        // block should exist, but currently some blocks' next property point\n        // to a blockId for non-existent blocks. Until we track down that behavior,\n        // this early exit allows the project to load.\n        if (!block) return;\n        // Encode properties of this block.\n        var tagName = block.shadow ? 'shadow' : 'block';\n        var xmlString = \"<\".concat(tagName, \"\\n                id=\\\"\").concat(block.id, \"\\\"\\n                type=\\\"\").concat(block.opcode, \"\\\"\\n                \").concat(block.topLevel ? \"x=\\\"\".concat(block.x, \"\\\" y=\\\"\").concat(block.y, \"\\\"\") : '', \"\\n            >\");\n        var commentId = block.comment;\n        if (commentId) {\n          if (comments) {\n            if (Object.prototype.hasOwnProperty.call(comments, commentId)) {\n              xmlString += comments[commentId].toXML();\n            } else {\n              log.warn(\"Could not find comment with id: \".concat(commentId, \" in provided comment descriptions.\"));\n            }\n          } else {\n            log.warn(\"Cannot serialize comment with id: \".concat(commentId, \"; no comment descriptions provided.\"));\n          }\n        }\n        // Add any mutation. Must come before inputs.\n        if (block.mutation) {\n          xmlString += this.mutationToXML(block.mutation);\n        }\n        // Add any inputs on this block.\n        for (var input in block.inputs) {\n          if (!Object.prototype.hasOwnProperty.call(block.inputs, input)) continue;\n          var blockInput = block.inputs[input];\n          // Only encode a value tag if the value input is occupied.\n          if (blockInput.block || blockInput.shadow) {\n            xmlString += \"<value name=\\\"\".concat(blockInput.name, \"\\\">\");\n            if (blockInput.block) {\n              xmlString += this.blockToXML(blockInput.block, comments);\n            }\n            if (blockInput.shadow && blockInput.shadow !== blockInput.block) {\n              // Obscured shadow.\n              xmlString += this.blockToXML(blockInput.shadow, comments);\n            }\n            xmlString += '</value>';\n          }\n        }\n        // Add any fields on this block.\n        for (var field in block.fields) {\n          if (!Object.prototype.hasOwnProperty.call(block.fields, field)) continue;\n          var blockField = block.fields[field];\n          xmlString += \"<field name=\\\"\".concat(blockField.name, \"\\\"\");\n          var fieldId = blockField.id;\n          if (fieldId) {\n            xmlString += \" id=\\\"\".concat(fieldId, \"\\\"\");\n          }\n          var varType = blockField.variableType;\n          if (typeof varType === 'string') {\n            xmlString += \" variabletype=\\\"\".concat(varType, \"\\\"\");\n          }\n          var value = blockField.value;\n          if (typeof value === 'string') {\n            value = xmlEscape(blockField.value);\n          }\n          xmlString += \">\".concat(value, \"</field>\");\n        }\n        // Add blocks connected to the next connection.\n        if (block.next) {\n          xmlString += \"<next>\".concat(this.blockToXML(block.next, comments), \"</next>\");\n        }\n        xmlString += \"</\".concat(tagName, \">\");\n        return xmlString;\n      }\n\n      /**\n       * Recursively encode a mutation object to XML.\n       * @param {!object} mutation Object representing a mutation.\n       * @return {string} XML string representing a mutation.\n       */\n    }, {\n      key: \"mutationToXML\",\n      value: function mutationToXML(mutation) {\n        var mutationString = \"<\".concat(mutation.tagName);\n        for (var prop in mutation) {\n          if (prop === 'children' || prop === 'tagName') continue;\n          var mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop];\n\n          // Handle dynamic extension blocks\n          if (prop === 'blockInfo') {\n            mutationValue = xmlEscape(JSON.stringify(mutation[prop]));\n          }\n          mutationString += \" \".concat(prop, \"=\\\"\").concat(mutationValue, \"\\\"\");\n        }\n        mutationString += '>';\n        for (var i = 0; i < mutation.children.length; i++) {\n          mutationString += this.mutationToXML(mutation.children[i]);\n        }\n        mutationString += \"</\".concat(mutation.tagName, \">\");\n        return mutationString;\n      }\n\n      // ---------------------------------------------------------------------\n      /**\n       * Helper to serialize block fields and input fields for reporting new monitors\n       * @param {!object} block Block to be paramified.\n       * @return {!object} object of param key/values.\n       */\n    }, {\n      key: \"_getBlockParams\",\n      value: function _getBlockParams(block) {\n        var params = {};\n        for (var key in block.fields) {\n          params[key] = block.fields[key].value;\n        }\n        for (var inputKey in block.inputs) {\n          var inputBlock = this._blocks[block.inputs[inputKey].block];\n          for (var _key in inputBlock.fields) {\n            params[_key] = inputBlock.fields[_key].value;\n          }\n        }\n        return params;\n      }\n\n      /**\n       * Helper to get the corresponding internal procedure definition block\n       * @param {!object} defineBlock Outer define block.\n       * @return {!object} internal definition block which has the mutation.\n       */\n    }, {\n      key: \"_getCustomBlockInternal\",\n      value: function _getCustomBlockInternal(defineBlock) {\n        if (defineBlock.inputs && defineBlock.inputs.custom_block) {\n          return this._blocks[defineBlock.inputs.custom_block.block];\n        }\n      }\n\n      /**\n       * Helper to add a stack to `this._scripts`.\n       * @param {?string} topBlockId ID of block that starts the script.\n       */\n    }, {\n      key: \"_addScript\",\n      value: function _addScript(topBlockId) {\n        var i = this._scripts.indexOf(topBlockId);\n        if (i > -1) return; // Already in scripts.\n        this._scripts.push(topBlockId);\n        // Update `topLevel` property on the top block.\n        this._blocks[topBlockId].topLevel = true;\n      }\n\n      /**\n       * Helper to remove a script from `this._scripts`.\n       * @param {?string} topBlockId ID of block that starts the script.\n       */\n    }, {\n      key: \"_deleteScript\",\n      value: function _deleteScript(topBlockId) {\n        var i = this._scripts.indexOf(topBlockId);\n        if (i > -1) this._scripts.splice(i, 1);\n        // Update `topLevel` property on the top block.\n        if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;\n      }\n    }], [{\n      key: \"BRANCH_INPUT_PREFIX\",\n      get: function get() {\n        return 'SUBSTACK';\n      }\n    }]);\n  }();\n  /**\n   * A private method shared with execute to build an object containing the block\n   * information execute needs and that is reset when other cached Blocks info is\n   * reset.\n   * @param {Blocks} blocks Blocks containing the expected blockId\n   * @param {string} blockId blockId for the desired execute cache\n   * @param {function} CacheType constructor for cached block information\n   * @return {object} execute cache object\n   */\n  BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {\n    var cached = blocks._cache._executeCached[blockId];\n    if (typeof cached !== 'undefined') {\n      return cached;\n    }\n    var block = blocks.getBlock(blockId);\n    if (typeof block === 'undefined') return null;\n    if (typeof CacheType === 'undefined') {\n      cached = {\n        id: blockId,\n        opcode: blocks.getOpcode(block),\n        fields: blocks.getFields(block),\n        inputs: blocks.getInputs(block),\n        mutation: blocks.getMutation(block)\n      };\n    } else {\n      cached = new CacheType(blocks, {\n        id: blockId,\n        opcode: blocks.getOpcode(block),\n        fields: blocks.getFields(block),\n        inputs: blocks.getInputs(block),\n        mutation: blocks.getMutation(block)\n      });\n    }\n    blocks._cache._executeCached[blockId] = cached;\n    return cached;\n  };\n\n  /**\n   * Cache class constructor for runtime. Used to consider what threads should\n   * start based on hat data.\n   * @type {function}\n   */\n  var RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;\n\n  /**\n   * Get an array of scripts from a block container prefiltered to match opcode.\n   * @param {Blocks} blocks - Container of blocks\n   * @param {string} opcode - Opcode to filter top blocks by\n   * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache\n   *   objects\n   */\n  BlocksRuntimeCache.getScripts = function (blocks, opcode) {\n    var scripts = blocks._cache.scripts[opcode];\n    if (!scripts) {\n      scripts = blocks._cache.scripts[opcode] = [];\n      var allScripts = blocks._scripts;\n      for (var i = 0; i < allScripts.length; i++) {\n        var topBlockId = allScripts[i];\n        var block = blocks.getBlock(topBlockId);\n        if (block.opcode === opcode) {\n          scripts.push(new RuntimeScriptCache(blocks, topBlockId));\n        }\n      }\n    }\n    return scripts;\n  };\n  blocks = Blocks;\n  return blocks;\n}\n\nvar uid$1 = uid_1;\nvar xmlEscape = xmlEscape_1;\nvar Comment$1 = /*#__PURE__*/function () {\n  /**\n   * @param {string} id Id of the comment.\n   * @param {string} text Text content of the comment.\n   * @param {number} x X position of the comment on the workspace.\n   * @param {number} y Y position of the comment on the workspace.\n   * @param {number} width The width of the comment when it is full size.\n   * @param {number} height The height of the comment when it is full size.\n   * @param {boolean} minimized Whether the comment is minimized.\n   * @constructor\n   */\n  function Comment(id, text, x, y, width, height, minimized) {\n    _classCallCheck(this, Comment);\n    this.id = id || uid$1();\n    this.text = text;\n    this.x = x;\n    this.y = y;\n    this.width = Math.max(Number(width), Comment.MIN_WIDTH);\n    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);\n    this.minimized = minimized || false;\n    this.blockId = null;\n  }\n  return _createClass(Comment, [{\n    key: \"toXML\",\n    value: function toXML() {\n      return \"<comment id=\\\"\".concat(this.id, \"\\\" x=\\\"\").concat(this.x, \"\\\" y=\\\"\").concat(this.y, \"\\\" w=\\\"\").concat(this.width, \"\\\" h=\\\"\").concat(this.height, \"\\\" pinned=\\\"\").concat(this.blockId !== null, \"\\\" minimized=\\\"\").concat(this.minimized, \"\\\">\").concat(xmlEscape(this.text), \"</comment>\");\n    }\n\n    // TODO choose min and defaults for width and height\n  }], [{\n    key: \"MIN_WIDTH\",\n    get: function get() {\n      return 20;\n    }\n  }, {\n    key: \"MIN_HEIGHT\",\n    get: function get() {\n      return 20;\n    }\n  }, {\n    key: \"DEFAULT_WIDTH\",\n    get: function get() {\n      return 100;\n    }\n  }, {\n    key: \"DEFAULT_HEIGHT\",\n    get: function get() {\n      return 100;\n    }\n  }]);\n}();\nvar comment = Comment$1;\n\nvar VariableUtil$1 = /*#__PURE__*/function () {\n  function VariableUtil() {\n    _classCallCheck(this, VariableUtil);\n  }\n  return _createClass(VariableUtil, null, [{\n    key: \"_mergeVarRefObjects\",\n    value: function _mergeVarRefObjects(accum, obj2) {\n      for (var id in obj2) {\n        if (accum[id]) {\n          accum[id] = accum[id].concat(obj2[id]);\n        } else {\n          accum[id] = obj2[id];\n        }\n      }\n      return accum;\n    }\n\n    /**\n     * Get all variable/list references in the given list of targets\n     * in the project.\n     * @param {Array.<Target>} targets The list of targets to get the variable\n     * and list references from.\n     * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.\n     * @return {object} An object with variable ids as the keys and a list of block fields referencing\n     * the variable.\n     */\n  }, {\n    key: \"getAllVarRefsForTargets\",\n    value: function getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {\n      return targets.map(function (t) {\n        return t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast);\n      }).reduce(VariableUtil._mergeVarRefObjects, {});\n    }\n\n    /**\n     * Give all variable references provided a new id and possibly new name.\n     * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable\n     * references to update.\n     * @param {string} newId ID of the variable that the old references should be replaced with\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n  }, {\n    key: \"updateVariableIdentifiers\",\n    value: function updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {\n      referencesToUpdate.map(function (ref) {\n        ref.referencingField.id = newId;\n        if (optNewName) {\n          ref.referencingField.value = optNewName;\n        }\n        return ref;\n      });\n    }\n  }]);\n}();\nvar variableUtil = VariableUtil$1;\n\nfunction _createForOfIteratorHelper$4(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$4(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray$4(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$4(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0; } }\nfunction _arrayLikeToArray$4(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _callSuper$D(t, o, e) { return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$E() ? Reflect.construct(o, [], _getPrototypeOf$1(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$E() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$E = function _isNativeReflectConstruct() { return !!t; })(); }\nvar EventEmitter = require$$0$3;\nvar Blocks = requireBlocks();\nvar Variable = variable;\nvar Comment = comment;\nvar uid = uid_1;\nvar Map$1 = immutableExports.Map;\nvar log = log$3;\nvar StringUtil$1 = stringUtil;\nvar VariableUtil = variableUtil;\n\n/**\n * @fileoverview\n * A Target is an abstract \"code-running\" object for the Scratch VM.\n * Examples include sprites/clones or potentially physical-world devices.\n */\nvar Target$1 = /*#__PURE__*/function (_EventEmitter) {\n  /**\n   * @param {Runtime} runtime Reference to the runtime.\n   * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.\n   * @constructor\n   */\n  function Target(runtime, blocks) {\n    var _this;\n    _classCallCheck(this, Target);\n    _this = _callSuper$D(this, Target);\n    if (!blocks) {\n      blocks = new Blocks(runtime);\n    }\n\n    /**\n     * Reference to the runtime.\n     * @type {Runtime}\n     */\n    _this.runtime = runtime;\n    /**\n     * A unique ID for this target.\n     * @type {string}\n     */\n    _this.id = uid();\n    /**\n     * Blocks run as code for this target.\n     * @type {!Blocks}\n     */\n    _this.blocks = blocks;\n    /**\n     * Dictionary of variables and their values for this target.\n     * Key is the variable id.\n     * @type {Object.<string,*>}\n     */\n    _this.variables = {};\n    /**\n     * Dictionary of comments for this target.\n     * Key is the comment id.\n     * @type {Object.<string,*>}\n     */\n    _this.comments = {};\n    /**\n     * Dictionary of custom state for this target.\n     * This can be used to store target-specific custom state for blocks which need it.\n     * TODO: do we want to persist this in SB3 files?\n     * @type {Object.<string,*>}\n     */\n    _this._customState = {};\n\n    /**\n     * Currently known values for edge-activated hats.\n     * Keys are block ID for the hat; values are the currently known values.\n     * @type {Object.<string, *>}\n     */\n    _this._edgeActivatedHatValues = {};\n    return _this;\n  }\n\n  /**\n   * Called when the project receives a \"green flag.\"\n   * @abstract\n   */\n  _inherits$1(Target, _EventEmitter);\n  return _createClass(Target, [{\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {}\n\n    /**\n     * Return a human-readable name for this target.\n     * Target implementations should override this.\n     * @abstract\n     * @returns {string} Human-readable name for the target.\n     */\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.id;\n    }\n\n    /**\n     * Update an edge-activated hat block value.\n     * @param {!string} blockId ID of hat to store value for.\n     * @param {*} newValue Value to store for edge-activated hat.\n     * @return {*} The old value for the edge-activated hat.\n     */\n  }, {\n    key: \"updateEdgeActivatedValue\",\n    value: function updateEdgeActivatedValue(blockId, newValue) {\n      var oldValue = this._edgeActivatedHatValues[blockId];\n      this._edgeActivatedHatValues[blockId] = newValue;\n      return oldValue;\n    }\n  }, {\n    key: \"hasEdgeActivatedValue\",\n    value: function hasEdgeActivatedValue(blockId) {\n      return Object.prototype.hasOwnProperty.call(this._edgeActivatedHatValues, blockId);\n    }\n\n    /**\n     * Clear all edge-activaed hat values.\n     */\n  }, {\n    key: \"clearEdgeActivatedValues\",\n    value: function clearEdgeActivatedValues() {\n      this._edgeActivatedHatValues = {};\n    }\n\n    /**\n     * Look up a variable object, first by id, and then by name if the id is not found.\n     * Create a new variable if both lookups fail.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n  }, {\n    key: \"lookupOrCreateVariable\",\n    value: function lookupOrCreateVariable(id, name) {\n      var variable = this.lookupVariableById(id);\n      if (variable) return variable;\n      variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);\n      if (variable) return variable;\n\n      // No variable with this name exists - create it locally.\n      var newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);\n      this.variables[id] = newVariable;\n      return newVariable;\n    }\n\n    /**\n     * Look up a broadcast message object with the given id and return it\n     * if it exists.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n  }, {\n    key: \"lookupBroadcastMsg\",\n    value: function lookupBroadcastMsg(id, name) {\n      var broadcastMsg;\n      if (id) {\n        broadcastMsg = this.lookupVariableById(id);\n      } else if (name) {\n        broadcastMsg = this.lookupBroadcastByInputValue(name);\n      } else {\n        log.error('Cannot find broadcast message if neither id nor name are provided.');\n      }\n      if (broadcastMsg) {\n        if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {\n          log.error(\"Found broadcast message with id: \".concat(id, \", but\") + \"its name, \".concat(broadcastMsg.name, \" did not match expected name \").concat(name, \".\"));\n        }\n        if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {\n          log.error(\"Found variable with id: \".concat(id, \", but its type \").concat(broadcastMsg.type) + \"did not match expected type \".concat(Variable.BROADCAST_MESSAGE_TYPE));\n        }\n        return broadcastMsg;\n      }\n    }\n\n    /**\n     * Look up a broadcast message with the given name and return the variable\n     * if it exists. Does not create a new broadcast message variable if\n     * it doesn't exist.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n  }, {\n    key: \"lookupBroadcastByInputValue\",\n    value: function lookupBroadcastByInputValue(name) {\n      var vars = this.variables;\n      for (var propName in vars) {\n        if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {\n          return vars[propName];\n        }\n      }\n    }\n\n    /**\n     * Look up a variable object.\n     * Search begins for local variables; then look for globals.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n  }, {\n    key: \"lookupVariableById\",\n    value: function lookupVariableById(id) {\n      // If we have a local copy, return it.\n      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n        return this.variables[id];\n      }\n      // If the stage has a global copy, return it.\n      if (this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage && Object.prototype.hasOwnProperty.call(stage.variables, id)) {\n          return stage.variables[id];\n        }\n      }\n    }\n\n    /**\n     * Look up a variable object by its name and variable type.\n     * Search begins with local variables; then global variables if a local one\n     * was not found.\n     * @param {string} name Name of the variable.\n     * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.\n     * @param {?bool} skipStage Optional flag to skip checking the stage\n     * @return {?Variable} Variable object if found, or null if not.\n     */\n  }, {\n    key: \"lookupVariableByNameAndType\",\n    value: function lookupVariableByNameAndType(name, type, skipStage) {\n      if (typeof name !== 'string') return;\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      for (var varId in this.variables) {\n        var currVar = this.variables[varId];\n        if (currVar.name === name && currVar.type === type) {\n          return currVar;\n        }\n      }\n      if (!skipStage && this.runtime && !this.isStage) {\n        var stage = this.runtime.getTargetForStage();\n        if (stage) {\n          for (var _varId in stage.variables) {\n            var _currVar = stage.variables[_varId];\n            if (_currVar.name === name && _currVar.type === type) {\n              return _currVar;\n            }\n          }\n        }\n      }\n      return null;\n    }\n\n    /**\n    * Look up a list object for this target, and create it if one doesn't exist.\n    * Search begins for local lists; then look for globals.\n    * @param {!string} id Id of the list.\n    * @param {!string} name Name of the list.\n    * @return {!Varible} Variable object representing the found/created list.\n     */\n  }, {\n    key: \"lookupOrCreateList\",\n    value: function lookupOrCreateList(id, name) {\n      var list = this.lookupVariableById(id);\n      if (list) return list;\n      list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);\n      if (list) return list;\n\n      // No variable with this name exists - create it locally.\n      var newList = new Variable(id, name, Variable.LIST_TYPE, false);\n      this.variables[id] = newList;\n      return newList;\n    }\n\n    /**\n     * Creates a variable with the given id and name and adds it to the\n     * dictionary of variables.\n     * @param {string} id Id of variable\n     * @param {string} name Name of variable.\n     * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'\n     * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.\n     * Additional checks are made that the variable can be created as a cloud variable.\n     */\n  }, {\n    key: \"createVariable\",\n    value: function createVariable(id, name, type, isCloud) {\n      if (!Object.prototype.hasOwnProperty.call(this.variables, id)) {\n        var newVariable = new Variable(id, name, type, false);\n        if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {\n          newVariable.isCloud = true;\n          this.runtime.addCloudVariable();\n          this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);\n        }\n        this.variables[id] = newVariable;\n      }\n    }\n\n    /**\n     * Creates a comment with the given properties.\n     * @param {string} id Id of the comment.\n     * @param {string} blockId Optional id of the block the comment is attached\n     * to if it is a block comment.\n     * @param {string} text The text the comment contains.\n     * @param {number} x The x coordinate of the comment on the workspace.\n     * @param {number} y The y coordinate of the comment on the workspace.\n     * @param {number} width The width of the comment when it is full size\n     * @param {number} height The height of the comment when it is full size\n     * @param {boolean} minimized Whether the comment is minimized.\n     */\n  }, {\n    key: \"createComment\",\n    value: function createComment(id, blockId, text, x, y, width, height, minimized) {\n      if (!Object.prototype.hasOwnProperty.call(this.comments, id)) {\n        var newComment = new Comment(id, text, x, y, width, height, minimized);\n        if (blockId) {\n          newComment.blockId = blockId;\n          var blockWithComment = this.blocks.getBlock(blockId);\n          if (blockWithComment) {\n            blockWithComment.comment = id;\n          } else {\n            log.warn(\"Could not find block with id \".concat(blockId, \" associated with commentId: \").concat(id));\n          }\n        }\n        this.comments[id] = newComment;\n      }\n    }\n\n    /**\n     * Renames the variable with the given id to newName.\n     * @param {string} id Id of variable to rename.\n     * @param {string} newName New name for the variable.\n     */\n  }, {\n    key: \"renameVariable\",\n    value: function renameVariable(id, newName) {\n      var _this2 = this;\n      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n        var variable = this.variables[id];\n        if (variable.id === id) {\n          var oldName = variable.name;\n          variable.name = newName;\n          if (this.runtime) {\n            if (variable.isCloud && this.isStage) {\n              this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);\n            }\n            if (variable.type === Variable.SCALAR_TYPE) {\n              // sensing__of may be referencing to this variable.\n              // Change the reference.\n              var blockUpdated = false;\n              this.runtime.targets.forEach(function (t) {\n                blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, _this2.isStage ? '_stage_' : _this2.getName()) || blockUpdated;\n              });\n              // Request workspace change only if sensing_of blocks were actually updated.\n              if (blockUpdated) this.runtime.requestBlocksUpdate();\n            }\n            var blocks = this.runtime.monitorBlocks;\n            blocks.changeBlock({\n              id: id,\n              element: 'field',\n              name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',\n              value: id\n            }, this.runtime);\n            var monitorBlock = blocks.getBlock(variable.id);\n            if (monitorBlock) {\n              this.runtime.requestUpdateMonitor(Map$1({\n                id: id,\n                params: blocks._getBlockParams(monitorBlock)\n              }));\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Removes the variable with the given id from the dictionary of variables.\n     * @param {string} id Id of variable to delete.\n     */\n  }, {\n    key: \"deleteVariable\",\n    value: function deleteVariable(id) {\n      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n        // Get info about the variable before deleting it\n        var deletedVariableName = this.variables[id].name;\n        var deletedVariableWasCloud = this.variables[id].isCloud;\n        delete this.variables[id];\n        if (this.runtime) {\n          if (deletedVariableWasCloud && this.isStage) {\n            this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);\n            this.runtime.removeCloudVariable();\n          }\n          this.runtime.monitorBlocks.deleteBlock(id);\n          this.runtime.requestRemoveMonitor(id);\n        }\n      }\n    }\n\n    /**\n     * Remove this target's monitors from the runtime state and remove the\n     * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).\n     * NOTE: This does not delete any of the stage monitors like backdrop name.\n     */\n  }, {\n    key: \"deleteMonitors\",\n    value: function deleteMonitors() {\n      var _this3 = this;\n      this.runtime.requestRemoveMonitorByTargetId(this.id);\n      var targetSpecificMonitorBlockIds;\n      if (this.isStage) {\n        // This only deletes global variables and not other stage monitors like backdrop number.\n        targetSpecificMonitorBlockIds = Object.keys(this.variables);\n      } else {\n        targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(function (key) {\n          return _this3.runtime.monitorBlocks._blocks[key].targetId === _this3.id;\n        });\n      }\n      var _iterator = _createForOfIteratorHelper$4(targetSpecificMonitorBlockIds),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var blockId = _step.value;\n          this.runtime.monitorBlocks.deleteBlock(blockId);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * Create a clone of the variable with the given id from the dictionary of\n     * this target's variables.\n     * @param {string} id Id of variable to duplicate.\n     * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID\n     * for the duplicate variable. This is necessary when cloning a sprite, for example.\n     * @return {?Variable} The duplicated variable, or null if\n     * the original variable was not found.\n     */\n  }, {\n    key: \"duplicateVariable\",\n    value: function duplicateVariable(id, optKeepOriginalId) {\n      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n        var originalVariable = this.variables[id];\n        var newVariable = new Variable(optKeepOriginalId ? id : null,\n        // conditionally keep original id or generate a new one\n        originalVariable.name, originalVariable.type, originalVariable.isCloud);\n        if (newVariable.type === Variable.LIST_TYPE) {\n          newVariable.value = originalVariable.value.slice(0);\n        } else {\n          newVariable.value = originalVariable.value;\n        }\n        return newVariable;\n      }\n      return null;\n    }\n\n    /**\n     * Duplicate the dictionary of this target's variables as part of duplicating.\n     * this target or making a clone.\n     * @param {object=} optBlocks Optional block container for the target being duplicated.\n     * If provided, new variables will be generated with new UIDs and any variable references\n     * in this blocks container will be updated to refer to the corresponding new IDs.\n     * @return {object} The duplicated dictionary of variables\n     */\n  }, {\n    key: \"duplicateVariables\",\n    value: function duplicateVariables(optBlocks) {\n      var _this4 = this;\n      var allVarRefs;\n      if (optBlocks) {\n        allVarRefs = optBlocks.getAllVariableAndListReferences();\n      }\n      return Object.keys(this.variables).reduce(function (accum, varId) {\n        var newVariable = _this4.duplicateVariable(varId, !optBlocks);\n        accum[newVariable.id] = newVariable;\n        if (optBlocks && allVarRefs) {\n          var currVarRefs = allVarRefs[varId];\n          if (currVarRefs) {\n            _this4.mergeVariables(varId, newVariable.id, currVarRefs);\n          }\n        }\n        return accum;\n      }, {});\n    }\n\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     * @abstract\n     */\n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo() {}\n\n    /**\n     * Retrieve custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to retrieve.\n     * @returns {*} the associated state, if any was found.\n     */\n  }, {\n    key: \"getCustomState\",\n    value: function getCustomState(stateId) {\n      return this._customState[stateId];\n    }\n\n    /**\n     * Store custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to store on this target.\n     * @param {*} newValue - the state value to store.\n     */\n  }, {\n    key: \"setCustomState\",\n    value: function setCustomState(stateId, newValue) {\n      this._customState[stateId] = newValue;\n    }\n\n    /**\n     * Call to destroy a target.\n     * @abstract\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._customState = {};\n      if (this.runtime) {\n        this.runtime.removeExecutable(this);\n      }\n    }\n\n    // Variable Conflict Resolution Helpers\n\n    /**\n     * Get the names of all the variables of the given type that are in scope for this target.\n     * For targets that are not the stage, this includes any target-specific\n     * variables as well as any stage variables unless the skipStage flag is true.\n     * For the stage, this is all stage variables.\n     * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE\n     * @param {?bool} skipStage Optional flag to skip the stage.\n     * @return {Array<string>} A list of variable names\n     */\n  }, {\n    key: \"getAllVariableNamesInScopeByType\",\n    value: function getAllVariableNamesInScopeByType(type, skipStage) {\n      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n      skipStage = skipStage || false;\n      var targetVariables = Object.values(this.variables).filter(function (v) {\n        return v.type === type;\n      }).map(function (variable) {\n        return variable.name;\n      });\n      if (skipStage || this.isStage || !this.runtime) {\n        return targetVariables;\n      }\n      var stage = this.runtime.getTargetForStage();\n      var stageVariables = stage.getAllVariableNamesInScopeByType(type);\n      return targetVariables.concat(stageVariables);\n    }\n\n    /**\n     * Merge variable references with another variable.\n     * @param {string} idToBeMerged ID of the variable whose references need to be updated\n     * @param {string} idToMergeWith ID of the variable that the old references should be replaced with\n     * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.\n     * Defaults to all the blocks in this target.\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n  }, {\n    key: \"mergeVariables\",\n    value: function mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {\n      var referencesToChange = optReferencesToUpdate ||\n      // TODO should there be a separate helper function that traverses the blocks\n      // for all references for a given ID instead of doing the below..?\n      this.blocks.getAllVariableAndListReferences()[idToBeMerged];\n      VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);\n    }\n\n    /**\n     * Share a local variable (and given references for that variable) to the stage.\n     * @param {string} varId The ID of the variable to share.\n     * @param {Array<object>} varRefs The list of variable references being shared,\n     * that reference the given variable ID. The names and IDs of these variable\n     * references will be updated to refer to the new (or pre-existing) global variable.\n     */\n  }, {\n    key: \"shareLocalVariableToStage\",\n    value: function shareLocalVariableToStage(varId, varRefs) {\n      if (!this.runtime) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Cannot share a local variable to the stage if it's not local.\");\n        return;\n      }\n      var stage = this.runtime.getTargetForStage();\n      // If a local var is being shared with the stage,\n      // sharing will make the variable global, resulting in a conflict\n      // with the existing local variable. Preemptively Resolve this conflict\n      // by renaming the new global variable.\n\n      // First check if we've already done the local to global transition for this\n      // variable. If we have, merge it with the global variable we've already created.\n      var varIdForStage = \"StageVarFromLocal_\".concat(varId);\n      var stageVar = stage.lookupVariableById(varIdForStage);\n      // If a global var doesn't already exist, create a new one with a fresh name.\n      // Use the ID we created above so that we can lookup this new variable in the\n      // future if we decide to share this same variable again.\n      if (!stageVar) {\n        var varName = variable.name;\n        var varType = variable.type;\n        var newStageName = \"Stage: \".concat(varName);\n        stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);\n      }\n      // Update all variable references to use the new name and ID\n      this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);\n    }\n\n    /**\n     * Share a local variable with a sprite, merging with one of the same name and\n     * type if it already exists on the sprite, or create a new one.\n     * @param {string} varId Id of the variable to share\n     * @param {Target} sprite The sprite to share the variable with\n     * @param {Array<object>} varRefs A list of all the variable references currently being shared.\n     */\n  }, {\n    key: \"shareLocalVariableToSprite\",\n    value: function shareLocalVariableToSprite(varId, sprite, varRefs) {\n      if (!this.runtime) return;\n      if (this.isStage) return;\n      var variable = this.variables[varId];\n      if (!variable) {\n        log.warn(\"Tried to call 'shareLocalVariableToSprite' with a non-local variable.\");\n        return;\n      }\n      var varName = variable.name;\n      var varType = variable.type;\n      // Check if the receiving sprite already has a variable of the same name and type\n      // and use the existing variable, otherwise create a new one.\n      var existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);\n      var newVarId;\n      if (existingLocalVar) {\n        newVarId = existingLocalVar.id;\n      } else {\n        var newVar = new Variable(null, varName, varType);\n        newVarId = newVar.id;\n        sprite.variables[newVarId] = newVar;\n      }\n\n      // Merge with the local variable on the new sprite.\n      this.mergeVariables(varId, newVarId, varRefs);\n    }\n\n    /**\n     * Given a list of variable referencing fields, shares those variables with\n     * the target with the provided id, resolving any variable conflicts that arise\n     * using the following rules:\n     *\n     * If this target is the stage, exit. There are no conflicts that arise\n     * from sharing variables from the stage to another sprite. The variables\n     * already exist globally, so no further action is needed.\n     *\n     * If a variable being referenced is a global variable, do nothing. The\n     * global variable already exists so no further action is needed.\n     *\n     * If a variable being referenced is local, and\n     * 1) The receiving target is a sprite:\n     * create a new local variable or merge with an existing local variable\n     * of the same name and type. Update all the referencing fields\n     * for the original variable to reference the new variable.\n     * 2) The receiving target is the stage:\n     * Create a new global variable with a fresh name and update all the referencing\n     * fields to reference the new variable.\n     *\n     * @param {Array<object>} blocks The blocks containing\n     * potential conflicting references to variables.\n     * @param {Target} receivingTarget The target receiving the variables\n     */\n  }, {\n    key: \"resolveVariableSharingConflictsWithTarget\",\n    value: function resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {\n      if (this.isStage) return;\n\n      // Get all the variable references in the given list of blocks\n      var allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks);\n\n      // For all the variables being referenced, check for which ones are local\n      // to this target, and resolve conflicts based on whether the receiving target\n      // is a sprite (with a conflicting local variable) or whether it is\n      // the stage (which cannot have local variables)\n      for (var varId in allVarListRefs) {\n        var currVar = this.variables[varId];\n        if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.\n\n        // Get the list of references for the current variable id\n        var currVarListRefs = allVarListRefs[varId];\n        if (receivingTarget.isStage) {\n          this.shareLocalVariableToStage(varId, currVarListRefs);\n        } else {\n          this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);\n        }\n      }\n    }\n\n    /**\n     * Fixes up variable references in this target avoiding conflicts with\n     * pre-existing variables in the same scope.\n     * This is used when uploading this target as a new sprite into an existing\n     * project, where the new sprite may contain references\n     * to variable names that already exist as global variables in the project\n     * (and thus are in scope for variable references in the given sprite).\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable *does not* exist in this target (e.g. it was a global variable in the\n     * project the sprite was originally exported from), merge the variables. This entails\n     * fixing the variable references in this sprite to reference the id of the pre-existing global variable.\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),\n     * then the local variable is renamed to distinguish itself from the pre-existing variable.\n     * All blocks that reference the local variable will be updated to use the new name.\n     */\n    // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...\n  }, {\n    key: \"fixUpVariableReferences\",\n    value: function fixUpVariableReferences() {\n      var _this5 = this;\n      if (!this.runtime) return; // There's no runtime context to conflict with\n      if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)\n      var stage = this.runtime.getTargetForStage();\n      if (!stage || !stage.variables) return;\n      var renameConflictingLocalVar = function renameConflictingLocalVar(id, name, type) {\n        var conflict = stage.lookupVariableByNameAndType(name, type);\n        if (conflict) {\n          var newName = StringUtil$1.unusedName(\"\".concat(_this5.getName(), \": \").concat(name), _this5.getAllVariableNamesInScopeByType(type));\n          _this5.renameVariable(id, newName);\n          return newName;\n        }\n        return null;\n      };\n      var allReferences = this.blocks.getAllVariableAndListReferences();\n      var unreferencedLocalVarIds = [];\n      if (Object.keys(this.variables).length > 0) {\n        for (var localVarId in this.variables) {\n          if (!Object.prototype.hasOwnProperty.call(this.variables, localVarId)) continue;\n          if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);\n        }\n      }\n      var conflictIdsToReplace = Object.create(null);\n      var conflictNamesToReplace = Object.create(null);\n\n      // Cache the list of all variable names by type so that we don't need to\n      // re-calculate this in every iteration of the following loop.\n      var varNamesByType = {};\n      var allVarNames = function allVarNames(type) {\n        var namesOfType = varNamesByType[type];\n        if (namesOfType) return namesOfType;\n        varNamesByType[type] = _this5.runtime.getAllVarNamesOfType(type);\n        return varNamesByType[type];\n      };\n      var _loop = function _loop() {\n        // We don't care about which var ref we get, they should all have the same var info\n        var varRef = allReferences[varId][0];\n        var varName = varRef.referencingField.value;\n        var varType = varRef.type;\n        if (_this5.lookupVariableById(varId)) {\n          // Found a variable with the id in either the target or the stage,\n          // figure out which one.\n          if (Object.prototype.hasOwnProperty.call(_this5.variables, varId)) {\n            // If the target has the variable, then check whether the stage\n            // has one with the same name and type. If it does, then rename\n            // this target specific variable so that there is a distinction.\n            var newVarName = renameConflictingLocalVar(varId, varName, varType);\n            if (newVarName) {\n              // We are not calling this.blocks.updateBlocksAfterVarRename\n              // here because it will search through all the blocks. We already\n              // have access to all the references for this var id.\n              allReferences[varId].map(function (ref) {\n                ref.referencingField.value = newVarName;\n                return ref;\n              });\n            }\n          }\n        } else {\n          // We didn't find the referenced variable id anywhere,\n          // Treat it as a reference to a global variable (from the original\n          // project this sprite was exported from).\n          // Check for whether a global variable of the same name and type exists,\n          // and if so, track it to merge with the existing global in a second pass of the blocks.\n          var existingVar = stage.lookupVariableByNameAndType(varName, varType);\n          if (existingVar) {\n            if (!conflictIdsToReplace[varId]) {\n              conflictIdsToReplace[varId] = existingVar.id;\n            }\n          } else {\n            // A global variable with the same name did not already exist,\n            // create a new one such that it does not conflict with any\n            // names of local variables of the same type.\n            var allNames = allVarNames(varType);\n            var freshName = StringUtil$1.unusedName(varName, allNames);\n            stage.createVariable(varId, freshName, varType);\n            if (!conflictNamesToReplace[varId]) {\n              conflictNamesToReplace[varId] = freshName;\n            }\n          }\n        }\n      };\n      for (var varId in allReferences) {\n        _loop();\n      }\n      // Rename any local variables that were missed above because they aren't\n      // referenced by any blocks\n      for (var id in unreferencedLocalVarIds) {\n        var _varId2 = unreferencedLocalVarIds[id];\n        var name = this.variables[_varId2].name;\n        var type = this.variables[_varId2].type;\n        renameConflictingLocalVar(_varId2, name, type);\n      }\n      // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has\n      // blocks referencing some variable that the sprite does not own, and this\n      // variable conflicts with a global var)\n      // In this case, we want to merge the new variable referenes with the\n      // existing global variable\n      for (var conflictId in conflictIdsToReplace) {\n        var existingId = conflictIdsToReplace[conflictId];\n        var referencesToUpdate = allReferences[conflictId];\n        this.mergeVariables(conflictId, existingId, referencesToUpdate);\n      }\n\n      // Handle global var conflicts existing local vars (e.g a sprite is uploaded,\n      // and has blocks referencing some variable that the sprite does not own, and this\n      // variable conflcits with another sprite's local var).\n      // In this case, we want to go through the variable references and update\n      // the name of the variable in that reference.\n      var _loop2 = function _loop2() {\n        var newName = conflictNamesToReplace[_conflictId];\n        var referencesToUpdate = allReferences[_conflictId];\n        referencesToUpdate.map(function (ref) {\n          ref.referencingField.value = newName;\n          return ref;\n        });\n      };\n      for (var _conflictId in conflictNamesToReplace) {\n        _loop2();\n      }\n    }\n  }]);\n}(EventEmitter);\nvar target = Target$1;\n\nvar StageLayering$1 = /*#__PURE__*/function () {\n  function StageLayering() {\n    _classCallCheck(this, StageLayering);\n  }\n  return _createClass(StageLayering, null, [{\n    key: \"BACKGROUND_LAYER\",\n    get: function get() {\n      return 'background';\n    }\n  }, {\n    key: \"VIDEO_LAYER\",\n    get: function get() {\n      return 'video';\n    }\n  }, {\n    key: \"PEN_LAYER\",\n    get: function get() {\n      return 'pen';\n    }\n  }, {\n    key: \"SPRITE_LAYER\",\n    get: function get() {\n      return 'sprite';\n    }\n\n    // Order of layer groups relative to each other,\n  }, {\n    key: \"LAYER_GROUPS\",\n    get: function get() {\n      return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];\n    }\n  }]);\n}();\nvar stageLayering = StageLayering$1;\nvar StageLayering$2 = /*@__PURE__*/getDefaultExportFromCjs(stageLayering);\n\nfunction _callSuper$C(t, o, e) { return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$D() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$D() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$D = function _isNativeReflectConstruct() { return !!t; })(); }\nvar MathUtil = mathUtil;\nvar StringUtil = stringUtil;\nvar Cast = cast;\nvar Clone = clone;\nvar Target = target;\nvar StageLayering = stageLayering;\n\n/**\n * Rendered target: instance of a sprite (clone), or the stage.\n */\nvar RenderedTarget = /*#__PURE__*/function (_Target) {\n  /**\n   * @param {!Sprite} sprite Reference to the parent sprite.\n   * @param {Runtime} runtime Reference to the runtime.\n   * @constructor\n   */\n  function RenderedTarget(sprite, runtime) {\n    var _this;\n    _classCallCheck(this, RenderedTarget);\n    _this = _callSuper$C(this, RenderedTarget, [runtime, sprite.blocks]);\n\n    /**\n     * Reference to the sprite that this is a render of.\n     * @type {!Sprite}\n     */\n    _this.sprite = sprite;\n    /**\n     * Reference to the global renderer for this VM, if one exists.\n     * @type {?RenderWebGL}\n     */\n    _this.renderer = null;\n    if (_this.runtime) {\n      _this.renderer = _this.runtime.renderer;\n    }\n    /**\n     * ID of the drawable for this rendered target,\n     * returned by the renderer, if rendered.\n     * @type {?Number}\n     */\n    _this.drawableID = null;\n\n    /**\n     * Drag state of this rendered target. If true, x/y position can't be\n     * changed by blocks.\n     * @type {boolean}\n     */\n    _this.dragging = false;\n\n    /**\n     * Map of current graphic effect values.\n     * @type {!Object.<string, number>}\n     */\n    _this.effects = {\n      color: 0,\n      fisheye: 0,\n      whirl: 0,\n      pixelate: 0,\n      mosaic: 0,\n      brightness: 0,\n      ghost: 0\n    };\n\n    /**\n     * Whether this represents an \"original\" non-clone rendered-target for a sprite,\n     * i.e., created by the editor and not clone blocks.\n     * @type {boolean}\n     */\n    _this.isOriginal = true;\n\n    /**\n     * Whether this rendered target represents the Scratch stage.\n     * @type {boolean}\n     */\n    _this.isStage = false;\n\n    /**\n     * Scratch X coordinate. Currently should range from -240 to 240.\n     * @type {Number}\n     */\n    _this.x = 0;\n\n    /**\n     * Scratch Y coordinate. Currently should range from -180 to 180.\n     * @type {number}\n     */\n    _this.y = 0;\n\n    /**\n     * Scratch direction. Currently should range from -179 to 180.\n     * @type {number}\n     */\n    _this.direction = 90;\n\n    /**\n     * Whether the rendered target is draggable on the stage\n     * @type {boolean}\n     */\n    _this.draggable = false;\n\n    /**\n     * Whether the rendered target is currently visible.\n     * @type {boolean}\n     */\n    _this.visible = true;\n\n    /**\n     * Size of rendered target as a percent of costume size.\n     * @type {number}\n     */\n    _this.size = 100;\n\n    /**\n     * Currently selected costume index.\n     * @type {number}\n     */\n    _this.currentCostume = 0;\n\n    /**\n     * Current rotation style.\n     * @type {!string}\n     */\n    _this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n\n    /**\n     * Loudness for sound playback for this target, as a percentage.\n     * @type {number}\n     */\n    _this.volume = 100;\n\n    /**\n     * Current tempo (used by the music extension).\n     * This property is global to the project and stored in the stage.\n     * @type {number}\n     */\n    _this.tempo = 60;\n\n    /**\n     * The transparency of the video (used by extensions with camera input).\n     * This property is global to the project and stored in the stage.\n     * @type {number}\n     */\n    _this.videoTransparency = 50;\n\n    /**\n     * The state of the video input (used by extensions with camera input).\n     * This property is global to the project and stored in the stage.\n     *\n     * Defaults to ON. This setting does not turn the video by itself. A\n     * video extension once loaded will set the video device to this\n     * setting. Set to ON when a video extension is added in the editor the\n     * video will start ON. If the extension is loaded as part of loading a\n     * saved project the extension will see the value set when the stage\n     * was loaded from the saved values including the video state.\n     *\n     * @type {string}\n     */\n    _this.videoState = RenderedTarget.VIDEO_STATE.ON;\n\n    /**\n     * The language to use for speech synthesis, in the text2speech extension.\n     * It is initialized to null so that on extension load, we can check for\n     * this and try setting it using the editor locale.\n     * @type {string}\n     */\n    _this.textToSpeechLanguage = null;\n    return _this;\n  }\n\n  /**\n   * Create a drawable with the this.renderer.\n   * @param {boolean} layerGroup The layer group this drawable should be added to\n   */\n  _inherits$1(RenderedTarget, _Target);\n  return _createClass(RenderedTarget, [{\n    key: \"initDrawable\",\n    value: function initDrawable(layerGroup) {\n      if (this.renderer) {\n        this.drawableID = this.renderer.createDrawable(layerGroup);\n      }\n      // If we're a clone, start the hats.\n      if (!this.isOriginal) {\n        this.runtime.startHats('control_start_as_clone', null, this);\n      }\n    }\n  }, {\n    key: \"audioPlayer\",\n    get: function get() {\n      var _this2 = this;\n      /* eslint-disable no-console */\n      console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');\n      console.warn(new Error('stack for debug').stack);\n      /* eslint-enable no-console */\n      var bank = this.sprite.soundBank;\n      var audioPlayerProxy = {\n        playSound: function playSound(soundId) {\n          return bank.play(_this2, soundId);\n        }\n      };\n      Object.defineProperty(this, 'audioPlayer', {\n        configurable: false,\n        enumerable: true,\n        writable: false,\n        value: audioPlayerProxy\n      });\n      return audioPlayerProxy;\n    }\n\n    /**\n     * Initialize the audio player for this sprite or clone.\n     */\n  }, {\n    key: \"initAudio\",\n    value: function initAudio() {}\n\n    /**\n     * Event which fires when a target moves.\n     * @type {string}\n     */\n  }, {\n    key: \"setXY\",\n    value:\n    /**\n     * Set the X and Y coordinates.\n     * @param {!number} x New X coordinate, in Scratch coordinates.\n     * @param {!number} y New Y coordinate, in Scratch coordinates.\n     * @param {?boolean} force Force setting X/Y, in case of dragging\n     */\n    function setXY(x, y, force) {\n      if (this.isStage) return;\n      if (this.dragging && !force) return;\n      var oldX = this.x;\n      var oldY = this.y;\n      if (this.renderer) {\n        var position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);\n        this.x = position[0];\n        this.y = position[1];\n        this.renderer.updateDrawablePosition(this.drawableID, position);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      } else {\n        this.x = x;\n        this.y = y;\n      }\n      this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Get the rendered direction and scale, after applying rotation style.\n     * @return {object<string, number>} Direction and scale to render.\n     */\n  }, {\n    key: \"_getRenderedDirectionAndScale\",\n    value: function _getRenderedDirectionAndScale() {\n      // Default: no changes to `this.direction` or `this.scale`.\n      var finalDirection = this.direction;\n      var finalScale = [this.size, this.size];\n      if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        // Force rendered direction to be 90.\n        finalDirection = 90;\n      } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        // Force rendered direction to be 90, and flip drawable if needed.\n        finalDirection = 90;\n        var scaleFlip = this.direction < 0 ? -1 : 1;\n        finalScale = [scaleFlip * this.size, this.size];\n      }\n      return {\n        direction: finalDirection,\n        scale: finalScale\n      };\n    }\n\n    /**\n     * Set the direction.\n     * @param {!number} direction New direction.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      if (this.isStage) {\n        return;\n      }\n      if (!isFinite(direction)) {\n        return;\n      }\n      // Keep direction between -179 and +180.\n      this.direction = MathUtil.wrapClamp(direction, -179, 180);\n      if (this.renderer) {\n        var _this$_getRenderedDir = this._getRenderedDirectionAndScale(),\n          renderedDirection = _this$_getRenderedDir.direction,\n          scale = _this$_getRenderedDir.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set draggability; i.e., whether it's able to be dragged in the player\n     * @param {!boolean} draggable True if should be draggable.\n     */\n  }, {\n    key: \"setDraggable\",\n    value: function setDraggable(draggable) {\n      if (this.isStage) return;\n      this.draggable = !!draggable;\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set visibility; i.e., whether it's shown or hidden.\n     * @param {!boolean} visible True if should be shown.\n     */\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.isStage) {\n        return;\n      }\n      this.visible = !!visible;\n      if (this.renderer) {\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set size, as a percentage of the costume size.\n     * @param {!number} size Size of rendered target, as % of costume size.\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize(size) {\n      if (this.isStage) {\n        return;\n      }\n      if (this.renderer) {\n        // Clamp to scales relative to costume and stage size.\n        // See original ScratchSprite.as:setSize.\n        var costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);\n        var origW = costumeSize[0];\n        var origH = costumeSize[1];\n        var minScale = Math.min(1, Math.max(5 / origW, 5 / origH));\n        var maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);\n        this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;\n        var _this$_getRenderedDir2 = this._getRenderedDirectionAndScale(),\n          direction = _this$_getRenderedDir2.direction,\n          scale = _this$_getRenderedDir2.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set a particular graphic effect value.\n     * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).\n     * @param {!number} value Numerical magnitude of effect.\n     */\n  }, {\n    key: \"setEffect\",\n    value: function setEffect(effectName, value) {\n      if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) return;\n      this.effects[effectName] = value;\n      if (this.renderer) {\n        this.renderer.updateDrawableEffect(this.drawableID, effectName, value);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n\n    /**\n     * Clear all graphic effects on this rendered target.\n     */\n  }, {\n    key: \"clearEffects\",\n    value: function clearEffects() {\n      for (var effectName in this.effects) {\n        if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;\n        this.effects[effectName] = 0;\n      }\n      if (this.renderer) {\n        for (var _effectName in this.effects) {\n          if (!Object.prototype.hasOwnProperty.call(this.effects, _effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, _effectName, 0);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n\n    /**\n     * Set the current costume.\n     * @param {number} index New index of costume.\n     */\n  }, {\n    key: \"setCostume\",\n    value: function setCostume(index) {\n      // Keep the costume index within possible values.\n      index = Math.round(index);\n      if ([Infinity, -Infinity, NaN].includes(index)) index = 0;\n      this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);\n      if (this.renderer) {\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Add a costume, taking care to avoid duplicate names.\n     * @param {!object} costumeObject Object representing the costume.\n     * @param {?int} index Index at which to add costume\n     */\n  }, {\n    key: \"addCostume\",\n    value: function addCostume(costumeObject, index) {\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.addCostumeAt(costumeObject, index);\n      } else {\n        this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);\n      }\n    }\n\n    /**\n     * Rename a costume, taking care to avoid duplicate names.\n     * @param {int} costumeIndex - the index of the costume to be renamed.\n     * @param {string} newName - the desired new name of the costume (will be modified if already in use).\n     */\n  }, {\n    key: \"renameCostume\",\n    value: function renameCostume(costumeIndex, newName) {\n      var usedNames = this.sprite.costumes.filter(function (costume, index) {\n        return costumeIndex !== index;\n      }).map(function (costume) {\n        return costume.name;\n      });\n      var oldName = this.getCostumes()[costumeIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.getCostumes()[costumeIndex].name = newUnusedName;\n      if (this.isStage) {\n        // Since this is a backdrop, go through all targets and\n        // update any blocks referencing the old backdrop name\n        var targets = this.runtime.targets;\n        for (var i = 0; i < targets.length; i++) {\n          var currTarget = targets[i];\n          currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');\n        }\n      } else {\n        this.blocks.updateAssetName(oldName, newUnusedName, 'costume');\n      }\n    }\n\n    /**\n     * Delete a costume by index.\n     * @param {number} index Costume index to be deleted\n     * @return {?object} The costume that was deleted or null\n     * if the index was out of bounds of the costumes list or\n     * this target only has one costume.\n     */\n  }, {\n    key: \"deleteCostume\",\n    value: function deleteCostume(index) {\n      var originalCostumeCount = this.sprite.costumes.length;\n      if (originalCostumeCount === 1) return null;\n      if (index < 0 || index >= originalCostumeCount) {\n        return null;\n      }\n      var deletedCostume = this.sprite.deleteCostumeAt(index);\n      if (index === this.currentCostume && index === originalCostumeCount - 1) {\n        this.setCostume(index - 1);\n      } else if (index < this.currentCostume) {\n        this.setCostume(this.currentCostume - 1);\n      } else {\n        this.setCostume(this.currentCostume);\n      }\n      this.runtime.requestTargetsUpdate(this);\n      return deletedCostume;\n    }\n\n    /**\n     * Add a sound, taking care to avoid duplicate names.\n     * @param {!object} soundObject Object representing the sound.\n     * @param {?int} index Index at which to add costume\n     */\n  }, {\n    key: \"addSound\",\n    value: function addSound(soundObject, index) {\n      var usedNames = this.sprite.sounds.map(function (sound) {\n        return sound.name;\n      });\n      soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);\n      if (typeof index === 'number' && !isNaN(index)) {\n        this.sprite.sounds.splice(index, 0, soundObject);\n      } else {\n        this.sprite.sounds.push(soundObject);\n      }\n    }\n\n    /**\n     * Rename a sound, taking care to avoid duplicate names.\n     * @param {int} soundIndex - the index of the sound to be renamed.\n     * @param {string} newName - the desired new name of the sound (will be modified if already in use).\n     */\n  }, {\n    key: \"renameSound\",\n    value: function renameSound(soundIndex, newName) {\n      var usedNames = this.sprite.sounds.filter(function (sound, index) {\n        return soundIndex !== index;\n      }).map(function (sound) {\n        return sound.name;\n      });\n      var oldName = this.sprite.sounds[soundIndex].name;\n      var newUnusedName = StringUtil.unusedName(newName, usedNames);\n      this.sprite.sounds[soundIndex].name = newUnusedName;\n      this.blocks.updateAssetName(oldName, newUnusedName, 'sound');\n    }\n\n    /**\n     * Delete a sound by index.\n     * @param {number} index Sound index to be deleted\n     * @return {object} The deleted sound object, or null if no sound was deleted.\n     */\n  }, {\n    key: \"deleteSound\",\n    value: function deleteSound(index) {\n      // Make sure the sound index is not out of bounds\n      if (index < 0 || index >= this.sprite.sounds.length) {\n        return null;\n      }\n      // Delete the sound at the given index\n      var deletedSound = this.sprite.sounds.splice(index, 1)[0];\n      this.runtime.requestTargetsUpdate(this);\n      return deletedSound;\n    }\n\n    /**\n     * Update the rotation style.\n     * @param {!string} rotationStyle New rotation style.\n     */\n  }, {\n    key: \"setRotationStyle\",\n    value: function setRotationStyle(rotationStyle) {\n      if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n      }\n      if (this.renderer) {\n        var _this$_getRenderedDir3 = this._getRenderedDirectionAndScale(),\n          direction = _this$_getRenderedDir3.direction,\n          scale = _this$_getRenderedDir3.scale;\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Get a costume index of this rendered target, by name of the costume.\n     * @param {?string} costumeName Name of a costume.\n     * @return {number} Index of the named costume, or -1 if not present.\n     */\n  }, {\n    key: \"getCostumeIndexByName\",\n    value: function getCostumeIndexByName(costumeName) {\n      for (var i = 0; i < this.sprite.costumes.length; i++) {\n        if (this.getCostumes()[i].name === costumeName) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Get a costume of this rendered target by id.\n     * @return {object} current costume\n     */\n  }, {\n    key: \"getCurrentCostume\",\n    value: function getCurrentCostume() {\n      return this.getCostumes()[this.currentCostume];\n    }\n\n    /**\n     * Get full costume list\n     * @return {object[]} list of costumes\n     */\n  }, {\n    key: \"getCostumes\",\n    value: function getCostumes() {\n      return this.sprite.costumes;\n    }\n\n    /**\n     * Reorder costume list by moving costume at costumeIndex to newIndex.\n     * @param {!number} costumeIndex Index of the costume to move.\n     * @param {!number} newIndex New index for that costume.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n  }, {\n    key: \"reorderCostume\",\n    value: function reorderCostume(costumeIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);\n      costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);\n      if (newIndex === costumeIndex) return false;\n      var currentCostume = this.getCurrentCostume();\n      var costume = this.sprite.costumes[costumeIndex];\n\n      // Use the sprite method for deleting costumes because setCostume is handled manually\n      this.sprite.deleteCostumeAt(costumeIndex);\n      this.addCostume(costume, newIndex);\n      this.currentCostume = this.getCostumeIndexByName(currentCostume.name);\n      return true;\n    }\n\n    /**\n     * Reorder sound list by moving sound at soundIndex to newIndex.\n     * @param {!number} soundIndex Index of the sound to move.\n     * @param {!number} newIndex New index for that sound.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n  }, {\n    key: \"reorderSound\",\n    value: function reorderSound(soundIndex, newIndex) {\n      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);\n      soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);\n      if (newIndex === soundIndex) return false;\n      var sound = this.sprite.sounds[soundIndex];\n      this.deleteSound(soundIndex);\n      this.addSound(sound, newIndex);\n      return true;\n    }\n\n    /**\n     * Get full sound list\n     * @return {object[]} list of sounds\n     */\n  }, {\n    key: \"getSounds\",\n    value: function getSounds() {\n      return this.sprite.sounds;\n    }\n\n    /**\n     * Update all drawable properties for this rendered target.\n     * Use when a batch has changed, e.g., when the drawable is first created.\n     */\n  }, {\n    key: \"updateAllDrawableProperties\",\n    value: function updateAllDrawableProperties() {\n      if (this.renderer) {\n        var _this$_getRenderedDir4 = this._getRenderedDirectionAndScale(),\n          direction = _this$_getRenderedDir4.direction,\n          scale = _this$_getRenderedDir4.scale;\n        this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);\n        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n        this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n        var costume = this.getCostumes()[this.currentCostume];\n        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n        for (var effectName in this.effects) {\n          if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;\n          this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);\n        }\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n      this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Return the human-readable name for this rendered target, e.g., the sprite's name.\n     * @override\n     * @returns {string} Human-readable name.\n     */\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.sprite.name;\n    }\n\n    /**\n     * Return whether this rendered target is a sprite (not a clone, not the stage).\n     * @return {boolean} True if not a clone and not the stage.\n     */\n  }, {\n    key: \"isSprite\",\n    value: function isSprite() {\n      return !this.isStage && this.isOriginal;\n    }\n\n    /**\n     * Return the rendered target's tight bounding box.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n  }, {\n    key: \"getBounds\",\n    value: function getBounds() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBounds(this.drawableID);\n      }\n      return null;\n    }\n\n    /**\n     * Return the bounding box around a slice of the top 8px of the rendered target.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n  }, {\n    key: \"getBoundsForBubble\",\n    value: function getBoundsForBubble() {\n      if (this.renderer) {\n        return this.runtime.renderer.getBoundsForBubble(this.drawableID);\n      }\n      return null;\n    }\n\n    /**\n     * Return whether this target is touching the mouse, an edge, or a sprite.\n     * @param {string} requestedObject an id for mouse or edge, or a sprite name.\n     * @return {boolean} True if the sprite is touching the object.\n     */\n  }, {\n    key: \"isTouchingObject\",\n    value: function isTouchingObject(requestedObject) {\n      if (requestedObject === '_mouse_') {\n        if (!this.runtime.ioDevices.mouse) return false;\n        var mouseX = this.runtime.ioDevices.mouse.getClientX();\n        var mouseY = this.runtime.ioDevices.mouse.getClientY();\n        return this.isTouchingPoint(mouseX, mouseY);\n      } else if (requestedObject === '_edge_') {\n        return this.isTouchingEdge();\n      }\n      return this.isTouchingSprite(requestedObject);\n    }\n\n    /**\n     * Return whether touching a point.\n     * @param {number} x X coordinate of test point.\n     * @param {number} y Y coordinate of test point.\n     * @return {boolean} True iff the rendered target is touching the point.\n     */\n  }, {\n    key: \"isTouchingPoint\",\n    value: function isTouchingPoint(x, y) {\n      if (this.renderer) {\n        return this.renderer.drawableTouching(this.drawableID, x, y);\n      }\n      return false;\n    }\n\n    /**\n     * Return whether touching a stage edge.\n     * @return {boolean} True iff the rendered target is touching the stage edge.\n     */\n  }, {\n    key: \"isTouchingEdge\",\n    value: function isTouchingEdge() {\n      if (this.renderer) {\n        var stageWidth = this.runtime.constructor.STAGE_WIDTH;\n        var stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n        var bounds = this.getBounds();\n        if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Return whether touching any of a named sprite's clones.\n     * @param {string} spriteName Name of the sprite.\n     * @return {boolean} True iff touching a clone of the sprite.\n     */\n  }, {\n    key: \"isTouchingSprite\",\n    value: function isTouchingSprite(spriteName) {\n      spriteName = Cast.toString(spriteName);\n      var firstClone = this.runtime.getSpriteTargetByName(spriteName);\n      if (!firstClone || !this.renderer) {\n        return false;\n      }\n      // Filter out dragging targets. This means a sprite that is being dragged\n      // can detect other sprites using touching <sprite>, but cannot be detected\n      // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.\n      var drawableCandidates = firstClone.sprite.clones.filter(function (clone) {\n        return !clone.dragging;\n      }).map(function (clone) {\n        return clone.drawableID;\n      });\n      return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);\n    }\n\n    /**\n     * Return whether touching a color.\n     * @param {Array.<number>} rgb [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the rendered target is touching the color.\n     */\n  }, {\n    key: \"isTouchingColor\",\n    value: function isTouchingColor(rgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, rgb);\n      }\n      return false;\n    }\n\n    /**\n     * Return whether rendered target's color is touching a color.\n     * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the color is touching the color.\n     */\n  }, {\n    key: \"colorIsTouchingColor\",\n    value: function colorIsTouchingColor(targetRgb, maskRgb) {\n      if (this.renderer) {\n        return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);\n      }\n      return false;\n    }\n  }, {\n    key: \"getLayerOrder\",\n    value: function getLayerOrder() {\n      if (this.renderer) {\n        return this.renderer.getDrawableOrder(this.drawableID);\n      }\n      return null;\n    }\n\n    /**\n     * Move to the front layer.\n     */\n  }, {\n    key: \"goToFront\",\n    value: function goToFront() {\n      // This should only ever be used for sprites\n      if (this.renderer) {\n        // Let the renderer re-order the sprite based on its knowledge\n        // of what layers are present\n        this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);\n      }\n      this.runtime.setExecutablePosition(this, Infinity);\n    }\n\n    /**\n     * Move to the back layer.\n     */\n  }, {\n    key: \"goToBack\",\n    value: function goToBack() {\n      // This should only ever be used for sprites\n      if (this.renderer) {\n        // Let the renderer re-order the sprite based on its knowledge\n        // of what layers are present\n        this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);\n      }\n      this.runtime.setExecutablePosition(this, -Infinity);\n    }\n\n    /**\n     * Move forward a number of layers.\n     * @param {number} nLayers How many layers to go forward.\n     */\n  }, {\n    key: \"goForwardLayers\",\n    value: function goForwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, nLayers);\n    }\n\n    /**\n     * Move backward a number of layers.\n     * @param {number} nLayers How many layers to go backward.\n     */\n  }, {\n    key: \"goBackwardLayers\",\n    value: function goBackwardLayers(nLayers) {\n      if (this.renderer) {\n        this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);\n      }\n      this.runtime.moveExecutable(this, -nLayers);\n    }\n\n    /**\n     * Move behind some other rendered target.\n     * @param {!RenderedTarget} other Other rendered target to move behind.\n     */\n  }, {\n    key: \"goBehindOther\",\n    value: function goBehindOther(other) {\n      if (this.renderer) {\n        var otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);\n        this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);\n      }\n      var executionPosition = this.runtime.executableTargets.indexOf(other);\n      this.runtime.setExecutablePosition(this, executionPosition);\n    }\n\n    /**\n     * Keep a desired position within a fence.\n     * @param {number} newX New desired X position.\n     * @param {number} newY New desired Y position.\n     * @param {object=} optFence Optional fence with left, right, top bottom.\n     * @return {Array.<number>} Fenced X and Y coordinates.\n     */\n  }, {\n    key: \"keepInFence\",\n    value: function keepInFence(newX, newY, optFence) {\n      var fence = optFence;\n      if (!fence) {\n        fence = {\n          left: -this.runtime.constructor.STAGE_WIDTH / 2,\n          right: this.runtime.constructor.STAGE_WIDTH / 2,\n          top: this.runtime.constructor.STAGE_HEIGHT / 2,\n          bottom: -this.runtime.constructor.STAGE_HEIGHT / 2\n        };\n      }\n      var bounds = this.getBounds();\n      if (!bounds) return;\n      // Adjust the known bounds to the target position.\n      bounds.left += newX - this.x;\n      bounds.right += newX - this.x;\n      bounds.top += newY - this.y;\n      bounds.bottom += newY - this.y;\n      // Find how far we need to move the target position.\n      var dx = 0;\n      var dy = 0;\n      if (bounds.left < fence.left) {\n        dx += fence.left - bounds.left;\n      }\n      if (bounds.right > fence.right) {\n        dx += fence.right - bounds.right;\n      }\n      if (bounds.top > fence.top) {\n        dy += fence.top - bounds.top;\n      }\n      if (bounds.bottom < fence.bottom) {\n        dy += fence.bottom - bounds.bottom;\n      }\n      return [newX + dx, newY + dy];\n    }\n\n    /**\n     * Make a clone, copying any run-time properties.\n     * If we've hit the global clone limit, returns null.\n     * @return {RenderedTarget} New clone.\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (!this.runtime.clonesAvailable() || this.isStage) {\n        return null; // Hit max clone limit, or this is the stage.\n      }\n      this.runtime.changeCloneCounter(1);\n      var newClone = this.sprite.createClone();\n      // Copy all properties.\n      newClone.x = this.x;\n      newClone.y = this.y;\n      newClone.direction = this.direction;\n      newClone.draggable = this.draggable;\n      newClone.visible = this.visible;\n      newClone.size = this.size;\n      newClone.currentCostume = this.currentCostume;\n      newClone.rotationStyle = this.rotationStyle;\n      newClone.effects = Clone.simple(this.effects);\n      newClone.variables = this.duplicateVariables();\n      newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);\n      newClone.initDrawable(StageLayering.SPRITE_LAYER);\n      newClone.updateAllDrawableProperties();\n      return newClone;\n    }\n\n    /**\n     * Make a duplicate using a duplicate sprite.\n     * @return {RenderedTarget} New clone.\n     */\n  }, {\n    key: \"duplicate\",\n    value: function duplicate() {\n      var _this3 = this;\n      return this.sprite.duplicate().then(function (newSprite) {\n        var newTarget = newSprite.createClone();\n        // Copy all properties.\n        // @todo refactor with clone methods\n        newTarget.x = (Math.random() - 0.5) * 400 / 2;\n        newTarget.y = (Math.random() - 0.5) * 300 / 2;\n        newTarget.direction = _this3.direction;\n        newTarget.draggable = _this3.draggable;\n        newTarget.visible = _this3.visible;\n        newTarget.size = _this3.size;\n        newTarget.currentCostume = _this3.currentCostume;\n        newTarget.rotationStyle = _this3.rotationStyle;\n        newTarget.effects = JSON.parse(JSON.stringify(_this3.effects));\n        newTarget.variables = _this3.duplicateVariables(newTarget.blocks);\n        newTarget.updateAllDrawableProperties();\n        return newTarget;\n      });\n    }\n\n    /**\n     * Called when the project receives a \"green flag.\"\n     * For a rendered target, this clears graphic effects.\n     */\n  }, {\n    key: \"onGreenFlag\",\n    value: function onGreenFlag() {\n      this.clearEffects();\n    }\n\n    /**\n     * Called when the project receives a \"stop all\"\n     * Stop all sounds and clear graphic effects.\n     */\n  }, {\n    key: \"onStopAll\",\n    value: function onStopAll() {\n      this.clearEffects();\n    }\n\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     */\n  }, {\n    key: \"postSpriteInfo\",\n    value: function postSpriteInfo(data) {\n      var force = Object.prototype.hasOwnProperty.call(data, 'force') ? data.force : null;\n      var isXChanged = Object.prototype.hasOwnProperty.call(data, 'x');\n      var isYChanged = Object.prototype.hasOwnProperty.call(data, 'y');\n      if (isXChanged || isYChanged) {\n        this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'direction')) {\n        this.setDirection(data.direction);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'draggable')) {\n        this.setDraggable(data.draggable);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'rotationStyle')) {\n        this.setRotationStyle(data.rotationStyle);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'visible')) {\n        this.setVisible(data.visible);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'size')) {\n        this.setSize(data.size);\n      }\n    }\n\n    /**\n     * Put the sprite into the drag state. While in effect, setXY must be forced\n     */\n  }, {\n    key: \"startDrag\",\n    value: function startDrag() {\n      this.dragging = true;\n    }\n\n    /**\n     * Remove the sprite from the drag state.\n     */\n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag() {\n      this.dragging = false;\n    }\n\n    /**\n     * Serialize sprite info, used when emitting events about the sprite\n     * @returns {object} Sprite data as a simple object\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var costumes = this.getCostumes();\n      return {\n        id: this.id,\n        name: this.getName(),\n        isStage: this.isStage,\n        x: this.x,\n        y: this.y,\n        size: this.size,\n        direction: this.direction,\n        draggable: this.draggable,\n        currentCostume: this.currentCostume,\n        costume: costumes[this.currentCostume],\n        costumeCount: costumes.length,\n        visible: this.visible,\n        rotationStyle: this.rotationStyle,\n        comments: this.comments,\n        blocks: this.blocks._blocks,\n        variables: this.variables,\n        costumes: costumes,\n        sounds: this.getSounds(),\n        textToSpeechLanguage: this.textToSpeechLanguage,\n        tempo: this.tempo,\n        volume: this.volume,\n        videoTransparency: this.videoTransparency,\n        videoState: this.videoState\n      };\n    }\n\n    /**\n     * Dispose, destroying any run-time properties.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.runtime.changeCloneCounter(-1);\n      this.runtime.stopForTarget(this);\n      this.runtime.removeExecutable(this);\n      this.sprite.removeClone(this);\n      if (this.renderer && this.drawableID !== null) {\n        this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);\n        if (this.visible) {\n          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n          this.runtime.requestRedraw();\n        }\n      }\n    }\n  }], [{\n    key: \"EVENT_TARGET_MOVED\",\n    get: function get() {\n      return 'TARGET_MOVED';\n    }\n\n    /**\n     * Event which fires when a target changes visually, for updating say bubbles.\n     * @type {string}\n     */\n  }, {\n    key: \"EVENT_TARGET_VISUAL_CHANGE\",\n    get: function get() {\n      return 'EVENT_TARGET_VISUAL_CHANGE';\n    }\n\n    /**\n     * Rotation style for \"all around\"/spinning.\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_ALL_AROUND\",\n    get: function get() {\n      return 'all around';\n    }\n\n    /**\n     * Rotation style for \"left-right\"/flipping.\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_LEFT_RIGHT\",\n    get: function get() {\n      return 'left-right';\n    }\n\n    /**\n     * Rotation style for \"no rotation.\"\n     * @type {string}\n     */\n  }, {\n    key: \"ROTATION_STYLE_NONE\",\n    get: function get() {\n      return \"don't rotate\";\n    }\n\n    /**\n     * Available states for video input.\n     * @enum {string}\n     */\n  }, {\n    key: \"VIDEO_STATE\",\n    get: function get() {\n      return {\n        OFF: 'off',\n        ON: 'on',\n        ON_FLIPPED: 'on-flipped'\n      };\n    }\n  }]);\n}(Target);\nvar renderedTarget = RenderedTarget;\nvar RenderedTarget$1 = /*@__PURE__*/getDefaultExportFromCjs(renderedTarget);\n\nvar en = {\n\t\"xcxVPen.name\": \"Vector Pen\",\n\t\"xcxVPen.clearAll\": \"erase all drawings\",\n\t\"xcxVPen.clear\": \"erase drawings of this sprite\",\n\t\"xcxVPen.eraseLast\": \"erase last drawing\",\n\t\"xcxVPen.penDown\": \"[PEN_TYPE] pen down\",\n\t\"xcxVPen.plot\": \"plot\",\n\t\"xcxVPen.setPenOpacity\": \"set pen opacity to [OPACITY]\",\n\t\"xcxVPen.setSize\": \"set pen size to [SIZE] mm\",\n\t\"xcxVPen.setLineShape\": \"set line shape to [LINE_SHAPE]\",\n\t\"xcxVPen.setFillColorToColor\": \"set fill color to [COLOR]\",\n\t\"xcxVPen.setFillOpacity\": \"set fill opacity to [OPACITY]\",\n\t\"xcxVPen.changeLayerTo\": \"change layer to [LAYER]\",\n\t\"xcxVPen.moveLayerBy\": \"move [DIRECTION] [LAYERS] layers\",\n\t\"xcxVPen.changeLayerMenu.top\": \"top\",\n\t\"xcxVPen.changeLayerMenu.bottom\": \"bottom\",\n\t\"xcxVPen.moveLayerDirectionMenu.up\": \"up\",\n\t\"xcxVPen.moveLayerDirectionMenu.down\": \"down\",\n\t\"xcxVPen.stepForMM\": \"steps for [MM] mm\",\n\t\"xcxVPen.mmForStep\": \"mm for [STEP] steps\",\n\t\"xcxVPen.getStepPerMM\": \"step/mm\",\n\t\"xcxVPen.setStepPerMM\": \"set step/mm to [STEP_PER_MM]\",\n\t\"xcxVPen.downloadSpriteDrawing\": \"download drawing by the sprite named [FILENAME]\",\n\t\"xcxVPen.downloadAllDrawing\": \"download all drawings named [FILENAME]\",\n\t\"xcxVPen.penTypesMenu.trail\": \"trail\",\n\t\"xcxVPen.penTypesMenu.plotter\": \"plotter\",\n\t\"xcxVPen.lineShapesMenu.straight\": \"straight\",\n\t\"xcxVPen.lineShapesMenu.curve\": \"curve\",\n\t\"xcxVPen.fileNameForSprite\": \"Enter a name for the file:\",\n\t\"xcxVPen.fileNameForAll\": \"Enter a name for the file:\"\n};\nvar ja = {\n\t\"xcxVPen.name\": \"ベクター ペン\",\n\t\"xcxVPen.clearAll\": \"すべての描画を消す\",\n\t\"xcxVPen.clear\": \"このスプライトの描画を消す\",\n\t\"xcxVPen.eraseLast\": \"最後の描画を消す\",\n\t\"xcxVPen.penDown\": \"[PEN_TYPE]ペンを下ろす\",\n\t\"xcxVPen.plot\": \"プロットする\",\n\t\"xcxVPen.setPenOpacity\": \"ペンの不透明度を[OPACITY]にする\",\n\t\"xcxVPen.setSize\": \"ペンの太さを[SIZE]mm にする\",\n\t\"xcxVPen.setLineShape\": \"線の種類を[LINE_SHAPE]にする\",\n\t\"xcxVPen.setFillColorToColor\": \"塗りつぶしの色を[COLOR]にする\",\n\t\"xcxVPen.setFillOpacity\": \"塗りつぶしの不透明度を[OPACITY]にする\",\n\t\"xcxVPen.changeLayerTo\": \"[LAYER]にする\",\n\t\"xcxVPen.moveLayerBy\": \"[LAYERS]層[DIRECTION]\",\n\t\"xcxVPen.changeLayerMenu.top\": \"最前面\",\n\t\"xcxVPen.changeLayerMenu.bottom\": \"最背面\",\n\t\"xcxVPen.moveLayerDirectionMenu.up\": \"手前へ出す\",\n\t\"xcxVPen.moveLayerDirectionMenu.down\": \"背後へ送る\",\n\t\"xcxVPen.stepForMM\": \"[MM]mm の歩数\",\n\t\"xcxVPen.mmForStep\": \"[STEP]歩の長さ(mm)\",\n\t\"xcxVPen.getStepPerMM\": \"歩/mm\",\n\t\"xcxVPen.setStepPerMM\": \"歩/mm を[STEP_PER_MM]にする\",\n\t\"xcxVPen.downloadSpriteDrawing\": \"このスプライトの描画をファイル[FILENAME]に保存する\",\n\t\"xcxVPen.downloadAllDrawing\": \"すべての描画をファイル[FILENAME]に保存する\",\n\t\"xcxVPen.penTypesMenu.trail\": \"トレイル\",\n\t\"xcxVPen.penTypesMenu.plotter\": \"プロッター\",\n\t\"xcxVPen.lineShapesMenu.straight\": \"直線\",\n\t\"xcxVPen.lineShapesMenu.curve\": \"曲線\",\n\t\"xcxVPen.fileNameForSprite\": \"ファイル名を入力してください:\",\n\t\"xcxVPen.fileNameForAll\": \"ファイル名を入力してください:\"\n};\nvar translations = {\n\ten: en,\n\tja: ja,\n\t\"ja-Hira\": {\n\t\"xcxVPen.name\": \"ベクター ペン\",\n\t\"xcxVPen.clearAll\": \"すべて の びょうが を けす\",\n\t\"xcxVPen.clear\": \"この スプライト の びょうが を けす\",\n\t\"xcxVPen.eraseLast\": \"さいご の びょうが を けす\",\n\t\"xcxVPen.penDown\": \"[PEN_TYPE]ペン を 下ろす\",\n\t\"xcxVPen.plot\": \"プロット する\",\n\t\"xcxVPen.setPenOpacity\": \"ペン の ふとうめいど を[OPACITY]に する\",\n\t\"xcxVPen.setSize\": \"ペン の ふとさ を[SIZE]mm に する\",\n\t\"xcxVPen.setLineShape\": \"せん の しゅるい を[LINE_SHAPE]に する\",\n\t\"xcxVPen.setFillColorToColor\": \"ぬりつぶし の いろ を[COLOR]に する\",\n\t\"xcxVPen.setFillOpacity\": \"ぬりつぶし の ふとうめいど を[OPACITY]に する\",\n\t\"xcxVPen.changeLayerTo\": \"[LAYER]に する\",\n\t\"xcxVPen.moveLayerBy\": \"[LAYERS]そう[DIRECTION]\",\n\t\"xcxVPen.changeLayerMenu.top\": \"さいぜんめん\",\n\t\"xcxVPen.changeLayerMenu.bottom\": \"さいはいめん\",\n\t\"xcxVPen.moveLayerDirectionMenu.up\": \"てまえ へ だす\",\n\t\"xcxVPen.moveLayerDirectionMenu.down\": \"はいご へ おくる\",\n\t\"xcxVPen.stepForMM\": \"[MM]mm の ほすう\",\n\t\"xcxVPen.mmForStep\": \"[STEP]ほ の ながさ(mm)\",\n\t\"xcxVPen.getStepPerMM\": \"ほ/mm\",\n\t\"xcxVPen.setStepPerMM\": \"ほ/mm を[STEP_PER_MM]に する\",\n\t\"xcxVPen.downloadSpriteDrawing\": \"この スプライト の びょうが を ファイル[FILENAME]に ほぞん する\",\n\t\"xcxVPen.downloadAllDrawing\": \"すべて の びょうが を ファイル[FILENAME]に ほぞん する\",\n\t\"xcxVPen.penTypesMenu.trail\": \"トレイル\",\n\t\"xcxVPen.penTypesMenu.plotter\": \"プロッター\",\n\t\"xcxVPen.lineShapesMenu.straight\": \"ちょくせん\",\n\t\"xcxVPen.lineShapesMenu.curve\": \"きょくせん\",\n\t\"xcxVPen.fileNameForSprite\": \"ファイルめい を にゅうりょく してください:\",\n\t\"xcxVPen.fileNameForAll\": \"ファイルめい を にゅぅりょく してください:\"\n}\n};\n\nvar img = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADUAAAA1CAYAAADh5qNwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABitJREFUaIHtmn9s1OUdx1/P93t33I9v7wqlhfaKMZVAKlCECVgT0eyfBZSFHwoOTfzDKqnKEh37Q8poDvfDLTPGhGzZqixTs2FQwbBgZF1WLCjOErrVdZJ1VVJGuEJT7nrtXfv98eyP4yqW0jvuOQY1ff3zTe6e7/s+r3ye57nnfggpJd80tBtdwPVgSmqyMCU1WZiSmixMSU0WXNclVQjB44/fA6xHiFqgCildQApN+xfQimW9xZ49ndfl5Qt+THriiW8DLwF3AGCakoEBgeOAywXBoETTxKXRf8JxtvHaa6cKWULhpDZu1AkGf4EQz+I40NUlOHUKenvh8tdwuSAchupqqKwEGAbqaWr6XWEKKZRUJKJx5swbwGb6+iQtLYL+/uz3VVbCvfdKfD6BlM/x6qsvqxdTqI3izJmdwGbOnoWDB3MTSt8H770nGBiQCPFL6uruL0Q56p168sk7cJw24nGNAwcEpnntGcXFsHatRNejpFLzefPNuEpJ6p2S8gWE0GltzU8I4OJFOHFCIMRs/P7vq5akJrVlyy3Aas6ehXPn1Crp7IRUSiLlFiIRpbrUpGx7FaDR1aUUcykLvvhCAJX09CxWiVKdft8C1LuUIRpNX4VYqhKjJiVEGIBEQilmlIGB9FXKsEqMaqfcSAmOoxhzia9y3CoxalJS9iEEeL1KMaP4fOmrEH0qMarTL30gnTlTKWaUkpL01XGUDrqqUn8B4NZblWJGSecMY5rHVGLUpJqaPkbKLubOlaNTJ18qKjKdepvXXx9Uibqmz1OHDh2aXVVV9Z1AIBAGhmMdHd2l7767Z2ZPz0/1FSugpSW/KnQdamslIJHyxfxCviJnqfb29tUrV67cZhhGMPPYnDlzMOfP1wbb2/tkW1uJL5nE88knX7tPCkEyHMZasQJRVIT88ksCR4+iWxYAsRk6oZp7YPp0gRAv0dT02f9F6uTJk7XV1dUNXq932tjn3G63416y5L+Ulxcl777bEzt8GPHhh5BMQjiMuOsuvEuW4Hend2kpJYmODtwNDZxYmOCpP5RTd8TN1g/EXxFiu6oQ5HBKj0Qirvr6+t+XlZXNn3CgaU6jt3culuXFsmBwkIkOuK2DreyY9waryjZyNNZs9drnX/nbzPZteVmMIavU8ePHly5fvrxJ07Tsn1EcR6evr5KhofQeb9tpMdMEIUDTQNf51P85Pyz6OauL1hHSirGx2Z/YF4va5379j9Bnz6tKZd39AoHALTkJAWiaTWnpacrLO/H7L+B2W3i9UFQEhgF+P58GTrHtMiEAHZ11xkOhWfrs+prYwp+pKeWwpuLx+DnHcUTOYgAeT5LS0tPAaUZGvDiOjmW5j4rjnu3OixUPBNbpGaEMGbH9iX31NbGFqHQsa6eam5vb+vv7u8c+PsKIGG/8FXg8KbzeweZpHzvPO40VawIbrhDKkBEr1cueWhxb8JOc8schq1RjY6PV3d398sjIyOiq/1Vq96za2PLF7dbJnN5x/2weDkZSjVXfDWzQg1pwwrE6OhuMTcESvezpRbHbf5xL/lhyOlEsW7bso87Ozp2JRCL22+HflO23DpTfH1irPz1UP6/NavNPdO8Rs8XYlYpUrQmszyqUQUfnQePh0Gy94pl81tg1ffFyX+/KH+ET2zcYm7we4eG8HeX9wYPWK/7d/77TdefQ2PFHzBZjR6ph7ppx1lAu5Lsr5nz2WxRfsNX0WT/ICAGU6rNYFVjjemaw/rbWRKvXNE3hOI4ohBDkvyvm1KlF8QVbgyL0wsPGo6GM0OWct6PsG/hj/9ILy7bURet69pXvrT1WcmzXQ0WbjXyFLudaO5ZVqubi7c+G9Bk7Nxmbi93jCGXotaO8k9h7YVgmd/m0QOR7xmPTc11DuWBj807irfgFO7r776F/Nkw0dkKpmovVzxXrM3ZuNB4JTSSUodeO0jz0fuKBwHqjkEIZbGzeTuyNnbejuztCnTuuNu6qUtmm3I0il6k47kZxswpBbpvHFVI3s1CGbGJfk5oMQhkmEhuVmkxCGa4mJqSUVA/cNk/a+gm/5ktp6NaNLDQfbBw95ST9Ulj3fR76T1vhf/O9CfhG/uVgSmqyMCU1WfgflKx65SYix1IAAAAASUVORK5CYII=\";\n\nfunction _createForOfIteratorHelper$3(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray$3(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }\nfunction _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar methods$1 = {};\nvar names = [];\nfunction registerMethods(name, m) {\n  if (Array.isArray(name)) {\n    var _iterator = _createForOfIteratorHelper$3(name),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _name = _step.value;\n        registerMethods(_name, m);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return;\n  }\n  if (_typeof$1(name) === 'object') {\n    for (var _name2 in name) {\n      registerMethods(_name2, name[_name2]);\n    }\n    return;\n  }\n  addMethodNames(Object.getOwnPropertyNames(m));\n  methods$1[name] = Object.assign(methods$1[name] || {}, m);\n}\nfunction getMethodsFor(name) {\n  return methods$1[name] || {};\n}\nfunction getMethodNames() {\n  return _toConsumableArray(new Set(names));\n}\nfunction addMethodNames(_names) {\n  names.push.apply(names, _toConsumableArray(_names));\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// Map function\nfunction map(array, block) {\n  var i;\n  var il = array.length;\n  var result = [];\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]));\n  }\n  return result;\n}\n\n// Filter function\nfunction filter(array, block) {\n  var i;\n  var il = array.length;\n  var result = [];\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n}\n\n// Degrees to radians\nfunction radians(d) {\n  return d % 360 * Math.PI / 180;\n}\n\n// Convert camel cased string to dash separated\nfunction unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase();\n  });\n}\n\n// Capitalize first letter of a string\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n// Calculate proportional width and height values when necessary\nfunction proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox();\n    if (width == null) {\n      width = box.width / box.height * height;\n    } else if (height == null) {\n      height = box.height / box.width * width;\n    }\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nfunction getOrigin(o, element) {\n  var origin = o.origin;\n  // First check if origin is in ox or originX\n  var ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';\n  var oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    var _ref = Array.isArray(origin) ? origin : _typeof$1(origin) === 'object' ? [origin.x, origin.y] : [origin, origin];\n    var _ref2 = _slicedToArray(_ref, 2);\n    ox = _ref2[0];\n    oy = _ref2[1];\n  }\n\n  // Make sure to only call bbox when actually needed\n  var condX = typeof ox === 'string';\n  var condY = typeof oy === 'string';\n  if (condX || condY) {\n    var _element$bbox = element.bbox(),\n      height = _element$bbox.height,\n      width = _element$bbox.width,\n      x = _element$bbox.x,\n      y = _element$bbox.y;\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left') ? x : ox.includes('right') ? x + width : x + width / 2;\n    }\n    if (condY) {\n      oy = oy.includes('top') ? y : oy.includes('bottom') ? y + height : y + height / 2;\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy];\n}\nvar descriptiveElements = new Set(['desc', 'metadata', 'title']);\nvar isDescriptive = function isDescriptive(element) {\n  return descriptiveElements.has(element.nodeName);\n};\nvar writeDataToDom = function writeDataToDom(element, data) {\n  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var cloned = _objectSpread$4({}, data);\n  for (var key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key];\n    }\n  }\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs');\n    element.node.removeAttribute('svgjs:data');\n  }\n};\n\n// Default namespaces\nvar svg = 'http://www.w3.org/2000/svg';\nvar html = 'http://www.w3.org/1999/xhtml';\nvar xmlns = 'http://www.w3.org/2000/xmlns/';\nvar xlink = 'http://www.w3.org/1999/xlink';\n\nvar globals = {\n  window: typeof window === 'undefined' ? null : window,\n  document: typeof document === 'undefined' ? null : document\n};\nfunction getWindow() {\n  return globals.window;\n}\n\nvar Base = /*#__PURE__*/_createClass$1(function Base() {\n  _classCallCheck$1(this, Base);\n});\n\nvar elements = {};\nvar root = '___SYMBOL___ROOT___';\n\n// Method for element creation\nfunction create(name) {\n  var ns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : svg;\n  // create element\n  return globals.document.createElementNS(ns, name);\n}\nfunction makeInstance(element) {\n  var isHTML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (element instanceof Base) return element;\n  if (_typeof$1(element) === 'object') {\n    return adopter(element);\n  }\n  if (element == null) {\n    return new elements[root]();\n  }\n  if (typeof element === 'string' && element.charAt(0) !== '<') {\n    return adopter(globals.document.querySelector(element));\n  }\n\n  // Make sure, that HTML elements are created with the correct namespace\n  var wrapper = isHTML ? globals.document.createElement('div') : create('svg');\n  wrapper.innerHTML = element;\n\n  // We can use firstChild here because we know,\n  // that the first char is < and thus an element\n  element = adopter(wrapper.firstChild);\n\n  // make sure, that element doesn't have its wrapper attached\n  wrapper.removeChild(wrapper.firstChild);\n  return element;\n}\nfunction nodeOrNew(name, node) {\n  return node && (node instanceof globals.window.Node || node.ownerDocument && node instanceof node.ownerDocument.defaultView.Node) ? node : create(name);\n}\n\n// Adopt existing svg elements\nfunction adopt(node) {\n  // check for presence of node\n  if (!node) return null;\n\n  // make sure a node isn't already adopted\n  if (node.instance instanceof Base) return node.instance;\n  if (node.nodeName === '#document-fragment') {\n    return new elements.Fragment(node);\n  }\n\n  // initialize variables\n  var className = capitalize(node.nodeName || 'Dom');\n\n  // Make sure that gradients are adopted correctly\n  if (className === 'LinearGradient' || className === 'RadialGradient') {\n    className = 'Gradient';\n\n    // Fallback to Dom if element is not known\n  } else if (!elements[className]) {\n    className = 'Dom';\n  }\n  return new elements[className](node);\n}\nvar adopter = adopt;\nfunction register(element) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.name;\n  var asRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  elements[name] = element;\n  if (asRoot) elements[root] = element;\n  addMethodNames(Object.getOwnPropertyNames(element.prototype));\n  return element;\n}\nfunction getClass(name) {\n  return elements[name];\n}\n\n// Element id sequence\nvar did = 1000;\n\n// Get next named element id\nfunction eid(name) {\n  return 'Svgjs' + capitalize(name) + did++;\n}\n\n// Deep new id assignment\nfunction assignNewId(node) {\n  // do the same for SVG child nodes as well\n  for (var i = node.children.length - 1; i >= 0; i--) {\n    assignNewId(node.children[i]);\n  }\n  if (node.id) {\n    node.id = eid(node.nodeName);\n    return node;\n  }\n  return node;\n}\n\n// Method for extending objects\nfunction extend(modules, methods) {\n  var key, i;\n  modules = Array.isArray(modules) ? modules : [modules];\n  for (i = modules.length - 1; i >= 0; i--) {\n    for (key in methods) {\n      modules[i].prototype[key] = methods[key];\n    }\n  }\n}\nfunction wrapWithAttrCheck(fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var o = args[args.length - 1];\n    if (o && o.constructor === Object && !(o instanceof Array)) {\n      return fn.apply(this, args.slice(0, -1)).attr(o);\n    } else {\n      return fn.apply(this, args);\n    }\n  };\n}\n\n// Get all siblings, including myself\nfunction siblings() {\n  return this.parent().children();\n}\n\n// Get the current position siblings\nfunction position() {\n  return this.parent().index(this);\n}\n\n// Get the next element (will return null if there is none)\nfunction next() {\n  return this.siblings()[this.position() + 1];\n}\n\n// Get the next element (will return null if there is none)\nfunction prev() {\n  return this.siblings()[this.position() - 1];\n}\n\n// Send given element one step forward\nfunction forward() {\n  var i = this.position();\n  var p = this.parent();\n\n  // move node one step forward\n  p.add(this.remove(), i + 1);\n  return this;\n}\n\n// Send given element one step backward\nfunction backward() {\n  var i = this.position();\n  var p = this.parent();\n  p.add(this.remove(), i ? i - 1 : 0);\n  return this;\n}\n\n// Send given element all the way to the front\nfunction front() {\n  var p = this.parent();\n\n  // Move node forward\n  p.add(this.remove());\n  return this;\n}\n\n// Send given element all the way to the back\nfunction back() {\n  var p = this.parent();\n\n  // Move node back\n  p.add(this.remove(), 0);\n  return this;\n}\n\n// Inserts a given element before the targeted element\nfunction before(element) {\n  element = makeInstance(element);\n  element.remove();\n  var i = this.position();\n  this.parent().add(element, i);\n  return this;\n}\n\n// Inserts a given element after the targeted element\nfunction after(element) {\n  element = makeInstance(element);\n  element.remove();\n  var i = this.position();\n  this.parent().add(element, i + 1);\n  return this;\n}\nfunction insertBefore(element) {\n  element = makeInstance(element);\n  element.before(this);\n  return this;\n}\nfunction insertAfter(element) {\n  element = makeInstance(element);\n  element.after(this);\n  return this;\n}\nregisterMethods('Dom', {\n  siblings: siblings,\n  position: position,\n  next: next,\n  prev: prev,\n  forward: forward,\n  backward: backward,\n  front: front,\n  back: back,\n  before: before,\n  after: after,\n  insertBefore: insertBefore,\n  insertAfter: insertAfter\n});\n\n// Parse unit value\nvar numberAndUnit = /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i;\n\n// Parse hex value\nvar hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\n// Parse rgb value\nvar rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/;\n\n// Parse reference id\nvar reference = /(#[a-z_][a-z0-9\\-_]*)/i;\n\n// splits a transformation chain\nvar transforms = /\\)\\s*,?\\s*/;\n\n// Whitespace\nvar whitespace = /\\s/g;\n\n// Test hex value\nvar isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;\n\n// Test rgb value\nvar isRgb = /^rgb\\(/;\n\n// Test for blank string\nvar isBlank = /^(\\s+)?$/;\n\n// Test for numeric string\nvar isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n\n// Test for image url\nvar isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i;\n\n// split at whitespace and comma\nvar delimiter = /[\\s,]+/;\n\n// Test for path letter\nvar isPathLetter = /[MLHVCSQTAZ]/i;\n\n// Return array of classes on the node\nfunction classes() {\n  var attr = this.attr('class');\n  return attr == null ? [] : attr.trim().split(delimiter);\n}\n\n// Return true if class exists on the node, false otherwise\nfunction hasClass(name) {\n  return this.classes().indexOf(name) !== -1;\n}\n\n// Add class to the node\nfunction addClass(name) {\n  if (!this.hasClass(name)) {\n    var array = this.classes();\n    array.push(name);\n    this.attr('class', array.join(' '));\n  }\n  return this;\n}\n\n// Remove class from the node\nfunction removeClass(name) {\n  if (this.hasClass(name)) {\n    this.attr('class', this.classes().filter(function (c) {\n      return c !== name;\n    }).join(' '));\n  }\n  return this;\n}\n\n// Toggle the presence of a class on the node\nfunction toggleClass(name) {\n  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n}\nregisterMethods('Dom', {\n  classes: classes,\n  hasClass: hasClass,\n  addClass: addClass,\n  removeClass: removeClass,\n  toggleClass: toggleClass\n});\n\nfunction _createForOfIteratorHelper$2(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray$2(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }\nfunction _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n// Dynamic style generator\nfunction css(style, val) {\n  var ret = {};\n  if (arguments.length === 0) {\n    // get full style as object\n    this.node.style.cssText.split(/\\s*;\\s*/).filter(function (el) {\n      return !!el.length;\n    }).forEach(function (el) {\n      var t = el.split(/\\s*:\\s*/);\n      ret[t[0]] = t[1];\n    });\n    return ret;\n  }\n  if (arguments.length < 2) {\n    // get style properties as array\n    if (Array.isArray(style)) {\n      var _iterator = _createForOfIteratorHelper$2(style),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var name = _step.value;\n          var cased = name;\n          ret[name] = this.node.style.getPropertyValue(cased);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return ret;\n    }\n\n    // get style for property\n    if (typeof style === 'string') {\n      return this.node.style.getPropertyValue(style);\n    }\n\n    // set styles in object\n    if (_typeof$1(style) === 'object') {\n      for (var _name in style) {\n        // set empty string if null/undefined/'' was given\n        this.node.style.setProperty(_name, style[_name] == null || isBlank.test(style[_name]) ? '' : style[_name]);\n      }\n    }\n  }\n\n  // set style for property\n  if (arguments.length === 2) {\n    this.node.style.setProperty(style, val == null || isBlank.test(val) ? '' : val);\n  }\n  return this;\n}\n\n// Show element\nfunction show() {\n  return this.css('display', '');\n}\n\n// Hide element\nfunction hide() {\n  return this.css('display', 'none');\n}\n\n// Is element visible?\nfunction visible() {\n  return this.css('display') !== 'none';\n}\nregisterMethods('Dom', {\n  css: css,\n  show: show,\n  hide: hide,\n  visible: visible\n});\n\nfunction _createForOfIteratorHelper$1(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray$1(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }\nfunction _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n// Store data values on svg nodes\nfunction data(a, v, r) {\n  if (a == null) {\n    // get an object of attributes\n    return this.data(map(filter(this.node.attributes, function (el) {\n      return el.nodeName.indexOf('data-') === 0;\n    }), function (el) {\n      return el.nodeName.slice(5);\n    }));\n  } else if (a instanceof Array) {\n    var _data = {};\n    var _iterator = _createForOfIteratorHelper$1(a),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n        _data[key] = this.data(key);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return _data;\n  } else if (_typeof$1(a) === 'object') {\n    for (v in a) {\n      this.data(v, a[v]);\n    }\n  } else if (arguments.length < 2) {\n    try {\n      return JSON.parse(this.attr('data-' + a));\n    } catch (e) {\n      return this.attr('data-' + a);\n    }\n  } else {\n    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n  }\n  return this;\n}\nregisterMethods('Dom', {\n  data: data\n});\n\n// Remember arbitrary data\nfunction remember(k, v) {\n  // remember every item in an object individually\n  if (_typeof$1(arguments[0]) === 'object') {\n    for (var key in k) {\n      this.remember(key, k[key]);\n    }\n  } else if (arguments.length === 1) {\n    // retrieve memory\n    return this.memory()[k];\n  } else {\n    // store memory\n    this.memory()[k] = v;\n  }\n  return this;\n}\n\n// Erase a given memory\nfunction forget() {\n  if (arguments.length === 0) {\n    this._memory = {};\n  } else {\n    for (var i = arguments.length - 1; i >= 0; i--) {\n      delete this.memory()[arguments[i]];\n    }\n  }\n  return this;\n}\n\n// This triggers creation of a new hidden class which is not performant\n// However, this function is not rarely used so it will not happen frequently\n// Return local memory object\nfunction memory() {\n  return this._memory = this._memory || {};\n}\nregisterMethods('Dom', {\n  remember: remember,\n  forget: forget,\n  memory: memory\n});\n\nfunction sixDigitHex(hex) {\n  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n}\nfunction componentHex(component) {\n  var integer = Math.round(component);\n  var bounded = Math.max(0, Math.min(255, integer));\n  var hex = bounded.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\nfunction is(object, space) {\n  for (var i = space.length; i--;) {\n    if (object[space[i]] == null) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getParameters(a, b) {\n  var params = is(a, 'rgb') ? {\n    _a: a.r,\n    _b: a.g,\n    _c: a.b,\n    _d: 0,\n    space: 'rgb'\n  } : is(a, 'xyz') ? {\n    _a: a.x,\n    _b: a.y,\n    _c: a.z,\n    _d: 0,\n    space: 'xyz'\n  } : is(a, 'hsl') ? {\n    _a: a.h,\n    _b: a.s,\n    _c: a.l,\n    _d: 0,\n    space: 'hsl'\n  } : is(a, 'lab') ? {\n    _a: a.l,\n    _b: a.a,\n    _c: a.b,\n    _d: 0,\n    space: 'lab'\n  } : is(a, 'lch') ? {\n    _a: a.l,\n    _b: a.c,\n    _c: a.h,\n    _d: 0,\n    space: 'lch'\n  } : is(a, 'cmyk') ? {\n    _a: a.c,\n    _b: a.m,\n    _c: a.y,\n    _d: a.k,\n    space: 'cmyk'\n  } : {\n    _a: 0,\n    _b: 0,\n    _c: 0,\n    space: 'rgb'\n  };\n  params.space = b || params.space;\n  return params;\n}\nfunction cieSpace(space) {\n  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\nvar Color = /*#__PURE__*/function () {\n  function Color() {\n    _classCallCheck$1(this, Color);\n    this.init.apply(this, arguments);\n  }\n\n  // Test if given value is a color\n  return _createClass$1(Color, [{\n    key: \"cmyk\",\n    value: function cmyk() {\n      // Get the rgb values for the current color\n      var _this$rgb = this.rgb(),\n        _a = _this$rgb._a,\n        _b = _this$rgb._b,\n        _c = _this$rgb._c;\n      var _map = [_a, _b, _c].map(function (v) {\n          return v / 255;\n        }),\n        _map2 = _slicedToArray(_map, 3),\n        r = _map2[0],\n        g = _map2[1],\n        b = _map2[2];\n\n      // Get the cmyk values in an unbounded format\n      var k = Math.min(1 - r, 1 - g, 1 - b);\n      if (k === 1) {\n        // Catch the black case\n        return new Color(0, 0, 0, 1, 'cmyk');\n      }\n      var c = (1 - r - k) / (1 - k);\n      var m = (1 - g - k) / (1 - k);\n      var y = (1 - b - k) / (1 - k);\n\n      // Construct the new color\n      var color = new Color(c, m, y, k, 'cmyk');\n      return color;\n    }\n  }, {\n    key: \"hsl\",\n    value: function hsl() {\n      // Get the rgb values\n      var _this$rgb2 = this.rgb(),\n        _a = _this$rgb2._a,\n        _b = _this$rgb2._b,\n        _c = _this$rgb2._c;\n      var _map3 = [_a, _b, _c].map(function (v) {\n          return v / 255;\n        }),\n        _map4 = _slicedToArray(_map3, 3),\n        r = _map4[0],\n        g = _map4[1],\n        b = _map4[2];\n\n      // Find the maximum and minimum values to get the lightness\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var l = (max + min) / 2;\n\n      // If the r, g, v values are identical then we are grey\n      var isGrey = max === min;\n\n      // Calculate the hue and saturation\n      var delta = max - min;\n      var s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n      var h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0;\n\n      // Construct and return the new color\n      var color = new Color(360 * h, 100 * s, 100 * l, 'hsl');\n      return color;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'rgb';\n      // This catches the case when a falsy value is passed like ''\n      a = !a ? 0 : a;\n\n      // Reset all values in case the init function is rerun with new color space\n      if (this.space) {\n        for (var component in this.space) {\n          delete this[this.space[component]];\n        }\n      }\n      if (typeof a === 'number') {\n        // Allow for the case that we don't need d...\n        space = typeof d === 'string' ? d : space;\n        d = typeof d === 'string' ? 0 : d;\n\n        // Assign the values straight to the color\n        Object.assign(this, {\n          _a: a,\n          _b: b,\n          _c: c,\n          _d: d,\n          space: space\n        });\n        // If the user gave us an array, make the color from it\n      } else if (a instanceof Array) {\n        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';\n        Object.assign(this, {\n          _a: a[0],\n          _b: a[1],\n          _c: a[2],\n          _d: a[3] || 0\n        });\n      } else if (a instanceof Object) {\n        // Set the object up and assign its values directly\n        var values = getParameters(a, b);\n        Object.assign(this, values);\n      } else if (typeof a === 'string') {\n        if (isRgb.test(a)) {\n          var noWhitespace = a.replace(whitespace, '');\n          var _rgb$exec$slice$map = rgb.exec(noWhitespace).slice(1, 4).map(function (v) {\n              return parseInt(v);\n            }),\n            _rgb$exec$slice$map2 = _slicedToArray(_rgb$exec$slice$map, 3),\n            _a2 = _rgb$exec$slice$map2[0],\n            _b2 = _rgb$exec$slice$map2[1],\n            _c2 = _rgb$exec$slice$map2[2];\n          Object.assign(this, {\n            _a: _a2,\n            _b: _b2,\n            _c: _c2,\n            _d: 0,\n            space: 'rgb'\n          });\n        } else if (isHex.test(a)) {\n          var hexParse = function hexParse(v) {\n            return parseInt(v, 16);\n          };\n          var _hex$exec$map = hex.exec(sixDigitHex(a)).map(hexParse),\n            _hex$exec$map2 = _slicedToArray(_hex$exec$map, 4),\n            _a3 = _hex$exec$map2[1],\n            _b3 = _hex$exec$map2[2],\n            _c3 = _hex$exec$map2[3];\n          Object.assign(this, {\n            _a: _a3,\n            _b: _b3,\n            _c: _c3,\n            _d: 0,\n            space: 'rgb'\n          });\n        } else throw Error(\"Unsupported string format, can't construct Color\");\n      }\n\n      // Now add the components as a convenience\n      var _a = this._a,\n        _b = this._b,\n        _c = this._c,\n        _d = this._d;\n      var components = this.space === 'rgb' ? {\n        r: _a,\n        g: _b,\n        b: _c\n      } : this.space === 'xyz' ? {\n        x: _a,\n        y: _b,\n        z: _c\n      } : this.space === 'hsl' ? {\n        h: _a,\n        s: _b,\n        l: _c\n      } : this.space === 'lab' ? {\n        l: _a,\n        a: _b,\n        b: _c\n      } : this.space === 'lch' ? {\n        l: _a,\n        c: _b,\n        h: _c\n      } : this.space === 'cmyk' ? {\n        c: _a,\n        m: _b,\n        y: _c,\n        k: _d\n      } : {};\n      Object.assign(this, components);\n    }\n  }, {\n    key: \"lab\",\n    value: function lab() {\n      // Get the xyz color\n      var _this$xyz = this.xyz(),\n        x = _this$xyz.x,\n        y = _this$xyz.y,\n        z = _this$xyz.z;\n\n      // Get the lab components\n      var l = 116 * y - 16;\n      var a = 500 * (x - y);\n      var b = 200 * (y - z);\n\n      // Construct and return a new color\n      var color = new Color(l, a, b, 'lab');\n      return color;\n    }\n  }, {\n    key: \"lch\",\n    value: function lch() {\n      // Get the lab color directly\n      var _this$lab = this.lab(),\n        l = _this$lab.l,\n        a = _this$lab.a,\n        b = _this$lab.b;\n\n      // Get the chromaticity and the hue using polar coordinates\n      var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n      var h = 180 * Math.atan2(b, a) / Math.PI;\n      if (h < 0) {\n        h *= -1;\n        h = 360 - h;\n      }\n\n      // Make a new color and return it\n      var color = new Color(l, c, h, 'lch');\n      return color;\n    }\n    /*\n    Conversion Methods\n    */\n  }, {\n    key: \"rgb\",\n    value: function rgb() {\n      if (this.space === 'rgb') {\n        return this;\n      } else if (cieSpace(this.space)) {\n        // Convert to the xyz color space\n        var x = this.x,\n          y = this.y,\n          z = this.z;\n        if (this.space === 'lab' || this.space === 'lch') {\n          // Get the values in the lab space\n          var l = this.l,\n            a = this.a,\n            _b4 = this.b;\n          if (this.space === 'lch') {\n            var c = this.c,\n              h = this.h;\n            var dToR = Math.PI / 180;\n            a = c * Math.cos(dToR * h);\n            _b4 = c * Math.sin(dToR * h);\n          }\n\n          // Undo the nonlinear function\n          var yL = (l + 16) / 116;\n          var xL = a / 500 + yL;\n          var zL = yL - _b4 / 200;\n\n          // Get the xyz values\n          var ct = 16 / 116;\n          var mx = 0.008856;\n          var nm = 7.787;\n          x = 0.95047 * (Math.pow(xL, 3) > mx ? Math.pow(xL, 3) : (xL - ct) / nm);\n          y = 1.0 * (Math.pow(yL, 3) > mx ? Math.pow(yL, 3) : (yL - ct) / nm);\n          z = 1.08883 * (Math.pow(zL, 3) > mx ? Math.pow(zL, 3) : (zL - ct) / nm);\n        }\n\n        // Convert xyz to unbounded rgb values\n        var rU = x * 3.2406 + y * -1.5372 + z * -0.4986;\n        var gU = x * -0.9689 + y * 1.8758 + z * 0.0415;\n        var bU = x * 0.0557 + y * -0.204 + z * 1.057;\n\n        // Convert the values to true rgb values\n        var pow = Math.pow;\n        var bd = 0.0031308;\n        var r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;\n        var g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;\n        var b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;\n\n        // Make and return the color\n        var color = new Color(255 * r, 255 * g, 255 * b);\n        return color;\n      } else if (this.space === 'hsl') {\n        // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n        // Get the current hsl values\n        var _h = this.h,\n          s = this.s,\n          _l = this.l;\n        _h /= 360;\n        s /= 100;\n        _l /= 100;\n\n        // If we are grey, then just make the color directly\n        if (s === 0) {\n          _l *= 255;\n          var _color = new Color(_l, _l, _l);\n          return _color;\n        }\n\n        // TODO I have no idea what this does :D If you figure it out, tell me!\n        var q = _l < 0.5 ? _l * (1 + s) : _l + s - _l * s;\n        var p = 2 * _l - q;\n\n        // Get the rgb values\n        var _r = 255 * hueToRgb(p, q, _h + 1 / 3);\n        var _g = 255 * hueToRgb(p, q, _h);\n        var _b5 = 255 * hueToRgb(p, q, _h - 1 / 3);\n\n        // Make a new color\n        var _color2 = new Color(_r, _g, _b5);\n        return _color2;\n      } else if (this.space === 'cmyk') {\n        // https://gist.github.com/felipesabino/5066336\n        // Get the normalised cmyk values\n        var _c4 = this.c,\n          m = this.m,\n          _y = this.y,\n          k = this.k;\n\n        // Get the rgb values\n        var _r2 = 255 * (1 - Math.min(1, _c4 * (1 - k) + k));\n        var _g2 = 255 * (1 - Math.min(1, m * (1 - k) + k));\n        var _b6 = 255 * (1 - Math.min(1, _y * (1 - k) + k));\n\n        // Form the color and return it\n        var _color3 = new Color(_r2, _g2, _b6);\n        return _color3;\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var _a = this._a,\n        _b = this._b,\n        _c = this._c,\n        _d = this._d,\n        space = this.space;\n      return [_a, _b, _c, _d, space];\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var _this$_clamped$map = this._clamped().map(componentHex),\n        _this$_clamped$map2 = _slicedToArray(_this$_clamped$map, 3),\n        r = _this$_clamped$map2[0],\n        g = _this$_clamped$map2[1],\n        b = _this$_clamped$map2[2];\n      return \"#\".concat(r).concat(g).concat(b);\n    }\n  }, {\n    key: \"toRgb\",\n    value: function toRgb() {\n      var _this$_clamped = this._clamped(),\n        _this$_clamped2 = _slicedToArray(_this$_clamped, 3),\n        rV = _this$_clamped2[0],\n        gV = _this$_clamped2[1],\n        bV = _this$_clamped2[2];\n      var string = \"rgb(\".concat(rV, \",\").concat(gV, \",\").concat(bV, \")\");\n      return string;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toHex();\n    }\n  }, {\n    key: \"xyz\",\n    value: function xyz() {\n      // Normalise the red, green and blue values\n      var _this$rgb3 = this.rgb(),\n        r255 = _this$rgb3._a,\n        g255 = _this$rgb3._b,\n        b255 = _this$rgb3._c;\n      var _map5 = [r255, g255, b255].map(function (v) {\n          return v / 255;\n        }),\n        _map6 = _slicedToArray(_map5, 3),\n        r = _map6[0],\n        g = _map6[1],\n        b = _map6[2];\n\n      // Convert to the lab rgb space\n      var rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      var gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      var bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n\n      // Convert to the xyz color space without bounding the values\n      var xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;\n      var yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0;\n      var zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;\n\n      // Get the proper xyz values by applying the bounding\n      var x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;\n      var y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;\n      var z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;\n\n      // Make and return the color\n      var color = new Color(x, y, z, 'xyz');\n      return color;\n    }\n\n    /*\n    Input and Output methods\n    */\n  }, {\n    key: \"_clamped\",\n    value: function _clamped() {\n      var _this$rgb4 = this.rgb(),\n        _a = _this$rgb4._a,\n        _b = _this$rgb4._b,\n        _c = _this$rgb4._c;\n      var max = Math.max,\n        min = Math.min,\n        round = Math.round;\n      var format = function format(v) {\n        return max(0, min(round(v), 255));\n      };\n      return [_a, _b, _c].map(format);\n    }\n\n    /*\n    Constructing colors\n    */\n  }], [{\n    key: \"isColor\",\n    value: function isColor(color) {\n      return color && (color instanceof Color || this.isRgb(color) || this.test(color));\n    }\n\n    // Test if given value is an rgb object\n  }, {\n    key: \"isRgb\",\n    value: function isRgb(color) {\n      return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n    }\n\n    /*\n    Generating random colors\n    */\n  }, {\n    key: \"random\",\n    value: function random() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vibrant';\n      var t = arguments.length > 1 ? arguments[1] : undefined;\n      // Get the math modules\n      var random = Math.random,\n        round = Math.round,\n        sin = Math.sin,\n        pi = Math.PI;\n\n      // Run the correct generator\n      if (mode === 'vibrant') {\n        var l = (81 - 57) * random() + 57;\n        var c = (83 - 45) * random() + 45;\n        var h = 360 * random();\n        var color = new Color(l, c, h, 'lch');\n        return color;\n      } else if (mode === 'sine') {\n        t = t == null ? random() : t;\n        var r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);\n        var g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);\n        var b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);\n        var _color4 = new Color(r, g, b);\n        return _color4;\n      } else if (mode === 'pastel') {\n        var _l2 = (94 - 86) * random() + 86;\n        var _c5 = (26 - 9) * random() + 9;\n        var _h2 = 360 * random();\n        var _color5 = new Color(_l2, _c5, _h2, 'lch');\n        return _color5;\n      } else if (mode === 'dark') {\n        var _l3 = 10 + 10 * random();\n        var _c6 = (125 - 75) * random() + 86;\n        var _h3 = 360 * random();\n        var _color6 = new Color(_l3, _c6, _h3, 'lch');\n        return _color6;\n      } else if (mode === 'rgb') {\n        var _r3 = 255 * random();\n        var _g3 = 255 * random();\n        var _b7 = 255 * random();\n        var _color7 = new Color(_r3, _g3, _b7);\n        return _color7;\n      } else if (mode === 'lab') {\n        var _l4 = 100 * random();\n        var a = 256 * random() - 128;\n        var _b8 = 256 * random() - 128;\n        var _color8 = new Color(_l4, a, _b8, 'lab');\n        return _color8;\n      } else if (mode === 'grey') {\n        var grey = 255 * random();\n        var _color9 = new Color(grey, grey, grey);\n        return _color9;\n      } else {\n        throw new Error('Unsupported random color mode');\n      }\n    }\n\n    // Test if given value is a color string\n  }, {\n    key: \"test\",\n    value: function test(color) {\n      return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));\n    }\n  }]);\n}();\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof$1(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););\n  return t;\n}\n\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = _superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\nvar Point = /*#__PURE__*/function () {\n  // Initialize\n  function Point() {\n    _classCallCheck$1(this, Point);\n    this.init.apply(this, arguments);\n  }\n\n  // Clone point\n  return _createClass$1(Point, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Point(this);\n    }\n  }, {\n    key: \"init\",\n    value: function init(x, y) {\n      var base = {\n        x: 0,\n        y: 0\n      };\n\n      // ensure source as object\n      var source = Array.isArray(x) ? {\n        x: x[0],\n        y: x[1]\n      } : _typeof$1(x) === 'object' ? {\n        x: x.x,\n        y: x.y\n      } : {\n        x: x,\n        y: y\n      };\n\n      // merge source\n      this.x = source.x == null ? base.x : source.x;\n      this.y = source.y == null ? base.y : source.y;\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y];\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(m) {\n      return this.clone().transformO(m);\n    }\n\n    // Transform point with matrix\n  }, {\n    key: \"transformO\",\n    value: function transformO(m) {\n      if (!Matrix.isMatrixLike(m)) {\n        m = new Matrix(m);\n      }\n      var x = this.x,\n        y = this.y;\n\n      // Perform the matrix multiplication\n      this.x = m.a * x + m.c * y + m.e;\n      this.y = m.b * x + m.d * y + m.f;\n      return this;\n    }\n  }]);\n}();\nfunction point(x, y) {\n  return new Point(x, y).transformO(this.screenCTM().inverseO());\n}\n\nfunction closeEnough(a, b, threshold) {\n  return Math.abs(b - a) < (1e-6);\n}\nvar Matrix = /*#__PURE__*/function () {\n  function Matrix() {\n    _classCallCheck$1(this, Matrix);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(Matrix, [{\n    key: \"around\",\n    value: function around(cx, cy, matrix) {\n      return this.clone().aroundO(cx, cy, matrix);\n    }\n\n    // Transform around a center point\n  }, {\n    key: \"aroundO\",\n    value: function aroundO(cx, cy, matrix) {\n      var dx = cx || 0;\n      var dy = cy || 0;\n      return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);\n    }\n\n    // Clones this matrix\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Matrix(this);\n    }\n\n    // Decomposes this matrix into its affine parameters\n  }, {\n    key: \"decompose\",\n    value: function decompose() {\n      var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // Get the parameters from the matrix\n      var a = this.a;\n      var b = this.b;\n      var c = this.c;\n      var d = this.d;\n      var e = this.e;\n      var f = this.f;\n\n      // Figure out if the winding direction is clockwise or counterclockwise\n      var determinant = a * d - b * c;\n      var ccw = determinant > 0 ? 1 : -1;\n\n      // Since we only shear in x, we can use the x basis to get the x scale\n      // and the rotation of the resulting matrix\n      var sx = ccw * Math.sqrt(a * a + b * b);\n      var thetaRad = Math.atan2(ccw * b, ccw * a);\n      var theta = 180 / Math.PI * thetaRad;\n      var ct = Math.cos(thetaRad);\n      var st = Math.sin(thetaRad);\n\n      // We can then solve the y basis vector simultaneously to get the other\n      // two affine parameters directly from these parameters\n      var lam = (a * c + b * d) / determinant;\n      var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a);\n\n      // Use the translations\n      var tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);\n      var ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);\n\n      // Construct the decomposition and return it\n      return {\n        // Return the affine parameters\n        scaleX: sx,\n        scaleY: sy,\n        shear: lam,\n        rotate: theta,\n        translateX: tx,\n        translateY: ty,\n        originX: cx,\n        originY: cy,\n        // Return the matrix parameters\n        a: this.a,\n        b: this.b,\n        c: this.c,\n        d: this.d,\n        e: this.e,\n        f: this.f\n      };\n    }\n\n    // Check if two matrices are equal\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other === this) return true;\n      var comp = new Matrix(other);\n      return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);\n    }\n\n    // Flip matrix on x or y, at a given offset\n  }, {\n    key: \"flip\",\n    value: function flip(axis, around) {\n      return this.clone().flipO(axis, around);\n    }\n  }, {\n    key: \"flipO\",\n    value: function flipO(axis, around) {\n      return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point\n    }\n\n    // Initialize\n  }, {\n    key: \"init\",\n    value: function init(source) {\n      var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);\n\n      // ensure source as object\n      source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : _typeof$1(source) === 'object' && Matrix.isMatrixLike(source) ? source : _typeof$1(source) === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base;\n\n      // Merge the source matrix with the base matrix\n      this.a = source.a != null ? source.a : base.a;\n      this.b = source.b != null ? source.b : base.b;\n      this.c = source.c != null ? source.c : base.c;\n      this.d = source.d != null ? source.d : base.d;\n      this.e = source.e != null ? source.e : base.e;\n      this.f = source.f != null ? source.f : base.f;\n      return this;\n    }\n  }, {\n    key: \"inverse\",\n    value: function inverse() {\n      return this.clone().inverseO();\n    }\n\n    // Inverses matrix\n  }, {\n    key: \"inverseO\",\n    value: function inverseO() {\n      // Get the current parameters out of the matrix\n      var a = this.a;\n      var b = this.b;\n      var c = this.c;\n      var d = this.d;\n      var e = this.e;\n      var f = this.f;\n\n      // Invert the 2x2 matrix in the top left\n      var det = a * d - b * c;\n      if (!det) throw new Error('Cannot invert ' + this);\n\n      // Calculate the top 2x2 matrix\n      var na = d / det;\n      var nb = -b / det;\n      var nc = -c / det;\n      var nd = a / det;\n\n      // Apply the inverted matrix to the top right\n      var ne = -(na * e + nc * f);\n      var nf = -(nb * e + nd * f);\n\n      // Construct the inverted matrix\n      this.a = na;\n      this.b = nb;\n      this.c = nc;\n      this.d = nd;\n      this.e = ne;\n      this.f = nf;\n      return this;\n    }\n  }, {\n    key: \"lmultiply\",\n    value: function lmultiply(matrix) {\n      return this.clone().lmultiplyO(matrix);\n    }\n  }, {\n    key: \"lmultiplyO\",\n    value: function lmultiplyO(matrix) {\n      var r = this;\n      var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n      return Matrix.matrixMultiply(l, r, this);\n    }\n\n    // Left multiplies by the given matrix\n  }, {\n    key: \"multiply\",\n    value: function multiply(matrix) {\n      return this.clone().multiplyO(matrix);\n    }\n  }, {\n    key: \"multiplyO\",\n    value: function multiplyO(matrix) {\n      // Get the matrices\n      var l = this;\n      var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n      return Matrix.matrixMultiply(l, r, this);\n    }\n\n    // Rotate matrix\n  }, {\n    key: \"rotate\",\n    value: function rotate(r, cx, cy) {\n      return this.clone().rotateO(r, cx, cy);\n    }\n  }, {\n    key: \"rotateO\",\n    value: function rotateO(r) {\n      var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // Convert degrees to radians\n      r = radians(r);\n      var cos = Math.cos(r);\n      var sin = Math.sin(r);\n      var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n      this.a = a * cos - b * sin;\n      this.b = b * cos + a * sin;\n      this.c = c * cos - d * sin;\n      this.d = d * cos + c * sin;\n      this.e = e * cos - f * sin + cy * sin - cx * cos + cx;\n      this.f = f * cos + e * sin - cx * sin - cy * cos + cy;\n      return this;\n    }\n\n    // Scale matrix\n  }, {\n    key: \"scale\",\n    value: function scale() {\n      var _this$clone;\n      return (_this$clone = this.clone()).scaleO.apply(_this$clone, arguments);\n    }\n  }, {\n    key: \"scaleO\",\n    value: function scaleO(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      // Support uniform scaling\n      if (arguments.length === 3) {\n        cy = cx;\n        cx = y;\n        y = x;\n      }\n      var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n      this.a = a * x;\n      this.b = b * y;\n      this.c = c * x;\n      this.d = d * y;\n      this.e = e * x - cx * x + cx;\n      this.f = f * y - cy * y + cy;\n      return this;\n    }\n\n    // Shear matrix\n  }, {\n    key: \"shear\",\n    value: function shear(a, cx, cy) {\n      return this.clone().shearO(a, cx, cy);\n    }\n\n    // eslint-disable-next-line no-unused-vars\n  }, {\n    key: \"shearO\",\n    value: function shearO(lx) {\n      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n      this.a = a + b * lx;\n      this.c = c + d * lx;\n      this.e = e + f * lx - cy * lx;\n      return this;\n    }\n\n    // Skew Matrix\n  }, {\n    key: \"skew\",\n    value: function skew() {\n      var _this$clone2;\n      return (_this$clone2 = this.clone()).skewO.apply(_this$clone2, arguments);\n    }\n  }, {\n    key: \"skewO\",\n    value: function skewO(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      // support uniformal skew\n      if (arguments.length === 3) {\n        cy = cx;\n        cx = y;\n        y = x;\n      }\n\n      // Convert degrees to radians\n      x = radians(x);\n      y = radians(y);\n      var lx = Math.tan(x);\n      var ly = Math.tan(y);\n      var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n      this.a = a + b * lx;\n      this.b = b + a * ly;\n      this.c = c + d * lx;\n      this.d = d + c * ly;\n      this.e = e + f * lx - cy * lx;\n      this.f = f + e * ly - cx * ly;\n      return this;\n    }\n\n    // SkewX\n  }, {\n    key: \"skewX\",\n    value: function skewX(x, cx, cy) {\n      return this.skew(x, 0, cx, cy);\n    }\n\n    // SkewY\n  }, {\n    key: \"skewY\",\n    value: function skewY(y, cx, cy) {\n      return this.skew(0, y, cx, cy);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.a, this.b, this.c, this.d, this.e, this.f];\n    }\n\n    // Convert matrix to string\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';\n    }\n\n    // Transform a matrix into another matrix by manipulating the space\n  }, {\n    key: \"transform\",\n    value: function transform(o) {\n      // Check if o is a matrix and then left multiply it directly\n      if (Matrix.isMatrixLike(o)) {\n        var matrix = new Matrix(o);\n        return matrix.multiplyO(this);\n      }\n\n      // Get the proposed transformations and the current transformations\n      var t = Matrix.formatTransforms(o);\n      var current = this;\n      var _Point$transform = new Point(t.ox, t.oy).transform(current),\n        ox = _Point$transform.x,\n        oy = _Point$transform.y;\n\n      // Construct the resulting matrix\n      var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy);\n\n      // If we want the origin at a particular place, we force it there\n      if (isFinite(t.px) || isFinite(t.py)) {\n        var origin = new Point(ox, oy).transform(transformer);\n        // TODO: Replace t.px with isFinite(t.px)\n        // Doesn't work because t.px is also 0 if it wasn't passed\n        var dx = isFinite(t.px) ? t.px - origin.x : 0;\n        var dy = isFinite(t.py) ? t.py - origin.y : 0;\n        transformer.translateO(dx, dy);\n      }\n\n      // Translate now after positioning\n      transformer.translateO(t.tx, t.ty);\n      return transformer;\n    }\n\n    // Translate matrix\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      return this.clone().translateO(x, y);\n    }\n  }, {\n    key: \"translateO\",\n    value: function translateO(x, y) {\n      this.e += x || 0;\n      this.f += y || 0;\n      return this;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return {\n        a: this.a,\n        b: this.b,\n        c: this.c,\n        d: this.d,\n        e: this.e,\n        f: this.f\n      };\n    }\n  }], [{\n    key: \"formatTransforms\",\n    value: function formatTransforms(o) {\n      // Get all of the parameters required to form the matrix\n      var flipBoth = o.flip === 'both' || o.flip === true;\n      var flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;\n      var flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;\n      var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;\n      var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;\n      var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;\n      var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;\n      var shear = o.shear || 0;\n      var theta = o.rotate || o.theta || 0;\n      var origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);\n      var ox = origin.x;\n      var oy = origin.y;\n      // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN\n      var position = new Point(o.position || o.px || o.positionX || NaN, o.py || o.positionY || NaN);\n      var px = position.x;\n      var py = position.y;\n      var translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);\n      var tx = translate.x;\n      var ty = translate.y;\n      var relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);\n      var rx = relative.x;\n      var ry = relative.y;\n\n      // Populate all of the values\n      return {\n        scaleX: scaleX,\n        scaleY: scaleY,\n        skewX: skewX,\n        skewY: skewY,\n        shear: shear,\n        theta: theta,\n        rx: rx,\n        ry: ry,\n        tx: tx,\n        ty: ty,\n        ox: ox,\n        oy: oy,\n        px: px,\n        py: py\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(a) {\n      return {\n        a: a[0],\n        b: a[1],\n        c: a[2],\n        d: a[3],\n        e: a[4],\n        f: a[5]\n      };\n    }\n  }, {\n    key: \"isMatrixLike\",\n    value: function isMatrixLike(o) {\n      return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;\n    }\n\n    // left matrix, right matrix, target matrix which is overwritten\n  }, {\n    key: \"matrixMultiply\",\n    value: function matrixMultiply(l, r, o) {\n      // Work out the product directly\n      var a = l.a * r.a + l.c * r.b;\n      var b = l.b * r.a + l.d * r.b;\n      var c = l.a * r.c + l.c * r.d;\n      var d = l.b * r.c + l.d * r.d;\n      var e = l.e + l.a * r.e + l.c * r.f;\n      var f = l.f + l.b * r.e + l.d * r.f;\n\n      // make sure to use local variables because l/r and o could be the same\n      o.a = a;\n      o.b = b;\n      o.c = c;\n      o.d = d;\n      o.e = e;\n      o.f = f;\n      return o;\n    }\n  }]);\n}();\nfunction ctm() {\n  return new Matrix(this.node.getCTM());\n}\nfunction screenCTM() {\n  try {\n    /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n       This is needed because FF does not return the transformation matrix\n       for the inner coordinate system when getScreenCTM() is called on nested svgs.\n       However all other Browsers do that */\n    if (typeof this.isRoot === 'function' && !this.isRoot()) {\n      var rect = this.rect(1, 1);\n      var m = rect.node.getScreenCTM();\n      rect.remove();\n      return new Matrix(m);\n    }\n    return new Matrix(this.node.getScreenCTM());\n  } catch (e) {\n    console.warn(\"Cannot get CTM from SVG node \".concat(this.node.nodeName, \". Is the element rendered?\"));\n    return new Matrix();\n  }\n}\nregister(Matrix, 'Matrix');\n\nfunction parser() {\n  // Reuse cached element if possible\n  if (!parser.nodes) {\n    var svg = makeInstance().size(2, 0);\n    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');\n    svg.attr('focusable', 'false');\n    svg.attr('aria-hidden', 'true');\n    var path = svg.path().node;\n    parser.nodes = {\n      svg: svg,\n      path: path\n    };\n  }\n  if (!parser.nodes.svg.node.parentNode) {\n    var b = globals.document.body || globals.document.documentElement;\n    parser.nodes.svg.addTo(b);\n  }\n  return parser.nodes;\n}\n\nfunction isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y;\n}\nfunction domContains(node) {\n  return node === globals.document || (globals.document.documentElement.contains || function (node) {\n    // This is IE - it does not support contains() for top-level SVGs\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node === globals.document;\n  }).call(globals.document.documentElement, node);\n}\nvar Box = /*#__PURE__*/function () {\n  function Box() {\n    _classCallCheck$1(this, Box);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(Box, [{\n    key: \"addOffset\",\n    value: function addOffset() {\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n      this.x += globals.window.pageXOffset;\n      this.y += globals.window.pageYOffset;\n      return new Box(this);\n    }\n  }, {\n    key: \"init\",\n    value: function init(source) {\n      var base = [0, 0, 0, 0];\n      source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : _typeof$1(source) === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;\n      this.x = source[0] || 0;\n      this.y = source[1] || 0;\n      this.width = this.w = source[2] || 0;\n      this.height = this.h = source[3] || 0;\n\n      // Add more bounding box properties\n      this.x2 = this.x + this.w;\n      this.y2 = this.y + this.h;\n      this.cx = this.x + this.w / 2;\n      this.cy = this.y + this.h / 2;\n      return this;\n    }\n  }, {\n    key: \"isNulled\",\n    value: function isNulled() {\n      return isNulledBox(this);\n    }\n\n    // Merge rect box with another, return a new instance\n  }, {\n    key: \"merge\",\n    value: function merge(box) {\n      var x = Math.min(this.x, box.x);\n      var y = Math.min(this.y, box.y);\n      var width = Math.max(this.x + this.width, box.x + box.width) - x;\n      var height = Math.max(this.y + this.height, box.y + box.height) - y;\n      return new Box(x, y, width, height);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y, this.width, this.height];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(m) {\n      if (!(m instanceof Matrix)) {\n        m = new Matrix(m);\n      }\n      var xMin = Infinity;\n      var xMax = -Infinity;\n      var yMin = Infinity;\n      var yMax = -Infinity;\n      var pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];\n      pts.forEach(function (p) {\n        p = p.transform(m);\n        xMin = Math.min(xMin, p.x);\n        xMax = Math.max(xMax, p.x);\n        yMin = Math.min(yMin, p.y);\n        yMax = Math.max(yMax, p.y);\n      });\n      return new Box(xMin, yMin, xMax - xMin, yMax - yMin);\n    }\n  }]);\n}();\nfunction getBox(el, getBBoxFn, retry) {\n  var box;\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node);\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom');\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el);\n  }\n  return box;\n}\nfunction bbox() {\n  // Function to get bbox is getBBox()\n  var getBBox = function getBBox(node) {\n    return node.getBBox();\n  };\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  var retry = function retry(el) {\n    try {\n      var clone = el.clone().addTo(parser().svg).show();\n      var _box = clone.node.getBBox();\n      clone.remove();\n      return _box;\n    } catch (e) {\n      // We give up...\n      throw new Error(\"Getting bbox of element \\\"\".concat(el.node.nodeName, \"\\\" is not possible: \").concat(e.toString()));\n    }\n  };\n  var box = getBox(this, getBBox, retry);\n  var bbox = new Box(box);\n  return bbox;\n}\nfunction rbox(el) {\n  var getRBox = function getRBox(node) {\n    return node.getBoundingClientRect();\n  };\n  var retry = function retry(el) {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(\"Getting rbox of element \\\"\".concat(el.node.nodeName, \"\\\" is not possible\"));\n  };\n  var box = getBox(this, getRBox, retry);\n  var rbox = new Box(box);\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO());\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset();\n}\n\n// Checks whether the given point is inside the bounding box\nfunction inside(x, y) {\n  var box = this.bbox();\n  return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n}\nregisterMethods({\n  viewbox: {\n    viewbox: function viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'));\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height));\n    },\n    zoom: function zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      var _this$attr = this.attr(['width', 'height']),\n        width = _this$attr.width,\n        height = _this$attr.height;\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (!width && !height || typeof width === 'string' || typeof height === 'string') {\n        width = this.node.clientWidth;\n        height = this.node.clientHeight;\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error('Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element');\n      }\n      var v = this.viewbox();\n      var zoomX = width / v.width;\n      var zoomY = height / v.height;\n      var zoom = Math.min(zoomX, zoomY);\n      if (level == null) {\n        return zoom;\n      }\n      var zoomAmount = zoom / level;\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;\n      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);\n      var box = new Box(v).transform(new Matrix({\n        scale: zoomAmount,\n        origin: point\n      }));\n      return this.viewbox(box);\n    }\n  }\n});\nregister(Box, 'Box');\n\nfunction _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\n\nfunction _isNativeReflectConstruct$C() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct$C = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\n\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct$C()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && _setPrototypeOf(p, r.prototype), p;\n}\n\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !_isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(t, arguments, _getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), _setPrototypeOf(Wrapper, t);\n  }, _wrapNativeSuper(t);\n}\n\nfunction _callSuper$B(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$B() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$B() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$B = function _isNativeReflectConstruct() { return !!t; })(); }\n// import { subClassArray } from './ArrayPolyfill.js'\nvar List = /*#__PURE__*/function (_Array) {\n  function List() {\n    var _this2;\n    var _this;\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck$1(this, List);\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    _this = _callSuper$B(this, List, [arr].concat(args));\n    if (typeof arr === 'number') return _possibleConstructorReturn(_this, _this);\n    _this.length = 0;\n    (_this2 = _this).push.apply(_this2, _toConsumableArray(arr));\n    return _this;\n  }\n  _inherits(List, _Array);\n  return _createClass$1(List);\n}( /*#__PURE__*/_wrapNativeSuper(Array));\nextend([List], {\n  each: function each(fnOrMethodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (typeof fnOrMethodName === 'function') {\n      return this.map(function (el, i, arr) {\n        return fnOrMethodName.call(el, el, i, arr);\n      });\n    } else {\n      return this.map(function (el) {\n        return el[fnOrMethodName].apply(el, args);\n      });\n    }\n  },\n  toArray: function toArray() {\n    return Array.prototype.concat.apply([], this);\n  }\n});\nvar reserved = ['toArray', 'constructor', 'each'];\nList.extend = function (methods) {\n  methods = methods.reduce(function (obj, name) {\n    // Don't overwrite own methods\n    if (reserved.includes(name)) return obj;\n\n    // Don't add private methods\n    if (name[0] === '_') return obj;\n\n    // Allow access to original Array methods through a prefix\n    if (name in Array.prototype) {\n      obj['$' + name] = Array.prototype[name];\n    }\n\n    // Relay every call to each()\n    obj[name] = function () {\n      for (var _len3 = arguments.length, attrs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        attrs[_key3] = arguments[_key3];\n      }\n      return this.each.apply(this, [name].concat(attrs));\n    };\n    return obj;\n  }, {});\n  extend([List], methods);\n};\n\nfunction baseFind(query, parent) {\n  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {\n    return adopt(node);\n  }));\n}\n\n// Scoped find method\nfunction find(query) {\n  return baseFind(query, this.node);\n}\nfunction findOne(query) {\n  return adopt(this.node.querySelector(query));\n}\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar listenerId = 0;\nvar windowEvents = {};\nfunction getEvents(instance) {\n  var n = instance.getEventHolder();\n\n  // We dont want to save events in global space\n  if (n === globals.window) n = windowEvents;\n  if (!n.events) n.events = {};\n  return n.events;\n}\nfunction getEventTarget(instance) {\n  return instance.getEventTarget();\n}\nfunction clearEvents(instance) {\n  var n = instance.getEventHolder();\n  if (n === globals.window) n = windowEvents;\n  if (n.events) n.events = {};\n}\n\n// Add event binder in the SVG namespace\nfunction on(node, events, listener, binding, options) {\n  var l = listener.bind(binding || node);\n  var instance = makeInstance(node);\n  var bag = getEvents(instance);\n  var n = getEventTarget(instance);\n\n  // events can be an array of events or a string of events\n  events = Array.isArray(events) ? events : events.split(delimiter);\n\n  // add id to listener\n  if (!listener._svgjsListenerId) {\n    listener._svgjsListenerId = ++listenerId;\n  }\n  events.forEach(function (event) {\n    var ev = event.split('.')[0];\n    var ns = event.split('.')[1] || '*';\n\n    // ensure valid object\n    bag[ev] = bag[ev] || {};\n    bag[ev][ns] = bag[ev][ns] || {};\n\n    // reference listener\n    bag[ev][ns][listener._svgjsListenerId] = l;\n\n    // add listener\n    n.addEventListener(ev, l, options || false);\n  });\n}\n\n// Add event unbinder in the SVG namespace\nfunction off(node, events, listener, options) {\n  var instance = makeInstance(node);\n  var bag = getEvents(instance);\n  var n = getEventTarget(instance);\n\n  // listener can be a function or a number\n  if (typeof listener === 'function') {\n    listener = listener._svgjsListenerId;\n    if (!listener) return;\n  }\n\n  // events can be an array of events or a string or undefined\n  events = Array.isArray(events) ? events : (events || '').split(delimiter);\n  events.forEach(function (event) {\n    var ev = event && event.split('.')[0];\n    var ns = event && event.split('.')[1];\n    var namespace, l;\n    if (listener) {\n      // remove listener reference\n      if (bag[ev] && bag[ev][ns || '*']) {\n        // removeListener\n        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);\n        delete bag[ev][ns || '*'][listener];\n      }\n    } else if (ev && ns) {\n      // remove all listeners for a namespaced event\n      if (bag[ev] && bag[ev][ns]) {\n        for (l in bag[ev][ns]) {\n          off(n, [ev, ns].join('.'), l);\n        }\n        delete bag[ev][ns];\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in bag) {\n        for (namespace in bag[event]) {\n          if (ns === namespace) {\n            off(n, [event, ns].join('.'));\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (bag[ev]) {\n        for (namespace in bag[ev]) {\n          off(n, [ev, namespace].join('.'));\n        }\n        delete bag[ev];\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in bag) {\n        off(n, event);\n      }\n      clearEvents(instance);\n    }\n  });\n}\nfunction dispatch(node, event, data, options) {\n  var n = getEventTarget(node);\n\n  // Dispatch event\n  if (event instanceof globals.window.Event) {\n    n.dispatchEvent(event);\n  } else {\n    event = new globals.window.CustomEvent(event, _objectSpread$3({\n      detail: data,\n      cancelable: true\n    }, options));\n    n.dispatchEvent(event);\n  }\n  return event;\n}\n\nfunction _callSuper$A(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$A() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$A() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$A = function _isNativeReflectConstruct() { return !!t; })(); }\nvar EventTarget = /*#__PURE__*/function (_Base) {\n  function EventTarget() {\n    _classCallCheck$1(this, EventTarget);\n    return _callSuper$A(this, EventTarget, arguments);\n  }\n  _inherits(EventTarget, _Base);\n  return _createClass$1(EventTarget, [{\n    key: \"addEventListener\",\n    value: function addEventListener() {}\n  }, {\n    key: \"dispatch\",\n    value: function dispatch$1(event, data, options) {\n      return dispatch(this, event, data, options);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      var bag = this.getEventHolder().events;\n      if (!bag) return true;\n      var events = bag[event.type];\n      for (var i in events) {\n        for (var j in events[i]) {\n          events[i][j](event);\n        }\n      }\n      return !event.defaultPrevented;\n    }\n\n    // Fire given event\n  }, {\n    key: \"fire\",\n    value: function fire(event, data, options) {\n      this.dispatch(event, data, options);\n      return this;\n    }\n  }, {\n    key: \"getEventHolder\",\n    value: function getEventHolder() {\n      return this;\n    }\n  }, {\n    key: \"getEventTarget\",\n    value: function getEventTarget() {\n      return this;\n    }\n\n    // Unbind event from listener\n  }, {\n    key: \"off\",\n    value: function off$1(event, listener, options) {\n      off(this, event, listener, options);\n      return this;\n    }\n\n    // Bind given event to listener\n  }, {\n    key: \"on\",\n    value: function on$1(event, listener, binding, options) {\n      on(this, event, listener, binding, options);\n      return this;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener() {}\n  }]);\n}(Base);\nregister(EventTarget, 'EventTarget');\n\nfunction noop() {}\n\n// Default animation values\nvar timeline = {\n  duration: 400,\n  ease: '>',\n  delay: 0\n};\n\n// Default attribute values\nvar attrs = {\n  // fill and stroke\n  'fill-opacity': 1,\n  'stroke-opacity': 1,\n  'stroke-width': 0,\n  'stroke-linejoin': 'miter',\n  'stroke-linecap': 'butt',\n  fill: '#000000',\n  stroke: '#000000',\n  opacity: 1,\n  // position\n  x: 0,\n  y: 0,\n  cx: 0,\n  cy: 0,\n  // size\n  width: 0,\n  height: 0,\n  // radius\n  r: 0,\n  rx: 0,\n  ry: 0,\n  // gradient\n  offset: 0,\n  'stop-opacity': 1,\n  'stop-color': '#000000',\n  // text\n  'text-anchor': 'start'\n};\n\nfunction _callSuper$z(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$z() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$z() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$z = function _isNativeReflectConstruct() { return !!t; })(); }\nvar SVGArray = /*#__PURE__*/function (_Array) {\n  function SVGArray() {\n    var _this2;\n    var _this;\n    _classCallCheck$1(this, SVGArray);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper$z(this, SVGArray, [].concat(args));\n    (_this2 = _this).init.apply(_this2, args);\n    return _this;\n  }\n  _inherits(SVGArray, _Array);\n  return _createClass$1(SVGArray, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this);\n    }\n  }, {\n    key: \"init\",\n    value: function init(arr) {\n      // This catches the case, that native map tries to create an array with new Array(1)\n      if (typeof arr === 'number') return this;\n      this.length = 0;\n      this.push.apply(this, _toConsumableArray(this.parse(arr)));\n      return this;\n    }\n\n    // Parse whitespace separated string\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      // If already is an array, no need to parse it\n      if (array instanceof Array) return array;\n      return array.trim().split(delimiter).map(parseFloat);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return Array.prototype.concat.apply([], this);\n    }\n  }, {\n    key: \"toSet\",\n    value: function toSet() {\n      return new Set(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.join(' ');\n    }\n\n    // Flattens the array if needed\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var ret = [];\n      ret.push.apply(ret, _toConsumableArray(this));\n      return ret;\n    }\n  }]);\n}( /*#__PURE__*/_wrapNativeSuper(Array));\n\n// Module for unit conversions\nvar SVGNumber = /*#__PURE__*/function () {\n  // Initialize\n  function SVGNumber() {\n    _classCallCheck$1(this, SVGNumber);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(SVGNumber, [{\n    key: \"convert\",\n    value: function convert(unit) {\n      return new SVGNumber(this.value, unit);\n    }\n\n    // Divide number\n  }, {\n    key: \"divide\",\n    value: function divide(number) {\n      number = new SVGNumber(number);\n      return new SVGNumber(this / number, this.unit || number.unit);\n    }\n  }, {\n    key: \"init\",\n    value: function init(value, unit) {\n      unit = Array.isArray(value) ? value[1] : unit;\n      value = Array.isArray(value) ? value[0] : value;\n\n      // initialize defaults\n      this.value = 0;\n      this.unit = unit || '';\n\n      // parse value\n      if (typeof value === 'number') {\n        // ensure a valid numeric value\n        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e38 : +3.4e38 : value;\n      } else if (typeof value === 'string') {\n        unit = value.match(numberAndUnit);\n        if (unit) {\n          // make value numeric\n          this.value = parseFloat(unit[1]);\n\n          // normalize\n          if (unit[5] === '%') {\n            this.value /= 100;\n          } else if (unit[5] === 's') {\n            this.value *= 1000;\n          }\n\n          // store unit\n          this.unit = unit[5];\n        }\n      } else {\n        if (value instanceof SVGNumber) {\n          this.value = value.valueOf();\n          this.unit = value.unit;\n        }\n      }\n      return this;\n    }\n\n    // Subtract number\n  }, {\n    key: \"minus\",\n    value: function minus(number) {\n      number = new SVGNumber(number);\n      return new SVGNumber(this - number, this.unit || number.unit);\n    }\n\n    // Add number\n  }, {\n    key: \"plus\",\n    value: function plus(number) {\n      number = new SVGNumber(number);\n      return new SVGNumber(this + number, this.unit || number.unit);\n    }\n\n    // Multiply number\n  }, {\n    key: \"times\",\n    value: function times(number) {\n      number = new SVGNumber(number);\n      return new SVGNumber(this * number, this.unit || number.unit);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.value, this.unit];\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value;\n    }\n  }]);\n}();\n\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar colorAttributes = new Set(['fill', 'stroke', 'color', 'bgcolor', 'stop-color', 'flood-color', 'lighting-color']);\nvar hooks = [];\nfunction registerAttrHook(fn) {\n  hooks.push(fn);\n}\n\n// Set svg element attribute\nfunction attr(attr, val, ns) {\n  var _this = this;\n  // act as full getter\n  if (attr == null) {\n    // get an object of attributes\n    attr = {};\n    val = this.node.attributes;\n    var _iterator = _createForOfIteratorHelper(val),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return attr;\n  } else if (attr instanceof Array) {\n    // loop through array and get all values\n    return attr.reduce(function (last, curr) {\n      last[curr] = _this.attr(curr);\n      return last;\n    }, {});\n  } else if (_typeof$1(attr) === 'object' && attr.constructor === Object) {\n    // apply every attribute individually if an object is passed\n    for (val in attr) this.attr(val, attr[val]);\n  } else if (val === null) {\n    // remove value\n    this.node.removeAttribute(attr);\n  } else if (val == null) {\n    // act as a getter if the first and only argument is not an object\n    val = this.node.getAttribute(attr);\n    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;\n  } else {\n    // Loop through hooks and execute them to convert value\n    val = hooks.reduce(function (_val, hook) {\n      return hook(attr, _val, _this);\n    }, val);\n\n    // ensure correct numeric values (also accepts NaN and Infinity)\n    if (typeof val === 'number') {\n      val = new SVGNumber(val);\n    } else if (colorAttributes.has(attr) && Color.isColor(val)) {\n      // ensure full hex color\n      val = new Color(val);\n    } else if (val.constructor === Array) {\n      // Check for plain arrays and parse array values\n      val = new SVGArray(val);\n    }\n\n    // if the passed attribute is leading...\n    if (attr === 'leading') {\n      // ... call the leading method instead\n      if (this.leading) {\n        this.leading(val);\n      }\n    } else {\n      // set given attribute on node\n      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());\n    }\n\n    // rebuild if required\n    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n      this.rebuild();\n    }\n  }\n  return this;\n}\n\nfunction _callSuper$y(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$y() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$y() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$y = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Dom = /*#__PURE__*/function (_EventTarget) {\n  function Dom(node, attrs) {\n    var _this2;\n    _classCallCheck$1(this, Dom);\n    _this2 = _callSuper$y(this, Dom);\n    _this2.node = node;\n    _this2.type = node.nodeName;\n    if (attrs && node !== attrs) {\n      _this2.attr(attrs);\n    }\n    return _this2;\n  }\n\n  // Add given element at a position\n  _inherits(Dom, _EventTarget);\n  return _createClass$1(Dom, [{\n    key: \"add\",\n    value: function add(element, i) {\n      element = makeInstance(element);\n\n      // If non-root svg nodes are added we have to remove their namespaces\n      if (element.removeNamespace && this.node instanceof globals.window.SVGElement) {\n        element.removeNamespace();\n      }\n      if (i == null) {\n        this.node.appendChild(element.node);\n      } else if (element.node !== this.node.childNodes[i]) {\n        this.node.insertBefore(element.node, this.node.childNodes[i]);\n      }\n      return this;\n    }\n\n    // Add element to given container and return self\n  }, {\n    key: \"addTo\",\n    value: function addTo(parent, i) {\n      return makeInstance(parent).put(this, i);\n    }\n\n    // Returns all child elements\n  }, {\n    key: \"children\",\n    value: function children() {\n      return new List(map(this.node.children, function (node) {\n        return adopt(node);\n      }));\n    }\n\n    // Remove all elements in this container\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // remove children\n      while (this.node.hasChildNodes()) {\n        this.node.removeChild(this.node.lastChild);\n      }\n      return this;\n    }\n\n    // Clone element\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var assignNewIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // write dom data to the dom so the clone can pickup the data\n      this.writeDataToDom();\n\n      // clone element\n      var nodeClone = this.node.cloneNode(deep);\n      if (assignNewIds) {\n        // assign new id\n        nodeClone = assignNewId(nodeClone);\n      }\n      return new this.constructor(nodeClone);\n    }\n\n    // Iterates over all children and invokes a given block\n  }, {\n    key: \"each\",\n    value: function each(block, deep) {\n      var children = this.children();\n      var i, il;\n      for (i = 0, il = children.length; i < il; i++) {\n        block.apply(children[i], [i, children]);\n        if (deep) {\n          children[i].each(block, deep);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"element\",\n    value: function element(nodeName, attrs) {\n      return this.put(new Dom(create(nodeName), attrs));\n    }\n\n    // Get first child\n  }, {\n    key: \"first\",\n    value: function first() {\n      return adopt(this.node.firstChild);\n    }\n\n    // Get a element at the given index\n  }, {\n    key: \"get\",\n    value: function get(i) {\n      return adopt(this.node.childNodes[i]);\n    }\n  }, {\n    key: \"getEventHolder\",\n    value: function getEventHolder() {\n      return this.node;\n    }\n  }, {\n    key: \"getEventTarget\",\n    value: function getEventTarget() {\n      return this.node;\n    }\n\n    // Checks if the given element is a child\n  }, {\n    key: \"has\",\n    value: function has(element) {\n      return this.index(element) >= 0;\n    }\n  }, {\n    key: \"html\",\n    value: function html$1(htmlOrFn, outerHTML) {\n      return this.xml(htmlOrFn, outerHTML, html);\n    }\n\n    // Get / set id\n  }, {\n    key: \"id\",\n    value: function id(_id) {\n      // generate new id if no id set\n      if (typeof _id === 'undefined' && !this.node.id) {\n        this.node.id = eid(this.type);\n      }\n\n      // don't set directly with this.node.id to make `null` work correctly\n      return this.attr('id', _id);\n    }\n\n    // Gets index of given element\n  }, {\n    key: \"index\",\n    value: function index(element) {\n      return [].slice.call(this.node.childNodes).indexOf(element.node);\n    }\n\n    // Get the last child\n  }, {\n    key: \"last\",\n    value: function last() {\n      return adopt(this.node.lastChild);\n    }\n\n    // matches the element vs a css selector\n  }, {\n    key: \"matches\",\n    value: function matches(selector) {\n      var el = this.node;\n      var matcher = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector || null;\n      return matcher && matcher.call(el, selector);\n    }\n\n    // Returns the parent element instance\n  }, {\n    key: \"parent\",\n    value: function parent(type) {\n      var parent = this;\n\n      // check for parent\n      if (!parent.node.parentNode) return null;\n\n      // get parent element\n      parent = adopt(parent.node.parentNode);\n      if (!type) return parent;\n\n      // loop through ancestors if type is given\n      do {\n        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n      } while (parent = adopt(parent.node.parentNode));\n      return parent;\n    }\n\n    // Basically does the same as `add()` but returns the added element instead\n  }, {\n    key: \"put\",\n    value: function put(element, i) {\n      element = makeInstance(element);\n      this.add(element, i);\n      return element;\n    }\n\n    // Add element to given container and return container\n  }, {\n    key: \"putIn\",\n    value: function putIn(parent, i) {\n      return makeInstance(parent).add(this, i);\n    }\n\n    // Remove element\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this.parent()) {\n        this.parent().removeElement(this);\n      }\n      return this;\n    }\n\n    // Remove a given child\n  }, {\n    key: \"removeElement\",\n    value: function removeElement(element) {\n      this.node.removeChild(element.node);\n      return this;\n    }\n\n    // Replace this with element\n  }, {\n    key: \"replace\",\n    value: function replace(element) {\n      element = makeInstance(element);\n      if (this.node.parentNode) {\n        this.node.parentNode.replaceChild(element.node, this.node);\n      }\n      return element;\n    }\n  }, {\n    key: \"round\",\n    value: function round() {\n      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var factor = Math.pow(10, precision);\n      var attrs = this.attr(map);\n      for (var i in attrs) {\n        if (typeof attrs[i] === 'number') {\n          attrs[i] = Math.round(attrs[i] * factor) / factor;\n        }\n      }\n      this.attr(attrs);\n      return this;\n    }\n\n    // Import / Export raw svg\n  }, {\n    key: \"svg\",\n    value: function svg$1(svgOrFn, outerSVG) {\n      return this.xml(svgOrFn, outerSVG, svg);\n    }\n\n    // Return id on string conversion\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.id();\n    }\n  }, {\n    key: \"words\",\n    value: function words(text) {\n      // This is faster than removing all children and adding a new one\n      this.node.textContent = text;\n      return this;\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(node) {\n      var parent = this.parent();\n      if (!parent) {\n        return this.addTo(node);\n      }\n      var position = parent.index(this);\n      return parent.put(node, position).put(this);\n    }\n\n    // write svgjs data to the dom\n  }, {\n    key: \"writeDataToDom\",\n    value: function writeDataToDom() {\n      // dump variables recursively\n      this.each(function () {\n        this.writeDataToDom();\n      });\n      return this;\n    }\n\n    // Import / Export raw svg\n  }, {\n    key: \"xml\",\n    value: function xml(xmlOrFn, outerXML, ns) {\n      if (typeof xmlOrFn === 'boolean') {\n        ns = outerXML;\n        outerXML = xmlOrFn;\n        xmlOrFn = null;\n      }\n\n      // act as getter if no svg string is given\n      if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n        // The default for exports is, that the outerNode is included\n        outerXML = outerXML == null ? true : outerXML;\n\n        // write svgjs data to the dom\n        this.writeDataToDom();\n        var current = this;\n\n        // An export modifier was passed\n        if (xmlOrFn != null) {\n          current = adopt(current.node.cloneNode(true));\n\n          // If the user wants outerHTML we need to process this node, too\n          if (outerXML) {\n            var result = xmlOrFn(current);\n            current = result || current;\n\n            // The user does not want this node? Well, then he gets nothing\n            if (result === false) return '';\n          }\n\n          // Deep loop through all children and apply modifier\n          current.each(function () {\n            var result = xmlOrFn(this);\n            var _this = result || this;\n\n            // If modifier returns false, discard node\n            if (result === false) {\n              this.remove();\n\n              // If modifier returns new node, use it\n            } else if (result && this !== _this) {\n              this.replace(_this);\n            }\n          }, true);\n        }\n\n        // Return outer or inner content\n        return outerXML ? current.node.outerHTML : current.node.innerHTML;\n      }\n\n      // Act as setter if we got a string\n\n      // The default for import is, that the current node is not replaced\n      outerXML = outerXML == null ? false : outerXML;\n\n      // Create temporary holder\n      var well = create('wrapper', ns);\n      var fragment = globals.document.createDocumentFragment();\n\n      // Dump raw svg\n      well.innerHTML = xmlOrFn;\n\n      // Transplant nodes into the fragment\n      for (var len = well.children.length; len--;) {\n        fragment.appendChild(well.firstElementChild);\n      }\n      var parent = this.parent();\n\n      // Add the whole fragment at once\n      return outerXML ? this.replace(fragment) && parent : this.add(fragment);\n    }\n  }]);\n}(EventTarget);\nextend(Dom, {\n  attr: attr,\n  find: find,\n  findOne: findOne\n});\nregister(Dom, 'Dom');\n\nfunction _callSuper$x(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$x() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$x() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$x = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Element = /*#__PURE__*/function (_Dom) {\n  function Element(node, attrs) {\n    var _this;\n    _classCallCheck$1(this, Element);\n    _this = _callSuper$x(this, Element, [node, attrs]);\n\n    // initialize data object\n    _this.dom = {};\n\n    // create circular reference\n    _this.node.instance = _this;\n    if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {\n      var _ref, _JSON$parse;\n      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n      _this.setData((_ref = (_JSON$parse = JSON.parse(node.getAttribute('data-svgjs'))) !== null && _JSON$parse !== void 0 ? _JSON$parse : JSON.parse(node.getAttribute('svgjs:data'))) !== null && _ref !== void 0 ? _ref : {});\n    }\n    return _this;\n  }\n\n  // Move element by its center\n  _inherits(Element, _Dom);\n  return _createClass$1(Element, [{\n    key: \"center\",\n    value: function center(x, y) {\n      return this.cx(x).cy(y);\n    }\n\n    // Move by center over x-axis\n  }, {\n    key: \"cx\",\n    value: function cx(x) {\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n    }\n\n    // Move by center over y-axis\n  }, {\n    key: \"cy\",\n    value: function cy(y) {\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n    }\n\n    // Get defs\n  }, {\n    key: \"defs\",\n    value: function defs() {\n      var root = this.root();\n      return root && root.defs();\n    }\n\n    // Relative move over x and y axes\n  }, {\n    key: \"dmove\",\n    value: function dmove(x, y) {\n      return this.dx(x).dy(y);\n    }\n\n    // Relative move over x axis\n  }, {\n    key: \"dx\",\n    value: function dx() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.x(new SVGNumber(x).plus(this.x()));\n    }\n\n    // Relative move over y axis\n  }, {\n    key: \"dy\",\n    value: function dy() {\n      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.y(new SVGNumber(y).plus(this.y()));\n    }\n  }, {\n    key: \"getEventHolder\",\n    value: function getEventHolder() {\n      return this;\n    }\n\n    // Set height of element\n  }, {\n    key: \"height\",\n    value: function height(_height) {\n      return this.attr('height', _height);\n    }\n\n    // Move element to given x and y values\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      return this.x(x).y(y);\n    }\n\n    // return array of all ancestors of given type up to the root svg\n  }, {\n    key: \"parents\",\n    value: function parents() {\n      var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root();\n      var isSelector = typeof until === 'string';\n      if (!isSelector) {\n        until = makeInstance(until);\n      }\n      var parents = new List();\n      var parent = this;\n      while ((parent = parent.parent()) && parent.node !== globals.document && parent.nodeName !== '#document-fragment') {\n        parents.push(parent);\n        if (!isSelector && parent.node === until.node) {\n          break;\n        }\n        if (isSelector && parent.matches(until)) {\n          break;\n        }\n        if (parent.node === this.root().node) {\n          // We worked our way to the root and didn't match `until`\n          return null;\n        }\n      }\n      return parents;\n    }\n\n    // Get referenced element form attribute value\n  }, {\n    key: \"reference\",\n    value: function reference$1(attr) {\n      attr = this.attr(attr);\n      if (!attr) return null;\n      var m = (attr + '').match(reference);\n      return m ? makeInstance(m[1]) : null;\n    }\n\n    // Get parent document\n  }, {\n    key: \"root\",\n    value: function root$1() {\n      var p = this.parent(getClass(root));\n      return p && p.root();\n    }\n\n    // set given data to the elements data property\n  }, {\n    key: \"setData\",\n    value: function setData(o) {\n      this.dom = o;\n      return this;\n    }\n\n    // Set element size to given width and height\n  }, {\n    key: \"size\",\n    value: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));\n    }\n\n    // Set width of element\n  }, {\n    key: \"width\",\n    value: function width(_width) {\n      return this.attr('width', _width);\n    }\n\n    // write svgjs data to the dom\n  }, {\n    key: \"writeDataToDom\",\n    value: function writeDataToDom$1() {\n      writeDataToDom(this, this.dom);\n      return _get(_getPrototypeOf(Element.prototype), \"writeDataToDom\", this).call(this);\n    }\n\n    // Move over x-axis\n  }, {\n    key: \"x\",\n    value: function x(_x) {\n      return this.attr('x', _x);\n    }\n\n    // Move over y-axis\n  }, {\n    key: \"y\",\n    value: function y(_y) {\n      return this.attr('y', _y);\n    }\n  }]);\n}(Dom);\nextend(Element, {\n  bbox: bbox,\n  rbox: rbox,\n  inside: inside,\n  point: point,\n  ctm: ctm,\n  screenCTM: screenCTM\n});\nregister(Element, 'Element');\n\n// Define list of available attributes for stroke and fill\nvar sugar = {\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n  fill: ['color', 'opacity', 'rule'],\n  prefix: function prefix(t, a) {\n    return a === 'color' ? t : t + '-' + a;\n  }\n}\n\n// Add sugar for fill and stroke\n;\n['fill', 'stroke'].forEach(function (m) {\n  var extension = {};\n  var i;\n  extension[m] = function (o) {\n    if (typeof o === 'undefined') {\n      return this.attr(m);\n    }\n    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {\n      this.attr(m, o);\n    } else {\n      // set all attributes from sugar.fill and sugar.stroke list\n      for (i = sugar[m].length - 1; i >= 0; i--) {\n        if (o[sugar[m][i]] != null) {\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n        }\n      }\n    }\n    return this;\n  };\n  registerMethods(['Element', 'Runner'], extension);\n});\nregisterMethods(['Element', 'Runner'], {\n  // Let the user set the matrix directly\n  matrix: function matrix(mat, b, c, d, e, f) {\n    // Act as a getter\n    if (mat == null) {\n      return new Matrix(this);\n    }\n\n    // Act as a setter, the user can pass a matrix or a set of numbers\n    return this.attr('transform', new Matrix(mat, b, c, d, e, f));\n  },\n  // Map rotation to transform\n  rotate: function rotate(angle, cx, cy) {\n    return this.transform({\n      rotate: angle,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map skew to transform\n  skew: function skew(x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      skew: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      skew: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  shear: function shear(lam, cx, cy) {\n    return this.transform({\n      shear: lam,\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map scale to transform\n  scale: function scale(x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n      scale: x,\n      ox: y,\n      oy: cx\n    }, true) : this.transform({\n      scale: [x, y],\n      ox: cx,\n      oy: cy\n    }, true);\n  },\n  // Map translate to transform\n  translate: function translate(x, y) {\n    return this.transform({\n      translate: [x, y]\n    }, true);\n  },\n  // Map relative translations to transform\n  relative: function relative(x, y) {\n    return this.transform({\n      relative: [x, y]\n    }, true);\n  },\n  // Map flip to transform\n  flip: function flip() {\n    var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'both';\n    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'center';\n    if ('xybothtrue'.indexOf(direction) === -1) {\n      origin = direction;\n      direction = 'both';\n    }\n    return this.transform({\n      flip: direction,\n      origin: origin\n    }, true);\n  },\n  // Opacity\n  opacity: function opacity(value) {\n    return this.attr('opacity', value);\n  }\n});\nregisterMethods('radius', {\n  // Add x and y radius\n  radius: function radius(x) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n    var type = (this._element || this).type;\n    return type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y);\n  }\n});\nregisterMethods('Path', {\n  // Get path length\n  length: function length() {\n    return this.node.getTotalLength();\n  },\n  // Get point at length\n  pointAt: function pointAt(length) {\n    return new Point(this.node.getPointAtLength(length));\n  }\n});\nregisterMethods(['Element', 'Runner'], {\n  // Set font\n  font: function font(a, v) {\n    if (_typeof$1(a) === 'object') {\n      for (v in a) this.font(v, a[v]);\n      return this;\n    }\n    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n  }\n});\n\n// Add events to elements\nvar methods = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel', 'contextmenu', 'wheel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel'].reduce(function (last, event) {\n  // add event to Element\n  var fn = function fn(f) {\n    if (f === null) {\n      this.off(event);\n    } else {\n      this.on(event, f);\n    }\n    return this;\n  };\n  last[event] = fn;\n  return last;\n}, {});\nregisterMethods('Element', methods);\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n\n// Reset all transformations\nfunction untransform() {\n  return this.attr('transform', null);\n}\n\n// merge the whole transformation chain into one matrix and returns it\nfunction matrixify() {\n  var matrix = (this.attr('transform') || ''\n  // split transformations\n  ).split(transforms).slice(0, -1).map(function (str) {\n    // generate key => value pairs\n    var kv = str.trim().split('(');\n    return [kv[0], kv[1].split(delimiter).map(function (str) {\n      return parseFloat(str);\n    })];\n  }).reverse()\n  // merge every transformation into one matrix\n  .reduce(function (matrix, transform) {\n    if (transform[0] === 'matrix') {\n      return matrix.lmultiply(Matrix.fromArray(transform[1]));\n    }\n    return matrix[transform[0]].apply(matrix, transform[1]);\n  }, new Matrix());\n  return matrix;\n}\n\n// add an element to another parent without changing the visual representation on the screen\nfunction toParent(parent, i) {\n  if (this === parent) return this;\n  if (isDescriptive(this.node)) return this.addTo(parent, i);\n  var ctm = this.screenCTM();\n  var pCtm = parent.screenCTM().inverse();\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));\n  return this;\n}\n\n// same as above with parent equals root-svg\nfunction toRoot(i) {\n  return this.toParent(this.root(), i);\n}\n\n// Add transformations\nfunction transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    var decomposed = new Matrix(this).decompose();\n    return o == null ? decomposed : decomposed[o];\n  }\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = _objectSpread$2(_objectSpread$2({}, o), {}, {\n      origin: getOrigin(o, this)\n    });\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  var cleanRelative = relative === true ? this : relative || false;\n  var result = new Matrix(cleanRelative).transform(o);\n  return this.attr('transform', result);\n}\nregisterMethods('Element', {\n  untransform: untransform,\n  matrixify: matrixify,\n  toParent: toParent,\n  toRoot: toRoot,\n  transform: transform\n});\n\nfunction _callSuper$w(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$w() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$w() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$w = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Container = /*#__PURE__*/function (_Element) {\n  function Container() {\n    _classCallCheck$1(this, Container);\n    return _callSuper$w(this, Container, arguments);\n  }\n  _inherits(Container, _Element);\n  return _createClass$1(Container, [{\n    key: \"flatten\",\n    value: function flatten() {\n      this.each(function () {\n        if (this instanceof Container) {\n          return this.flatten().ungroup();\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"ungroup\",\n    value: function ungroup() {\n      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.parent();\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parent.index(this);\n      // when parent != this, we want append all elements to the end\n      index = index === -1 ? parent.children().length : index;\n      this.each(function (i, children) {\n        // reverse each\n        return children[children.length - i - 1].toParent(parent, index);\n      });\n      return this.remove();\n    }\n  }]);\n}(Element);\nregister(Container, 'Container');\n\nfunction _callSuper$v(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$v() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$v() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$v = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Defs = /*#__PURE__*/function (_Container) {\n  function Defs(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Defs);\n    return _callSuper$v(this, Defs, [nodeOrNew('defs', node), attrs]);\n  }\n  _inherits(Defs, _Container);\n  return _createClass$1(Defs, [{\n    key: \"flatten\",\n    value: function flatten() {\n      return this;\n    }\n  }, {\n    key: \"ungroup\",\n    value: function ungroup() {\n      return this;\n    }\n  }]);\n}(Container);\nregister(Defs, 'Defs');\n\nfunction _callSuper$u(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$u() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$u() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$u = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Shape = /*#__PURE__*/function (_Element) {\n  function Shape() {\n    _classCallCheck$1(this, Shape);\n    return _callSuper$u(this, Shape, arguments);\n  }\n  _inherits(Shape, _Element);\n  return _createClass$1(Shape);\n}(Element);\nregister(Shape, 'Shape');\n\n// Radius x value\nfunction rx(rx) {\n  return this.attr('rx', rx);\n}\n\n// Radius y value\nfunction ry(ry) {\n  return this.attr('ry', ry);\n}\n\n// Move over x-axis\nfunction x$3(x) {\n  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());\n}\n\n// Move over y-axis\nfunction y$3(y) {\n  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());\n}\n\n// Move by center over x-axis\nfunction cx$1(x) {\n  return this.attr('cx', x);\n}\n\n// Move by center over y-axis\nfunction cy$1(y) {\n  return this.attr('cy', y);\n}\n\n// Set width of element\nfunction width$2(width) {\n  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));\n}\n\n// Set height of element\nfunction height$2(height) {\n  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));\n}\n\nvar circled = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  cx: cx$1,\n  cy: cy$1,\n  height: height$2,\n  rx: rx,\n  ry: ry,\n  width: width$2,\n  x: x$3,\n  y: y$3\n});\n\nfunction _callSuper$t(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$t() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$t() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$t = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Ellipse = /*#__PURE__*/function (_Shape) {\n  function Ellipse(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Ellipse);\n    return _callSuper$t(this, Ellipse, [nodeOrNew('ellipse', node), attrs]);\n  }\n  _inherits(Ellipse, _Shape);\n  return _createClass$1(Ellipse, [{\n    key: \"size\",\n    value: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));\n    }\n  }]);\n}(Shape);\nextend(Ellipse, circled);\nregisterMethods('Container', {\n  // Create an ellipse\n  ellipse: wrapWithAttrCheck(function () {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n    return this.put(new Ellipse()).size(width, height).move(0, 0);\n  })\n});\nregister(Ellipse, 'Ellipse');\n\nfunction _callSuper$s(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$s() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$s() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$s = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Fragment = /*#__PURE__*/function (_Dom) {\n  function Fragment() {\n    var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globals.document.createDocumentFragment();\n    _classCallCheck$1(this, Fragment);\n    return _callSuper$s(this, Fragment, [node]);\n  }\n\n  // Import / Export raw xml\n  _inherits(Fragment, _Dom);\n  return _createClass$1(Fragment, [{\n    key: \"xml\",\n    value: function xml(xmlOrFn, outerXML, ns) {\n      if (typeof xmlOrFn === 'boolean') {\n        ns = outerXML;\n        outerXML = xmlOrFn;\n        xmlOrFn = null;\n      }\n\n      // because this is a fragment we have to put all elements into a wrapper first\n      // before we can get the innerXML from it\n      if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n        var wrapper = new Dom(create('wrapper', ns));\n        wrapper.add(this.node.cloneNode(true));\n        return wrapper.xml(false, ns);\n      }\n\n      // Act as setter if we got a string\n      return _get(_getPrototypeOf(Fragment.prototype), \"xml\", this).call(this, xmlOrFn, false, ns);\n    }\n  }]);\n}(Dom);\nregister(Fragment, 'Fragment');\n\nfunction from(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    fx: new SVGNumber(x),\n    fy: new SVGNumber(y)\n  }) : this.attr({\n    x1: new SVGNumber(x),\n    y1: new SVGNumber(y)\n  });\n}\nfunction to(x, y) {\n  return (this._element || this).type === 'radialGradient' ? this.attr({\n    cx: new SVGNumber(x),\n    cy: new SVGNumber(y)\n  }) : this.attr({\n    x2: new SVGNumber(x),\n    y2: new SVGNumber(y)\n  });\n}\n\nvar gradiented = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  from: from,\n  to: to\n});\n\nfunction _callSuper$r(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$r() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Gradient = /*#__PURE__*/function (_Container) {\n  function Gradient(type, attrs) {\n    _classCallCheck$1(this, Gradient);\n    return _callSuper$r(this, Gradient, [nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs]);\n  }\n\n  // custom attr to handle transform\n  _inherits(Gradient, _Container);\n  return _createClass$1(Gradient, [{\n    key: \"attr\",\n    value: function attr(a, b, c) {\n      if (a === 'transform') a = 'gradientTransform';\n      return _get(_getPrototypeOf(Gradient.prototype), \"attr\", this).call(this, a, b, c);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return new Box();\n    }\n  }, {\n    key: \"targets\",\n    value: function targets() {\n      return baseFind('svg [fill*=' + this.id() + ']');\n    }\n\n    // Alias string conversion to fill\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.url();\n    }\n\n    // Update gradient\n  }, {\n    key: \"update\",\n    value: function update(block) {\n      // remove all stops\n      this.clear();\n\n      // invoke passed block\n      if (typeof block === 'function') {\n        block.call(this, this);\n      }\n      return this;\n    }\n\n    // Return the fill id\n  }, {\n    key: \"url\",\n    value: function url() {\n      return 'url(#' + this.id() + ')';\n    }\n  }]);\n}(Container);\nextend(Gradient, gradiented);\nregisterMethods({\n  Container: {\n    // Create gradient element in defs\n    gradient: function gradient() {\n      var _this$defs;\n      return (_this$defs = this.defs()).gradient.apply(_this$defs, arguments);\n    }\n  },\n  // define gradient\n  Defs: {\n    gradient: wrapWithAttrCheck(function (type, block) {\n      return this.put(new Gradient(type)).update(block);\n    })\n  }\n});\nregister(Gradient, 'Gradient');\n\nfunction _callSuper$q(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$q() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Pattern = /*#__PURE__*/function (_Container) {\n  // Initialize node\n  function Pattern(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Pattern);\n    return _callSuper$q(this, Pattern, [nodeOrNew('pattern', node), attrs]);\n  }\n\n  // custom attr to handle transform\n  _inherits(Pattern, _Container);\n  return _createClass$1(Pattern, [{\n    key: \"attr\",\n    value: function attr(a, b, c) {\n      if (a === 'transform') a = 'patternTransform';\n      return _get(_getPrototypeOf(Pattern.prototype), \"attr\", this).call(this, a, b, c);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return new Box();\n    }\n  }, {\n    key: \"targets\",\n    value: function targets() {\n      return baseFind('svg [fill*=' + this.id() + ']');\n    }\n\n    // Alias string conversion to fill\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.url();\n    }\n\n    // Update pattern by rebuilding\n  }, {\n    key: \"update\",\n    value: function update(block) {\n      // remove content\n      this.clear();\n\n      // invoke passed block\n      if (typeof block === 'function') {\n        block.call(this, this);\n      }\n      return this;\n    }\n\n    // Return the fill id\n  }, {\n    key: \"url\",\n    value: function url() {\n      return 'url(#' + this.id() + ')';\n    }\n  }]);\n}(Container);\nregisterMethods({\n  Container: {\n    // Create pattern element in defs\n    pattern: function pattern() {\n      var _this$defs;\n      return (_this$defs = this.defs()).pattern.apply(_this$defs, arguments);\n    }\n  },\n  Defs: {\n    pattern: wrapWithAttrCheck(function (width, height, block) {\n      return this.put(new Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    })\n  }\n});\nregister(Pattern, 'Pattern');\n\nfunction _callSuper$p(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$p() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Image = /*#__PURE__*/function (_Shape) {\n  function Image(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Image);\n    return _callSuper$p(this, Image, [nodeOrNew('image', node), attrs]);\n  }\n\n  // (re)load image\n  _inherits(Image, _Shape);\n  return _createClass$1(Image, [{\n    key: \"load\",\n    value: function load(url, callback) {\n      if (!url) return this;\n      var img = new globals.window.Image();\n      on(img, 'load', function (e) {\n        var p = this.parent(Pattern);\n\n        // ensure image size\n        if (this.width() === 0 && this.height() === 0) {\n          this.size(img.width, img.height);\n        }\n        if (p instanceof Pattern) {\n          // ensure pattern size if not set\n          if (p.width() === 0 && p.height() === 0) {\n            p.size(this.width(), this.height());\n          }\n        }\n        if (typeof callback === 'function') {\n          callback.call(this, e);\n        }\n      }, this);\n      on(img, 'load error', function () {\n        // dont forget to unbind memory leaking events\n        off(img);\n      });\n      return this.attr('href', img.src = url, xlink);\n    }\n  }]);\n}(Shape);\nregisterAttrHook(function (attr, val, _this) {\n  // convert image fill and stroke to patterns\n  if (attr === 'fill' || attr === 'stroke') {\n    if (isImage.test(val)) {\n      val = _this.root().defs().image(val);\n    }\n  }\n  if (val instanceof Image) {\n    val = _this.root().defs().pattern(0, 0, function (pattern) {\n      pattern.add(val);\n    });\n  }\n  return val;\n});\nregisterMethods({\n  Container: {\n    // create image element, load image and set its size\n    image: wrapWithAttrCheck(function (source, callback) {\n      return this.put(new Image()).size(0, 0).load(source, callback);\n    })\n  }\n});\nregister(Image, 'Image');\n\nfunction _callSuper$o(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$o() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() { return !!t; })(); }\nvar PointArray = /*#__PURE__*/function (_SVGArray) {\n  function PointArray() {\n    _classCallCheck$1(this, PointArray);\n    return _callSuper$o(this, PointArray, arguments);\n  }\n  _inherits(PointArray, _SVGArray);\n  return _createClass$1(PointArray, [{\n    key: \"bbox\",\n    value:\n    // Get bounding box of points\n    function bbox() {\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      var minX = Infinity;\n      var minY = Infinity;\n      this.forEach(function (el) {\n        maxX = Math.max(el[0], maxX);\n        maxY = Math.max(el[1], maxY);\n        minX = Math.min(el[0], minX);\n        minY = Math.min(el[1], minY);\n      });\n      return new Box(minX, minY, maxX - minX, maxY - minY);\n    }\n\n    // Move point string\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      var box = this.bbox();\n\n      // get relative offset\n      x -= box.x;\n      y -= box.y;\n\n      // move every point\n      if (!isNaN(x) && !isNaN(y)) {\n        for (var i = this.length - 1; i >= 0; i--) {\n          this[i] = [this[i][0] + x, this[i][1] + y];\n        }\n      }\n      return this;\n    }\n\n    // Parse point string and flat array\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0];\n      var points = [];\n\n      // if it is an array, we flatten it and therefore clone it to 1 depths\n      if (array instanceof Array) {\n        array = Array.prototype.concat.apply([], array);\n      } else {\n        // Else, it is considered as a string\n        // parse points\n        array = array.trim().split(delimiter).map(parseFloat);\n      }\n\n      // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n      if (array.length % 2 !== 0) array.pop();\n\n      // wrap points in two-tuples\n      for (var i = 0, len = array.length; i < len; i = i + 2) {\n        points.push([array[i], array[i + 1]]);\n      }\n      return points;\n    }\n\n    // Resize poly string\n  }, {\n    key: \"size\",\n    value: function size(width, height) {\n      var i;\n      var box = this.bbox();\n\n      // recalculate position of all points according to new size\n      for (i = this.length - 1; i >= 0; i--) {\n        if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;\n        if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n      }\n      return this;\n    }\n\n    // Convert array to line object\n  }, {\n    key: \"toLine\",\n    value: function toLine() {\n      return {\n        x1: this[0][0],\n        y1: this[0][1],\n        x2: this[1][0],\n        y2: this[1][1]\n      };\n    }\n\n    // Convert array to string\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var array = [];\n      // convert to a poly point string\n      for (var i = 0, il = this.length; i < il; i++) {\n        array.push(this[i].join(','));\n      }\n      return array.join(' ');\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(m) {\n      return this.clone().transformO(m);\n    }\n\n    // transform points with matrix (similar to Point.transform)\n  }, {\n    key: \"transformO\",\n    value: function transformO(m) {\n      if (!Matrix.isMatrixLike(m)) {\n        m = new Matrix(m);\n      }\n      for (var i = this.length; i--;) {\n        // Perform the matrix multiplication\n        var _this$i = _slicedToArray(this[i], 2),\n          x = _this$i[0],\n          y = _this$i[1];\n        this[i][0] = m.a * x + m.c * y + m.e;\n        this[i][1] = m.b * x + m.d * y + m.f;\n      }\n      return this;\n    }\n  }]);\n}(SVGArray);\n\nvar MorphArray = PointArray;\n\n// Move by left top corner over x-axis\nfunction x$2(x) {\n  return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n}\n\n// Move by left top corner over y-axis\nfunction y$2(y) {\n  return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n}\n\n// Set width of element\nfunction width$1(width) {\n  var b = this.bbox();\n  return width == null ? b.width : this.size(width, b.height);\n}\n\n// Set height of element\nfunction height$1(height) {\n  var b = this.bbox();\n  return height == null ? b.height : this.size(b.width, height);\n}\n\nvar pointed = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MorphArray: MorphArray,\n  height: height$1,\n  width: width$1,\n  x: x$2,\n  y: y$2\n});\n\nfunction _callSuper$n(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$n() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Line = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Line(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Line);\n    return _callSuper$n(this, Line, [nodeOrNew('line', node), attrs]);\n  }\n\n  // Get array\n  _inherits(Line, _Shape);\n  return _createClass$1(Line, [{\n    key: \"array\",\n    value: function array() {\n      return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n    }\n\n    // Move by left top corner\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      return this.attr(this.array().move(x, y).toLine());\n    }\n\n    // Overwrite native plot() method\n  }, {\n    key: \"plot\",\n    value: function plot(x1, y1, x2, y2) {\n      if (x1 == null) {\n        return this.array();\n      } else if (typeof y1 !== 'undefined') {\n        x1 = {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2\n        };\n      } else {\n        x1 = new PointArray(x1).toLine();\n      }\n      return this.attr(x1);\n    }\n\n    // Set element size to given width and height\n  }, {\n    key: \"size\",\n    value: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.attr(this.array().size(p.width, p.height).toLine());\n    }\n  }]);\n}(Shape);\nextend(Line, pointed);\nregisterMethods({\n  Container: {\n    // Create a line element\n    line: wrapWithAttrCheck(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      // make sure plot is called as a setter\n      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);\n    })\n  }\n});\nregister(Line, 'Line');\n\nfunction _callSuper$m(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$m() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Marker = /*#__PURE__*/function (_Container) {\n  // Initialize node\n  function Marker(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Marker);\n    return _callSuper$m(this, Marker, [nodeOrNew('marker', node), attrs]);\n  }\n\n  // Set height of element\n  _inherits(Marker, _Container);\n  return _createClass$1(Marker, [{\n    key: \"height\",\n    value: function height(_height) {\n      return this.attr('markerHeight', _height);\n    }\n  }, {\n    key: \"orient\",\n    value: function orient(_orient) {\n      return this.attr('orient', _orient);\n    }\n\n    // Set marker refX and refY\n  }, {\n    key: \"ref\",\n    value: function ref(x, y) {\n      return this.attr('refX', x).attr('refY', y);\n    }\n\n    // Return the fill id\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'url(#' + this.id() + ')';\n    }\n\n    // Update marker\n  }, {\n    key: \"update\",\n    value: function update(block) {\n      // remove all content\n      this.clear();\n\n      // invoke passed block\n      if (typeof block === 'function') {\n        block.call(this, this);\n      }\n      return this;\n    }\n\n    // Set width of element\n  }, {\n    key: \"width\",\n    value: function width(_width) {\n      return this.attr('markerWidth', _width);\n    }\n  }]);\n}(Container);\nregisterMethods({\n  Container: {\n    marker: function marker() {\n      var _this$defs;\n      // Create marker element in defs\n      return (_this$defs = this.defs()).marker.apply(_this$defs, arguments);\n    }\n  },\n  Defs: {\n    // Create marker\n    marker: wrapWithAttrCheck(function (width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    })\n  },\n  marker: {\n    // Create and attach markers\n    marker: function marker(_marker, width, height, block) {\n      var attr = ['marker'];\n\n      // Build attribute name\n      if (_marker !== 'all') attr.push(_marker);\n      attr = attr.join('-');\n\n      // Set marker attribute\n      _marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);\n      return this.attr(attr, _marker);\n    }\n  }\n});\nregister(Marker, 'Marker');\n\nfunction _callSuper$l(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$l() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() { return !!t; })(); }\n\n/***\nBase Class\n==========\nThe base stepper class that will be\n***/\n\nfunction makeSetterGetter(k, f) {\n  return function (v) {\n    if (v == null) return this[k];\n    this[k] = v;\n    if (f) f.call(this);\n    return this;\n  };\n}\nvar easing = {\n  '-': function _(pos) {\n    return pos;\n  },\n  '<>': function _(pos) {\n    return -Math.cos(pos * Math.PI) / 2 + 0.5;\n  },\n  '>': function _(pos) {\n    return Math.sin(pos * Math.PI / 2);\n  },\n  '<': function _(pos) {\n    return -Math.cos(pos * Math.PI / 2) + 1;\n  },\n  bezier: function bezier(x1, y1, x2, y2) {\n    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n    return function (t) {\n      if (t < 0) {\n        if (x1 > 0) {\n          return y1 / x1 * t;\n        } else if (x2 > 0) {\n          return y2 / x2 * t;\n        } else {\n          return 0;\n        }\n      } else if (t > 1) {\n        if (x2 < 1) {\n          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);\n        } else if (x1 < 1) {\n          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);\n        } else {\n          return 1;\n        }\n      } else {\n        return 3 * t * Math.pow(1 - t, 2) * y1 + 3 * Math.pow(t, 2) * (1 - t) * y2 + Math.pow(t, 3);\n      }\n    };\n  },\n  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n  steps: function steps(_steps) {\n    var stepPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end';\n    // deal with \"jump-\" prefix\n    stepPosition = stepPosition.split('-').reverse()[0];\n    var jumps = _steps;\n    if (stepPosition === 'none') {\n      --jumps;\n    } else if (stepPosition === 'both') {\n      ++jumps;\n    }\n\n    // The beforeFlag is essentially useless\n    return function (t) {\n      var beforeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Step is called currentStep in referenced url\n      var step = Math.floor(t * _steps);\n      var jumping = t * step % 1 === 0;\n      if (stepPosition === 'start' || stepPosition === 'both') {\n        ++step;\n      }\n      if (beforeFlag && jumping) {\n        --step;\n      }\n      if (t >= 0 && step < 0) {\n        step = 0;\n      }\n      if (t <= 1 && step > jumps) {\n        step = jumps;\n      }\n      return step / jumps;\n    };\n  }\n};\nvar Stepper = /*#__PURE__*/function () {\n  function Stepper() {\n    _classCallCheck$1(this, Stepper);\n  }\n  return _createClass$1(Stepper, [{\n    key: \"done\",\n    value: function done() {\n      return false;\n    }\n  }]);\n}();\n\n/***\nEasing Functions\n================\n***/\n\nvar Ease = /*#__PURE__*/function (_Stepper) {\n  function Ease() {\n    var _this;\n    var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timeline.ease;\n    _classCallCheck$1(this, Ease);\n    _this = _callSuper$l(this, Ease);\n    _this.ease = easing[fn] || fn;\n    return _this;\n  }\n  _inherits(Ease, _Stepper);\n  return _createClass$1(Ease, [{\n    key: \"step\",\n    value: function step(from, to, pos) {\n      if (typeof from !== 'number') {\n        return pos < 1 ? from : to;\n      }\n      return from + (to - from) * this.ease(pos);\n    }\n  }]);\n}(Stepper);\n\n/***\nController Types\n================\n***/\n\nvar Controller = /*#__PURE__*/function (_Stepper2) {\n  function Controller(fn) {\n    var _this2;\n    _classCallCheck$1(this, Controller);\n    _this2 = _callSuper$l(this, Controller);\n    _this2.stepper = fn;\n    return _this2;\n  }\n  _inherits(Controller, _Stepper2);\n  return _createClass$1(Controller, [{\n    key: \"done\",\n    value: function done(c) {\n      return c.done;\n    }\n  }, {\n    key: \"step\",\n    value: function step(current, target, dt, c) {\n      return this.stepper(current, target, dt, c);\n    }\n  }]);\n}(Stepper);\nfunction recalculate() {\n  // Apply the default parameters\n  var duration = (this._duration || 500) / 1000;\n  var overshoot = this._overshoot || 0;\n\n  // Calculate the PID natural response\n  var eps = 1e-10;\n  var pi = Math.PI;\n  var os = Math.log(overshoot / 100 + eps);\n  var zeta = -os / Math.sqrt(pi * pi + os * os);\n  var wn = 3.9 / (zeta * duration);\n\n  // Calculate the Spring values\n  this.d = 2 * zeta * wn;\n  this.k = wn * wn;\n}\nvar Spring = /*#__PURE__*/function (_Controller) {\n  function Spring() {\n    var _this3;\n    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;\n    var overshoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck$1(this, Spring);\n    _this3 = _callSuper$l(this, Spring);\n    _this3.duration(duration).overshoot(overshoot);\n    return _this3;\n  }\n  _inherits(Spring, _Controller);\n  return _createClass$1(Spring, [{\n    key: \"step\",\n    value: function step(current, target, dt, c) {\n      if (typeof current === 'string') return current;\n      c.done = dt === Infinity;\n      if (dt === Infinity) return target;\n      if (dt === 0) return current;\n      if (dt > 100) dt = 16;\n      dt /= 1000;\n\n      // Get the previous velocity\n      var velocity = c.velocity || 0;\n\n      // Apply the control to get the new position and store it\n      var acceleration = -this.d * velocity - this.k * (current - target);\n      var newPosition = current + velocity * dt + acceleration * dt * dt / 2;\n\n      // Store the velocity\n      c.velocity = velocity + acceleration * dt;\n\n      // Figure out if we have converged, and if so, pass the value\n      c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;\n      return c.done ? target : newPosition;\n    }\n  }]);\n}(Controller);\nextend(Spring, {\n  duration: makeSetterGetter('_duration', recalculate),\n  overshoot: makeSetterGetter('_overshoot', recalculate)\n});\nvar PID = /*#__PURE__*/function (_Controller2) {\n  function PID() {\n    var _this4;\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.1;\n    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;\n    var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var windup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    _classCallCheck$1(this, PID);\n    _this4 = _callSuper$l(this, PID);\n    _this4.p(p).i(i).d(d).windup(windup);\n    return _this4;\n  }\n  _inherits(PID, _Controller2);\n  return _createClass$1(PID, [{\n    key: \"step\",\n    value: function step(current, target, dt, c) {\n      if (typeof current === 'string') return current;\n      c.done = dt === Infinity;\n      if (dt === Infinity) return target;\n      if (dt === 0) return current;\n      var p = target - current;\n      var i = (c.integral || 0) + p * dt;\n      var d = (p - (c.error || 0)) / dt;\n      var windup = this._windup;\n\n      // antiwindup\n      if (windup !== false) {\n        i = Math.max(-windup, Math.min(i, windup));\n      }\n      c.error = p;\n      c.integral = i;\n      c.done = Math.abs(p) < 0.001;\n      return c.done ? target : current + (this.P * p + this.I * i + this.D * d);\n    }\n  }]);\n}(Controller);\nextend(PID, {\n  windup: makeSetterGetter('_windup'),\n  p: makeSetterGetter('P'),\n  i: makeSetterGetter('I'),\n  d: makeSetterGetter('D')\n});\n\nvar segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n};\nvar pathHandlers = {\n  M: function M(c, p, p0) {\n    p.x = p0.x = c[0];\n    p.y = p0.y = c[1];\n    return ['M', p.x, p.y];\n  },\n  L: function L(c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['L', c[0], c[1]];\n  },\n  H: function H(c, p) {\n    p.x = c[0];\n    return ['H', c[0]];\n  },\n  V: function V(c, p) {\n    p.y = c[0];\n    return ['V', c[0]];\n  },\n  C: function C(c, p) {\n    p.x = c[4];\n    p.y = c[5];\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n  },\n  S: function S(c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['S', c[0], c[1], c[2], c[3]];\n  },\n  Q: function Q(c, p) {\n    p.x = c[2];\n    p.y = c[3];\n    return ['Q', c[0], c[1], c[2], c[3]];\n  },\n  T: function T(c, p) {\n    p.x = c[0];\n    p.y = c[1];\n    return ['T', c[0], c[1]];\n  },\n  Z: function Z(c, p, p0) {\n    p.x = p0.x;\n    p.y = p0.y;\n    return ['Z'];\n  },\n  A: function A(c, p) {\n    p.x = c[5];\n    p.y = c[6];\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n  }\n};\nvar mlhvqtcsaz = 'mlhvqtcsaz'.split('');\nfor (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n        c[5] = c[5] + p.x;\n        c[6] = c[6] + p.y;\n      } else {\n        for (var j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n      }\n      return pathHandlers[i](c, p, p0);\n    };\n  }(mlhvqtcsaz[i].toUpperCase());\n}\nfunction makeAbsolut(parser) {\n  var command = parser.segment[0];\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0);\n}\nfunction segmentComplete(parser) {\n  return parser.segment.length && parser.segment.length - 1 === segmentParameters[parser.segment[0].toUpperCase()];\n}\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false);\n  var pathLetter = isPathLetter.test(token);\n  if (pathLetter) {\n    parser.segment = [token];\n  } else {\n    var lastCommand = parser.lastCommand;\n    var small = lastCommand.toLowerCase();\n    var isSmall = lastCommand === small;\n    parser.segment = [small === 'm' ? isSmall ? 'l' : 'L' : lastCommand];\n  }\n  parser.inSegment = true;\n  parser.lastCommand = parser.segment[0];\n  return pathLetter;\n}\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error');\n  parser.number && parser.segment.push(parseFloat(parser.number));\n  parser.inNumber = inNumber;\n  parser.number = '';\n  parser.pointSeen = false;\n  parser.hasExponent = false;\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n}\nfunction finalizeSegment(parser) {\n  parser.inSegment = false;\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser);\n  }\n  parser.segments.push(parser.segment);\n}\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false;\n  var isArc = parser.segment[0].toUpperCase() === 'A';\n  var length = parser.segment.length;\n  return isArc && (length === 4 || length === 5);\n}\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E';\n}\nvar pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f']);\nfunction pathParser(d) {\n  var toAbsolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var index = 0;\n  var token = '';\n  var parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  };\n  while (parser.lastToken = token, token = d.charAt(index++)) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue;\n      }\n    }\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.inNumber = true;\n      parser.pointSeen = true;\n      parser.number += token;\n      continue;\n    }\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true;\n        parser.number = token;\n        finalizeNumber(parser, true);\n        continue;\n      }\n      parser.inNumber = true;\n      parser.number += token;\n      continue;\n    }\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      }\n      continue;\n    }\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false);\n        --index;\n        continue;\n      }\n      parser.number += token;\n      parser.inNumber = true;\n      continue;\n    }\n    if (token.toUpperCase() === 'E') {\n      parser.number += token;\n      parser.hasExponent = true;\n      continue;\n    }\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false);\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error');\n      } else {\n        finalizeSegment(parser);\n      }\n      --index;\n    }\n  }\n  if (parser.inNumber) {\n    finalizeNumber(parser, false);\n  }\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser);\n  }\n  return parser.segments;\n}\n\nfunction _callSuper$k(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$k() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction arrayToString(a) {\n  var s = '';\n  for (var i = 0, il = a.length; i < il; i++) {\n    s += a[i][0];\n    if (a[i][1] != null) {\n      s += a[i][1];\n      if (a[i][2] != null) {\n        s += ' ';\n        s += a[i][2];\n        if (a[i][3] != null) {\n          s += ' ';\n          s += a[i][3];\n          s += ' ';\n          s += a[i][4];\n          if (a[i][5] != null) {\n            s += ' ';\n            s += a[i][5];\n            s += ' ';\n            s += a[i][6];\n            if (a[i][7] != null) {\n              s += ' ';\n              s += a[i][7];\n            }\n          }\n        }\n      }\n    }\n  }\n  return s + ' ';\n}\nvar PathArray = /*#__PURE__*/function (_SVGArray) {\n  function PathArray() {\n    _classCallCheck$1(this, PathArray);\n    return _callSuper$k(this, PathArray, arguments);\n  }\n  _inherits(PathArray, _SVGArray);\n  return _createClass$1(PathArray, [{\n    key: \"bbox\",\n    value:\n    // Get bounding box of path\n    function bbox() {\n      parser().path.setAttribute('d', this.toString());\n      return new Box(parser.nodes.path.getBBox());\n    }\n\n    // Move path string\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      // get bounding box of current situation\n      var box = this.bbox();\n\n      // get relative offset\n      x -= box.x;\n      y -= box.y;\n      if (!isNaN(x) && !isNaN(y)) {\n        // move every point\n        for (var l, i = this.length - 1; i >= 0; i--) {\n          l = this[i][0];\n          if (l === 'M' || l === 'L' || l === 'T') {\n            this[i][1] += x;\n            this[i][2] += y;\n          } else if (l === 'H') {\n            this[i][1] += x;\n          } else if (l === 'V') {\n            this[i][1] += y;\n          } else if (l === 'C' || l === 'S' || l === 'Q') {\n            this[i][1] += x;\n            this[i][2] += y;\n            this[i][3] += x;\n            this[i][4] += y;\n            if (l === 'C') {\n              this[i][5] += x;\n              this[i][6] += y;\n            }\n          } else if (l === 'A') {\n            this[i][6] += x;\n            this[i][7] += y;\n          }\n        }\n      }\n      return this;\n    }\n\n    // Absolutize and parse path to array\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'M0 0';\n      if (Array.isArray(d)) {\n        d = Array.prototype.concat.apply([], d).toString();\n      }\n      return pathParser(d);\n    }\n\n    // Resize path string\n  }, {\n    key: \"size\",\n    value: function size(width, height) {\n      // get bounding box of current situation\n      var box = this.bbox();\n      var i, l;\n\n      // If the box width or height is 0 then we ignore\n      // transformations on the respective axis\n      box.width = box.width === 0 ? 1 : box.width;\n      box.height = box.height === 0 ? 1 : box.height;\n\n      // recalculate position of all points according to new size\n      for (i = this.length - 1; i >= 0; i--) {\n        l = this[i][0];\n        if (l === 'M' || l === 'L' || l === 'T') {\n          this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n          this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n        } else if (l === 'H') {\n          this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n        } else if (l === 'V') {\n          this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n        } else if (l === 'C' || l === 'S' || l === 'Q') {\n          this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n          this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n          this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;\n          this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;\n          if (l === 'C') {\n            this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;\n            this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;\n          }\n        } else if (l === 'A') {\n          // resize radii\n          this[i][1] = this[i][1] * width / box.width;\n          this[i][2] = this[i][2] * height / box.height;\n\n          // move position values\n          this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;\n          this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;\n        }\n      }\n      return this;\n    }\n\n    // Convert array to string\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return arrayToString(this);\n    }\n  }]);\n}(SVGArray);\n\nvar getClassForType = function getClassForType(value) {\n  var type = _typeof$1(value);\n  if (type === 'number') {\n    return SVGNumber;\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color;\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray;\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber;\n    } else {\n      return NonMorphable;\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor;\n  } else if (Array.isArray(value)) {\n    return SVGArray;\n  } else if (type === 'object') {\n    return ObjectBag;\n  } else {\n    return NonMorphable;\n  }\n};\nvar Morphable = /*#__PURE__*/function () {\n  function Morphable(stepper) {\n    _classCallCheck$1(this, Morphable);\n    this._stepper = stepper || new Ease('-');\n    this._from = null;\n    this._to = null;\n    this._type = null;\n    this._context = null;\n    this._morphObj = null;\n  }\n  return _createClass$1(Morphable, [{\n    key: \"at\",\n    value: function at(pos) {\n      return this._morphObj.morph(this._from, this._to, pos, this._stepper, this._context);\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      var complete = this._context.map(this._stepper.done).reduce(function (last, curr) {\n        return last && curr;\n      }, true);\n      return complete;\n    }\n  }, {\n    key: \"from\",\n    value: function from(val) {\n      if (val == null) {\n        return this._from;\n      }\n      this._from = this._set(val);\n      return this;\n    }\n  }, {\n    key: \"stepper\",\n    value: function stepper(_stepper) {\n      if (_stepper == null) return this._stepper;\n      this._stepper = _stepper;\n      return this;\n    }\n  }, {\n    key: \"to\",\n    value: function to(val) {\n      if (val == null) {\n        return this._to;\n      }\n      this._to = this._set(val);\n      return this;\n    }\n  }, {\n    key: \"type\",\n    value: function type(_type) {\n      // getter\n      if (_type == null) {\n        return this._type;\n      }\n\n      // setter\n      this._type = _type;\n      return this;\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(value) {\n      if (!this._type) {\n        this.type(getClassForType(value));\n      }\n      var result = new this._type(value);\n      if (this._type === Color) {\n        result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;\n      }\n      if (this._type === ObjectBag) {\n        result = this._to ? result.align(this._to) : this._from ? result.align(this._from) : result;\n      }\n      result = result.toConsumable();\n      this._morphObj = this._morphObj || new this._type();\n      this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {\n        o.done = true;\n        return o;\n      });\n      return result;\n    }\n  }]);\n}();\nvar NonMorphable = /*#__PURE__*/function () {\n  function NonMorphable() {\n    _classCallCheck$1(this, NonMorphable);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(NonMorphable, [{\n    key: \"init\",\n    value: function init(val) {\n      val = Array.isArray(val) ? val[0] : val;\n      this.value = val;\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.value];\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value;\n    }\n  }]);\n}();\nvar TransformBag = /*#__PURE__*/function () {\n  function TransformBag() {\n    _classCallCheck$1(this, TransformBag);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(TransformBag, [{\n    key: \"init\",\n    value: function init(obj) {\n      if (Array.isArray(obj)) {\n        obj = {\n          scaleX: obj[0],\n          scaleY: obj[1],\n          shear: obj[2],\n          rotate: obj[3],\n          translateX: obj[4],\n          translateY: obj[5],\n          originX: obj[6],\n          originY: obj[7]\n        };\n      }\n      Object.assign(this, TransformBag.defaults, obj);\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var v = this;\n      return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];\n    }\n  }]);\n}();\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n};\nvar sortByKey = function sortByKey(a, b) {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;\n};\nvar ObjectBag = /*#__PURE__*/function () {\n  function ObjectBag() {\n    _classCallCheck$1(this, ObjectBag);\n    this.init.apply(this, arguments);\n  }\n  return _createClass$1(ObjectBag, [{\n    key: \"align\",\n    value: function align(other) {\n      var values = this.values;\n      for (var i = 0, il = values.length; i < il; ++i) {\n        // If the type is the same we only need to check if the color is in the correct format\n        if (values[i + 1] === other[i + 1]) {\n          if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n            var _this$values;\n            var space = other[i + 7];\n            var color = new Color(this.values.splice(i + 3, 5))[space]().toArray();\n            (_this$values = this.values).splice.apply(_this$values, [i + 3, 0].concat(_toConsumableArray(color)));\n          }\n          i += values[i + 2] + 2;\n          continue;\n        }\n        if (!other[i + 1]) {\n          return this;\n        }\n\n        // The types differ, so we overwrite the new type with the old one\n        // And initialize it with the types default (e.g. black for color or 0 for number)\n        var defaultObject = new other[i + 1]().toArray();\n\n        // Than we fix the values array\n        var toDelete = values[i + 2] + 3;\n        values.splice.apply(values, [i, toDelete, other[i], other[i + 1], other[i + 2]].concat(_toConsumableArray(defaultObject)));\n        i += values[i + 2] + 2;\n      }\n      return this;\n    }\n  }, {\n    key: \"init\",\n    value: function init(objOrArr) {\n      this.values = [];\n      if (Array.isArray(objOrArr)) {\n        this.values = objOrArr.slice();\n        return;\n      }\n      objOrArr = objOrArr || {};\n      var entries = [];\n      for (var i in objOrArr) {\n        var Type = getClassForType(objOrArr[i]);\n        var val = new Type(objOrArr[i]).toArray();\n        entries.push([i, Type, val.length].concat(_toConsumableArray(val)));\n      }\n      entries.sort(sortByKey);\n      this.values = entries.reduce(function (last, curr) {\n        return last.concat(curr);\n      }, []);\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.values;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var obj = {};\n      var arr = this.values;\n\n      // for (var i = 0, len = arr.length; i < len; i += 2) {\n      while (arr.length) {\n        var key = arr.shift();\n        var Type = arr.shift();\n        var num = arr.shift();\n        var values = arr.splice(0, num);\n        obj[key] = new Type(values); // .valueOf()\n      }\n      return obj;\n    }\n  }]);\n}();\nvar morphableTypes = [NonMorphable, TransformBag, ObjectBag];\nfunction registerMorphableType() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  morphableTypes.push.apply(morphableTypes, _toConsumableArray([].concat(type)));\n}\nfunction makeMorphable() {\n  extend(morphableTypes, {\n    to: function to(val) {\n      return new Morphable().type(this.constructor).from(this.toArray()) // this.valueOf())\n      .to(val);\n    },\n    fromArray: function fromArray(arr) {\n      this.init(arr);\n      return this;\n    },\n    toConsumable: function toConsumable() {\n      return this.toArray();\n    },\n    morph: function morph(from, to, pos, stepper, context) {\n      var mapper = function mapper(i, index) {\n        return stepper.step(i, to[index], pos, context[index], context);\n      };\n      return this.fromArray(from.map(mapper));\n    }\n  });\n}\n\nfunction _callSuper$j(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$j() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Path = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Path(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Path);\n    return _callSuper$j(this, Path, [nodeOrNew('path', node), attrs]);\n  }\n\n  // Get array\n  _inherits(Path, _Shape);\n  return _createClass$1(Path, [{\n    key: \"array\",\n    value: function array() {\n      return this._array || (this._array = new PathArray(this.attr('d')));\n    }\n\n    // Clear array cache\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      delete this._array;\n      return this;\n    }\n\n    // Set height of element\n  }, {\n    key: \"height\",\n    value: function height(_height) {\n      return _height == null ? this.bbox().height : this.size(this.bbox().width, _height);\n    }\n\n    // Move by left top corner\n  }, {\n    key: \"move\",\n    value: function move(x, y) {\n      return this.attr('d', this.array().move(x, y));\n    }\n\n    // Plot new path\n  }, {\n    key: \"plot\",\n    value: function plot(d) {\n      return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));\n    }\n\n    // Set element size to given width and height\n  }, {\n    key: \"size\",\n    value: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.attr('d', this.array().size(p.width, p.height));\n    }\n\n    // Set width of element\n  }, {\n    key: \"width\",\n    value: function width(_width) {\n      return _width == null ? this.bbox().width : this.size(_width, this.bbox().height);\n    }\n\n    // Move by left top corner over x-axis\n  }, {\n    key: \"x\",\n    value: function x(_x) {\n      return _x == null ? this.bbox().x : this.move(_x, this.bbox().y);\n    }\n\n    // Move by left top corner over y-axis\n  }, {\n    key: \"y\",\n    value: function y(_y) {\n      return _y == null ? this.bbox().y : this.move(this.bbox().x, _y);\n    }\n  }]);\n}(Shape); // Define morphable array\nPath.prototype.MorphArray = PathArray;\n\n// Add parent method\nregisterMethods({\n  Container: {\n    // Create a wrapped path element\n    path: wrapWithAttrCheck(function (d) {\n      // make sure plot is called as a setter\n      return this.put(new Path()).plot(d || new PathArray());\n    })\n  }\n});\nregister(Path, 'Path');\n\n// Get array\nfunction array() {\n  return this._array || (this._array = new PointArray(this.attr('points')));\n}\n\n// Clear array cache\nfunction clear() {\n  delete this._array;\n  return this;\n}\n\n// Move by left top corner\nfunction move$2(x, y) {\n  return this.attr('points', this.array().move(x, y));\n}\n\n// Plot new path\nfunction plot(p) {\n  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));\n}\n\n// Set element size to given width and height\nfunction size$1(width, height) {\n  var p = proportionalSize(this, width, height);\n  return this.attr('points', this.array().size(p.width, p.height));\n}\n\nvar poly = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  array: array,\n  clear: clear,\n  move: move$2,\n  plot: plot,\n  size: size$1\n});\n\nfunction _callSuper$i(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$i() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Polygon = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Polygon(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Polygon);\n    return _callSuper$i(this, Polygon, [nodeOrNew('polygon', node), attrs]);\n  }\n  _inherits(Polygon, _Shape);\n  return _createClass$1(Polygon);\n}(Shape);\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polygon: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polygon()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polygon, pointed);\nextend(Polygon, poly);\nregister(Polygon, 'Polygon');\n\nfunction _callSuper$h(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$h() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Polyline = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Polyline(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Polyline);\n    return _callSuper$h(this, Polyline, [nodeOrNew('polyline', node), attrs]);\n  }\n  _inherits(Polyline, _Shape);\n  return _createClass$1(Polyline);\n}(Shape);\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polyline: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polyline()).plot(p || new PointArray());\n    })\n  }\n});\nextend(Polyline, pointed);\nextend(Polyline, poly);\nregister(Polyline, 'Polyline');\n\nfunction _callSuper$g(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$g() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Rect = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Rect(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Rect);\n    return _callSuper$g(this, Rect, [nodeOrNew('rect', node), attrs]);\n  }\n  _inherits(Rect, _Shape);\n  return _createClass$1(Rect);\n}(Shape);\nextend(Rect, {\n  rx: rx,\n  ry: ry\n});\nregisterMethods({\n  Container: {\n    // Create a rect element\n    rect: wrapWithAttrCheck(function (width, height) {\n      return this.put(new Rect()).size(width, height);\n    })\n  }\n});\nregister(Rect, 'Rect');\n\nvar Queue = /*#__PURE__*/function () {\n  function Queue() {\n    _classCallCheck$1(this, Queue);\n    this._first = null;\n    this._last = null;\n  }\n\n  // Shows us the first item in the list\n  return _createClass$1(Queue, [{\n    key: \"first\",\n    value: function first() {\n      return this._first && this._first.value;\n    }\n\n    // Shows us the last item in the list\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this._last && this._last.value;\n    }\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      // An item stores an id and the provided value\n      var item = typeof value.next !== 'undefined' ? value : {\n        value: value,\n        next: null,\n        prev: null\n      };\n\n      // Deal with the queue being empty or populated\n      if (this._last) {\n        item.prev = this._last;\n        this._last.next = item;\n        this._last = item;\n      } else {\n        this._last = item;\n        this._first = item;\n      }\n\n      // Return the current item\n      return item;\n    }\n\n    // Removes the item that was returned from the push\n  }, {\n    key: \"remove\",\n    value: function remove(item) {\n      // Relink the previous item\n      if (item.prev) item.prev.next = item.next;\n      if (item.next) item.next.prev = item.prev;\n      if (item === this._last) this._last = item.prev;\n      if (item === this._first) this._first = item.next;\n\n      // Invalidate item\n      item.prev = null;\n      item.next = null;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      // Check if we have a value\n      var remove = this._first;\n      if (!remove) return null;\n\n      // If we do, remove it and relink things\n      this._first = remove.next;\n      if (this._first) this._first.prev = null;\n      this._last = this._first ? this._last : null;\n      return remove.value;\n    }\n  }]);\n}();\n\nvar Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: function timer() {\n    return globals.window.performance || globals.window.Date;\n  },\n  transforms: [],\n  frame: function frame(fn) {\n    // Store the node\n    var node = Animator.frames.push({\n      run: fn\n    });\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n\n    // Return the node so we can remove it easily\n    return node;\n  },\n  timeout: function timeout(fn, delay) {\n    delay = delay || 0;\n\n    // Work out when the event should fire\n    var time = Animator.timer().now() + delay;\n\n    // Add the timeout to the end of the queue\n    var node = Animator.timeouts.push({\n      run: fn,\n      time: time\n    });\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  immediate: function immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    var node = Animator.immediates.push(fn);\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n    }\n    return node;\n  },\n  cancelFrame: function cancelFrame(node) {\n    node != null && Animator.frames.remove(node);\n  },\n  clearTimeout: function clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node);\n  },\n  cancelImmediate: function cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node);\n  },\n  _draw: function _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    var nextTimeout = null;\n    var lastTimeout = Animator.timeouts.last();\n    while (nextTimeout = Animator.timeouts.shift()) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run();\n      } else {\n        Animator.timeouts.push(nextTimeout);\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break;\n    }\n\n    // Run all of the animation frames\n    var nextFrame = null;\n    var lastFrame = Animator.frames.last();\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now);\n    }\n    var nextImmediate = null;\n    while (nextImmediate = Animator.immediates.shift()) {\n      nextImmediate();\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;\n  }\n};\n\nfunction _callSuper$f(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() { return !!t; })(); }\nvar makeSchedule = function makeSchedule(runnerInfo) {\n  var start = runnerInfo.start;\n  var duration = runnerInfo.runner.duration();\n  var end = start + duration;\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  };\n};\nvar defaultSource = function defaultSource() {\n  var w = globals.window;\n  return (w.performance || w.Date).now();\n};\nvar Timeline = /*#__PURE__*/function (_EventTarget) {\n  // Construct a new timeline on the given element\n  function Timeline() {\n    var _this;\n    var timeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSource;\n    _classCallCheck$1(this, Timeline);\n    _this = _callSuper$f(this, Timeline);\n    _this._timeSource = timeSource;\n\n    // terminate resets all variables to their initial state\n    _this.terminate();\n    return _this;\n  }\n  _inherits(Timeline, _EventTarget);\n  return _createClass$1(Timeline, [{\n    key: \"active\",\n    value: function active() {\n      return !!this._nextFrame;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      // Go to end and pause\n      this.time(this.getEndTimeOfTimeline() + 1);\n      return this.pause();\n    }\n\n    // Calculates the end of the timeline\n  }, {\n    key: \"getEndTime\",\n    value: function getEndTime() {\n      var lastRunnerInfo = this.getLastRunnerInfo();\n      var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;\n      var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n      return lastStartTime + lastDuration;\n    }\n  }, {\n    key: \"getEndTimeOfTimeline\",\n    value: function getEndTimeOfTimeline() {\n      var endTimes = this._runners.map(function (i) {\n        return i.start + i.runner.duration();\n      });\n      return Math.max.apply(Math, [0].concat(_toConsumableArray(endTimes)));\n    }\n  }, {\n    key: \"getLastRunnerInfo\",\n    value: function getLastRunnerInfo() {\n      return this.getRunnerInfoById(this._lastRunnerId);\n    }\n  }, {\n    key: \"getRunnerInfoById\",\n    value: function getRunnerInfoById(id) {\n      return this._runners[this._runnerIds.indexOf(id)] || null;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n      return this._continue();\n    }\n  }, {\n    key: \"persist\",\n    value: function persist(dtOrForever) {\n      if (dtOrForever == null) return this._persist;\n      this._persist = dtOrForever;\n      return this;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      // Now make sure we are not paused and continue the animation\n      this._paused = false;\n      return this.updateTime()._continue();\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(yes) {\n      var currentSpeed = this.speed();\n      if (yes == null) return this.speed(-currentSpeed);\n      var positive = Math.abs(currentSpeed);\n      return this.speed(yes ? -positive : positive);\n    }\n\n    // schedules a runner on the timeline\n  }, {\n    key: \"schedule\",\n    value: function schedule(runner, delay, when) {\n      if (runner == null) {\n        return this._runners.map(makeSchedule);\n      }\n\n      // The start time for the next animation can either be given explicitly,\n      // derived from the current timeline time or it can be relative to the\n      // last start time to chain animations directly\n\n      var absoluteStartTime = 0;\n      var endTime = this.getEndTime();\n      delay = delay || 0;\n\n      // Work out when to start the animation\n      if (when == null || when === 'last' || when === 'after') {\n        // Take the last time and increment\n        absoluteStartTime = endTime;\n      } else if (when === 'absolute' || when === 'start') {\n        absoluteStartTime = delay;\n        delay = 0;\n      } else if (when === 'now') {\n        absoluteStartTime = this._time;\n      } else if (when === 'relative') {\n        var _runnerInfo = this.getRunnerInfoById(runner.id);\n        if (_runnerInfo) {\n          absoluteStartTime = _runnerInfo.start + delay;\n          delay = 0;\n        }\n      } else if (when === 'with-last') {\n        var lastRunnerInfo = this.getLastRunnerInfo();\n        var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;\n        absoluteStartTime = lastStartTime;\n      } else {\n        throw new Error('Invalid value for the \"when\" parameter');\n      }\n\n      // Manage runner\n      runner.unschedule();\n      runner.timeline(this);\n      var persist = runner.persist();\n      var runnerInfo = {\n        persist: persist === null ? this._persist : persist,\n        start: absoluteStartTime + delay,\n        runner: runner\n      };\n      this._lastRunnerId = runner.id;\n      this._runners.push(runnerInfo);\n      this._runners.sort(function (a, b) {\n        return a.start - b.start;\n      });\n      this._runnerIds = this._runners.map(function (info) {\n        return info.runner.id;\n      });\n      this.updateTime()._continue();\n      return this;\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(dt) {\n      return this.time(this._time + dt);\n    }\n  }, {\n    key: \"source\",\n    value: function source(fn) {\n      if (fn == null) return this._timeSource;\n      this._timeSource = fn;\n      return this;\n    }\n  }, {\n    key: \"speed\",\n    value: function speed(_speed) {\n      if (_speed == null) return this._speed;\n      this._speed = _speed;\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // Go to start and pause\n      this.time(0);\n      return this.pause();\n    }\n  }, {\n    key: \"time\",\n    value: function time(_time) {\n      if (_time == null) return this._time;\n      this._time = _time;\n      return this._continue(true);\n    }\n\n    // Remove the runner from this timeline\n  }, {\n    key: \"unschedule\",\n    value: function unschedule(runner) {\n      var index = this._runnerIds.indexOf(runner.id);\n      if (index < 0) return this;\n      this._runners.splice(index, 1);\n      this._runnerIds.splice(index, 1);\n      runner.timeline(null);\n      return this;\n    }\n\n    // Makes sure, that after pausing the time doesn't jump\n  }, {\n    key: \"updateTime\",\n    value: function updateTime() {\n      if (!this.active()) {\n        this._lastSourceTime = this._timeSource();\n      }\n      return this;\n    }\n\n    // Checks if we are running and continues the animation\n  }, {\n    key: \"_continue\",\n    value: function _continue() {\n      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      Animator.cancelFrame(this._nextFrame);\n      this._nextFrame = null;\n      if (immediateStep) return this._stepImmediate();\n      if (this._paused) return this;\n      this._nextFrame = Animator.frame(this._step);\n      return this;\n    }\n  }, {\n    key: \"_stepFn\",\n    value: function _stepFn() {\n      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // Get the time delta from the last time and update the time\n      var time = this._timeSource();\n      var dtSource = time - this._lastSourceTime;\n      if (immediateStep) dtSource = 0;\n      var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);\n      this._lastSourceTime = time;\n\n      // Only update the time if we use the timeSource.\n      // Otherwise use the current time\n      if (!immediateStep) {\n        // Update the time\n        this._time += dtTime;\n        this._time = this._time < 0 ? 0 : this._time;\n      }\n      this._lastStepTime = this._time;\n      this.fire('time', this._time);\n\n      // This is for the case that the timeline was seeked so that the time\n      // is now before the startTime of the runner. That is why we need to set\n      // the runner to position 0\n\n      // FIXME:\n      // However, resetting in insertion order leads to bugs. Considering the case,\n      // where 2 runners change the same attribute but in different times,\n      // resetting both of them will lead to the case where the later defined\n      // runner always wins the reset even if the other runner started earlier\n      // and therefore should win the attribute battle\n      // this can be solved by resetting them backwards\n      for (var k = this._runners.length; k--;) {\n        // Get and run the current runner and ignore it if its inactive\n        var runnerInfo = this._runners[k];\n        var runner = runnerInfo.runner;\n\n        // Make sure that we give the actual difference\n        // between runner start time and now\n        var dtToStart = this._time - runnerInfo.start;\n\n        // Dont run runner if not started yet\n        // and try to reset it\n        if (dtToStart <= 0) {\n          runner.reset();\n        }\n      }\n\n      // Run all of the runners directly\n      var runnersLeft = false;\n      for (var i = 0, len = this._runners.length; i < len; i++) {\n        // Get and run the current runner and ignore it if its inactive\n        var _runnerInfo2 = this._runners[i];\n        var _runner = _runnerInfo2.runner;\n        var dt = dtTime;\n\n        // Make sure that we give the actual difference\n        // between runner start time and now\n        var _dtToStart = this._time - _runnerInfo2.start;\n\n        // Dont run runner if not started yet\n        if (_dtToStart <= 0) {\n          runnersLeft = true;\n          continue;\n        } else if (_dtToStart < dt) {\n          // Adjust dt to make sure that animation is on point\n          dt = _dtToStart;\n        }\n        if (!_runner.active()) continue;\n\n        // If this runner is still going, signal that we need another animation\n        // frame, otherwise, remove the completed runner\n        var finished = _runner.step(dt).done;\n        if (!finished) {\n          runnersLeft = true;\n          // continue\n        } else if (_runnerInfo2.persist !== true) {\n          // runner is finished. And runner might get removed\n          var endTime = _runner.duration() - _runner.time() + this._time;\n          if (endTime + _runnerInfo2.persist < this._time) {\n            // Delete runner and correct index\n            _runner.unschedule();\n            --i;\n            --len;\n          }\n        }\n      }\n\n      // Basically: we continue when there are runners right from us in time\n      // when -->, and when runners are left from us when <--\n      if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {\n        this._continue();\n      } else {\n        this.pause();\n        this.fire('finished');\n      }\n      return this;\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      // cleanup memory\n\n      // Store the timing variables\n      this._startTime = 0;\n      this._speed = 1.0;\n\n      // Determines how long a runner is hold in memory. Can be a dt or true/false\n      this._persist = 0;\n\n      // Keep track of the running animations and their starting parameters\n      this._nextFrame = null;\n      this._paused = true;\n      this._runners = [];\n      this._runnerIds = [];\n      this._lastRunnerId = -1;\n      this._time = 0;\n      this._lastSourceTime = 0;\n      this._lastStepTime = 0;\n\n      // Make sure that step is always called in class context\n      this._step = this._stepFn.bind(this, false);\n      this._stepImmediate = this._stepFn.bind(this, true);\n    }\n  }]);\n}(EventTarget);\nregisterMethods({\n  Element: {\n    timeline: function timeline(_timeline) {\n      if (_timeline == null) {\n        this._timeline = this._timeline || new Timeline();\n        return this._timeline;\n      } else {\n        this._timeline = _timeline;\n        return this;\n      }\n    }\n  }\n});\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper$e(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Runner = /*#__PURE__*/function (_EventTarget) {\n  function Runner(options) {\n    var _this;\n    _classCallCheck$1(this, Runner);\n    _this = _callSuper$e(this, Runner);\n\n    // Store a unique id on the runner, so that we can identify it later\n    _this.id = Runner.id++;\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options;\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options;\n\n    // Declare all of the variables\n    _this._element = null;\n    _this._timeline = null;\n    _this.done = false;\n    _this._queue = [];\n\n    // Work out the stepper and the duration\n    _this._duration = typeof options === 'number' && options;\n    _this._isDeclarative = options instanceof Controller;\n    _this._stepper = _this._isDeclarative ? options : new Ease();\n\n    // We copy the current values from the timeline because they can change\n    _this._history = {};\n\n    // Store the state of the runner\n    _this.enabled = true;\n    _this._time = 0;\n    _this._lastTime = 0;\n\n    // At creation, the runner is in reset state\n    _this._reseted = true;\n\n    // Save transforms applied to this runner\n    _this.transforms = new Matrix();\n    _this.transformId = 1;\n\n    // Looping variables\n    _this._haveReversed = false;\n    _this._reverse = false;\n    _this._loopsDone = 0;\n    _this._swing = false;\n    _this._wait = 0;\n    _this._times = 1;\n    _this._frameId = null;\n\n    // Stores how long a runner is stored after being done\n    _this._persist = _this._isDeclarative ? true : null;\n    return _this;\n  }\n  _inherits(Runner, _EventTarget);\n  return _createClass$1(Runner, [{\n    key: \"active\",\n    value: function active(enabled) {\n      if (enabled == null) return this.enabled;\n      this.enabled = enabled;\n      return this;\n    }\n\n    /*\n    Private Methods\n    ===============\n    Methods that shouldn't be used externally\n    */\n  }, {\n    key: \"addTransform\",\n    value: function addTransform(transform) {\n      this.transforms.lmultiplyO(transform);\n      return this;\n    }\n  }, {\n    key: \"after\",\n    value: function after(fn) {\n      return this.on('finished', fn);\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(duration, delay, when) {\n      var o = Runner.sanitise(duration, delay, when);\n      var runner = new Runner(o.duration);\n      if (this._timeline) runner.timeline(this._timeline);\n      if (this._element) runner.element(this._element);\n      return runner.loop(o).schedule(o.delay, o.when);\n    }\n  }, {\n    key: \"clearTransform\",\n    value: function clearTransform() {\n      this.transforms = new Matrix();\n      return this;\n    }\n\n    // TODO: Keep track of all transformations so that deletion is faster\n  }, {\n    key: \"clearTransformsFromQueue\",\n    value: function clearTransformsFromQueue() {\n      if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\n        this._queue = this._queue.filter(function (item) {\n          return !item.isTransform;\n        });\n      }\n    }\n  }, {\n    key: \"delay\",\n    value: function delay(_delay) {\n      return this.animate(0, _delay);\n    }\n  }, {\n    key: \"duration\",\n    value: function duration() {\n      return this._times * (this._wait + this._duration) - this._wait;\n    }\n  }, {\n    key: \"during\",\n    value: function during(fn) {\n      return this.queue(null, fn);\n    }\n  }, {\n    key: \"ease\",\n    value: function ease(fn) {\n      this._stepper = new Ease(fn);\n      return this;\n    }\n    /*\n    Runner Definitions\n    ==================\n    These methods help us define the runtime behaviour of the Runner or they\n    help us make new runners from the current runner\n    */\n  }, {\n    key: \"element\",\n    value: function element(_element) {\n      if (_element == null) return this._element;\n      this._element = _element;\n      _element._prepareRunner();\n      return this;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return this.step(Infinity);\n    }\n  }, {\n    key: \"loop\",\n    value: function loop(times, swing, wait) {\n      // Deal with the user passing in an object\n      if (_typeof$1(times) === 'object') {\n        swing = times.swing;\n        wait = times.wait;\n        times = times.times;\n      }\n\n      // Sanitise the values and store them\n      this._times = times || Infinity;\n      this._swing = swing || false;\n      this._wait = wait || 0;\n\n      // Allow true to be passed\n      if (this._times === true) {\n        this._times = Infinity;\n      }\n      return this;\n    }\n  }, {\n    key: \"loops\",\n    value: function loops(p) {\n      var loopDuration = this._duration + this._wait;\n      if (p == null) {\n        var loopsDone = Math.floor(this._time / loopDuration);\n        var relativeTime = this._time - loopsDone * loopDuration;\n        var position = relativeTime / this._duration;\n        return Math.min(loopsDone + position, this._times);\n      }\n      var whole = Math.floor(p);\n      var partial = p % 1;\n      var time = loopDuration * whole + this._duration * partial;\n      return this.time(time);\n    }\n  }, {\n    key: \"persist\",\n    value: function persist(dtOrForever) {\n      if (dtOrForever == null) return this._persist;\n      this._persist = dtOrForever;\n      return this;\n    }\n  }, {\n    key: \"position\",\n    value: function position(p) {\n      // Get all of the variables we need\n      var x = this._time;\n      var d = this._duration;\n      var w = this._wait;\n      var t = this._times;\n      var s = this._swing;\n      var r = this._reverse;\n      var position;\n      if (p == null) {\n        /*\n        This function converts a time to a position in the range [0, 1]\n        The full explanation can be found in this desmos demonstration\n          https://www.desmos.com/calculator/u4fbavgche\n        The logic is slightly simplified here because we can use booleans\n        */\n\n        // Figure out the value without thinking about the start or end time\n        var f = function f(x) {\n          var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));\n          var backwards = swinging && !r || !swinging && r;\n          var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;\n          var clipped = Math.max(Math.min(uncliped, 1), 0);\n          return clipped;\n        };\n\n        // Figure out the value by incorporating the start time\n        var endTime = t * (w + d) - w;\n        position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));\n        return position;\n      }\n\n      // Work out the loops done and add the position to the loops done\n      var loopsDone = Math.floor(this.loops());\n      var swingForward = s && loopsDone % 2 === 0;\n      var forwards = swingForward && !r || r && swingForward;\n      position = loopsDone + (forwards ? p : 1 - p);\n      return this.loops(position);\n    }\n  }, {\n    key: \"progress\",\n    value: function progress(p) {\n      if (p == null) {\n        return Math.min(1, this._time / this.duration());\n      }\n      return this.time(p * this.duration());\n    }\n\n    /*\n    Basic Functionality\n    ===================\n    These methods allow us to attach basic functions to the runner directly\n    */\n  }, {\n    key: \"queue\",\n    value: function queue(initFn, runFn, retargetFn, isTransform) {\n      this._queue.push({\n        initialiser: initFn || noop,\n        runner: runFn || noop,\n        retarget: retargetFn,\n        isTransform: isTransform,\n        initialised: false,\n        finished: false\n      });\n      var timeline = this.timeline();\n      timeline && this.timeline()._continue();\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this._reseted) return this;\n      this.time(0);\n      this._reseted = true;\n      return this;\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(_reverse) {\n      this._reverse = _reverse == null ? !this._reverse : _reverse;\n      return this;\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(timeline, delay, when) {\n      // The user doesn't need to pass a timeline if we already have one\n      if (!(timeline instanceof Timeline)) {\n        when = delay;\n        delay = timeline;\n        timeline = this.timeline();\n      }\n\n      // If there is no timeline, yell at the user...\n      if (!timeline) {\n        throw Error('Runner cannot be scheduled without timeline');\n      }\n\n      // Schedule the runner on the timeline provided\n      timeline.schedule(this, delay, when);\n      return this;\n    }\n  }, {\n    key: \"step\",\n    value: function step(dt) {\n      // If we are inactive, this stepper just gets skipped\n      if (!this.enabled) return this;\n\n      // Update the time and get the new position\n      dt = dt == null ? 16 : dt;\n      this._time += dt;\n      var position = this.position();\n\n      // Figure out if we need to run the stepper in this frame\n      var running = this._lastPosition !== position && this._time >= 0;\n      this._lastPosition = position;\n\n      // Figure out if we just started\n      var duration = this.duration();\n      var justStarted = this._lastTime <= 0 && this._time > 0;\n      var justFinished = this._lastTime < duration && this._time >= duration;\n      this._lastTime = this._time;\n      if (justStarted) {\n        this.fire('start', this);\n      }\n\n      // Work out if the runner is finished set the done flag here so animations\n      // know, that they are running in the last step (this is good for\n      // transformations which can be merged)\n      var declarative = this._isDeclarative;\n      this.done = !declarative && !justFinished && this._time >= duration;\n\n      // Runner is running. So its not in reset state anymore\n      this._reseted = false;\n      var converged = false;\n      // Call initialise and the run function\n      if (running || declarative) {\n        this._initialise(running);\n\n        // clear the transforms on this runner so they dont get added again and again\n        this.transforms = new Matrix();\n        converged = this._run(declarative ? dt : position);\n        this.fire('step', this);\n      }\n      // correct the done flag here\n      // declarative animations itself know when they converged\n      this.done = this.done || converged && declarative;\n      if (justFinished) {\n        this.fire('finished', this);\n      }\n      return this;\n    }\n\n    /*\n    Runner animation methods\n    ========================\n    Control how the animation plays\n    */\n  }, {\n    key: \"time\",\n    value: function time(_time) {\n      if (_time == null) {\n        return this._time;\n      }\n      var dt = _time - this._time;\n      this.step(dt);\n      return this;\n    }\n  }, {\n    key: \"timeline\",\n    value: function timeline(_timeline) {\n      // check explicitly for undefined so we can set the timeline to null\n      if (typeof _timeline === 'undefined') return this._timeline;\n      this._timeline = _timeline;\n      return this;\n    }\n  }, {\n    key: \"unschedule\",\n    value: function unschedule() {\n      var timeline = this.timeline();\n      timeline && timeline.unschedule(this);\n      return this;\n    }\n\n    // Run each initialise function in the runner if required\n  }, {\n    key: \"_initialise\",\n    value: function _initialise(running) {\n      // If we aren't running, we shouldn't initialise when not declarative\n      if (!running && !this._isDeclarative) return;\n\n      // Loop through all of the initialisers\n      for (var i = 0, len = this._queue.length; i < len; ++i) {\n        // Get the current initialiser\n        var current = this._queue[i];\n\n        // Determine whether we need to initialise\n        var needsIt = this._isDeclarative || !current.initialised && running;\n        running = !current.finished;\n\n        // Call the initialiser if we need to\n        if (needsIt && running) {\n          current.initialiser.call(this);\n          current.initialised = true;\n        }\n      }\n    }\n\n    // Save a morpher to the morpher list so that we can retarget it later\n  }, {\n    key: \"_rememberMorpher\",\n    value: function _rememberMorpher(method, morpher) {\n      this._history[method] = {\n        morpher: morpher,\n        caller: this._queue[this._queue.length - 1]\n      };\n\n      // We have to resume the timeline in case a controller\n      // is already done without being ever run\n      // This can happen when e.g. this is done:\n      //    anim = el.animate(new SVG.Spring)\n      // and later\n      //    anim.move(...)\n      if (this._isDeclarative) {\n        var _timeline2 = this.timeline();\n        _timeline2 && _timeline2.play();\n      }\n    }\n\n    // Try to set the target for a morpher if the morpher exists, otherwise\n    // Run each run function for the position or dt given\n  }, {\n    key: \"_run\",\n    value: function _run(positionOrDt) {\n      // Run all of the _queue directly\n      var allfinished = true;\n      for (var i = 0, len = this._queue.length; i < len; ++i) {\n        // Get the current function to run\n        var current = this._queue[i];\n\n        // Run the function if its not finished, we keep track of the finished\n        // flag for the sake of declarative _queue\n        var converged = current.runner.call(this, positionOrDt);\n        current.finished = current.finished || converged === true;\n        allfinished = allfinished && current.finished;\n      }\n\n      // We report when all of the constructors are finished\n      return allfinished;\n    }\n\n    // do nothing and return false\n  }, {\n    key: \"_tryRetarget\",\n    value: function _tryRetarget(method, target, extra) {\n      if (this._history[method]) {\n        // if the last method wasn't even initialised, throw it away\n        if (!this._history[method].caller.initialised) {\n          var index = this._queue.indexOf(this._history[method].caller);\n          this._queue.splice(index, 1);\n          return false;\n        }\n\n        // for the case of transformations, we use the special retarget function\n        // which has access to the outer scope\n        if (this._history[method].caller.retarget) {\n          this._history[method].caller.retarget.call(this, target, extra);\n          // for everything else a simple morpher change is sufficient\n        } else {\n          this._history[method].morpher.to(target);\n        }\n        this._history[method].caller.finished = false;\n        var _timeline3 = this.timeline();\n        _timeline3 && _timeline3.play();\n        return true;\n      }\n      return false;\n    }\n  }], [{\n    key: \"sanitise\",\n    value: function sanitise(duration, delay, when) {\n      var _duration, _delay2;\n      // Initialise the default parameters\n      var times = 1;\n      var swing = false;\n      var wait = 0;\n      duration = (_duration = duration) !== null && _duration !== void 0 ? _duration : timeline.duration;\n      delay = (_delay2 = delay) !== null && _delay2 !== void 0 ? _delay2 : timeline.delay;\n      when = when || 'last';\n\n      // If we have an object, unpack the values\n      if (_typeof$1(duration) === 'object' && !(duration instanceof Stepper)) {\n        var _duration$delay, _duration$when, _duration$times, _duration$wait, _duration$duration;\n        delay = (_duration$delay = duration.delay) !== null && _duration$delay !== void 0 ? _duration$delay : delay;\n        when = (_duration$when = duration.when) !== null && _duration$when !== void 0 ? _duration$when : when;\n        swing = duration.swing || swing;\n        times = (_duration$times = duration.times) !== null && _duration$times !== void 0 ? _duration$times : times;\n        wait = (_duration$wait = duration.wait) !== null && _duration$wait !== void 0 ? _duration$wait : wait;\n        duration = (_duration$duration = duration.duration) !== null && _duration$duration !== void 0 ? _duration$duration : timeline.duration;\n      }\n      return {\n        duration: duration,\n        delay: delay,\n        swing: swing,\n        times: times,\n        wait: wait,\n        when: when\n      };\n    }\n  }]);\n}(EventTarget);\nRunner.id = 0;\nvar FakeRunner = /*#__PURE__*/function () {\n  function FakeRunner() {\n    var transforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    _classCallCheck$1(this, FakeRunner);\n    this.transforms = transforms;\n    this.id = id;\n    this.done = done;\n  }\n  return _createClass$1(FakeRunner, [{\n    key: \"clearTransformsFromQueue\",\n    value: function clearTransformsFromQueue() {}\n  }]);\n}();\nextend([Runner, FakeRunner], {\n  mergeWith: function mergeWith(runner) {\n    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);\n  }\n});\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nvar lmultiply = function lmultiply(last, curr) {\n  return last.lmultiplyO(curr);\n};\nvar getRunnerTransform = function getRunnerTransform(runner) {\n  return runner.transforms;\n};\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  var runners = this._transformationRunners.runners;\n  var netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());\n  this.transform(netTransform);\n  this._transformationRunners.merge();\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null;\n  }\n}\nvar RunnerArray = /*#__PURE__*/function () {\n  function RunnerArray() {\n    _classCallCheck$1(this, RunnerArray);\n    this.runners = [];\n    this.ids = [];\n  }\n  return _createClass$1(RunnerArray, [{\n    key: \"add\",\n    value: function add(runner) {\n      if (this.runners.includes(runner)) return;\n      var id = runner.id + 1;\n      this.runners.push(runner);\n      this.ids.push(id);\n      return this;\n    }\n  }, {\n    key: \"clearBefore\",\n    value: function clearBefore(id) {\n      var deleteCnt = this.ids.indexOf(id + 1) || 1;\n      this.ids.splice(0, deleteCnt, 0);\n      this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(function (r) {\n        return r.clearTransformsFromQueue();\n      });\n      return this;\n    }\n  }, {\n    key: \"edit\",\n    value: function edit(id, newRunner) {\n      var index = this.ids.indexOf(id + 1);\n      this.ids.splice(index, 1, id + 1);\n      this.runners.splice(index, 1, newRunner);\n      return this;\n    }\n  }, {\n    key: \"getByID\",\n    value: function getByID(id) {\n      return this.runners[this.ids.indexOf(id + 1)];\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.ids.length;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge() {\n      var lastRunner = null;\n      for (var i = 0; i < this.runners.length; ++i) {\n        var runner = this.runners[i];\n        var condition = lastRunner && runner.done && lastRunner.done && (\n        // don't merge runner when persisted on timeline\n        !runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));\n        if (condition) {\n          // the +1 happens in the function\n          this.remove(runner.id);\n          var newRunner = runner.mergeWith(lastRunner);\n          this.edit(lastRunner.id, newRunner);\n          lastRunner = newRunner;\n          --i;\n        } else {\n          lastRunner = runner;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      var index = this.ids.indexOf(id + 1);\n      this.ids.splice(index, 1);\n      this.runners.splice(index, 1);\n      return this;\n    }\n  }]);\n}();\nregisterMethods({\n  Element: {\n    animate: function animate(duration, delay, when) {\n      var o = Runner.sanitise(duration, delay, when);\n      var timeline = this.timeline();\n      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);\n    },\n    delay: function delay(by, when) {\n      return this.animate(0, by, when);\n    },\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore: function _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id);\n    },\n    _currentTransform: function _currentTransform(current) {\n      return this._transformationRunners.runners\n      // we need the equal sign here to make sure, that also transformations\n      // on the same runner which execute before the current transformation are\n      // taken into account\n      .filter(function (runner) {\n        return runner.id <= current.id;\n      }).map(getRunnerTransform).reduce(lmultiply, new Matrix());\n    },\n    _addRunner: function _addRunner(runner) {\n      this._transformationRunners.add(runner);\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      Animator.cancelImmediate(this._frameId);\n      this._frameId = Animator.immediate(mergeTransforms.bind(this));\n    },\n    _prepareRunner: function _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));\n      }\n    }\n  }\n});\n\n// Will output the elements from array A that are not in the array B\nvar difference = function difference(a, b) {\n  return a.filter(function (x) {\n    return !b.includes(x);\n  });\n};\nextend(Runner, {\n  attr: function attr(a, v) {\n    return this.styleAttr('attr', a, v);\n  },\n  // Add animatable styles\n  css: function css(s, v) {\n    return this.styleAttr('css', s, v);\n  },\n  styleAttr: function styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, _defineProperty({}, nameOrAttrs, val));\n    }\n    var attrs = nameOrAttrs;\n    if (this._tryRetarget(type, attrs)) return this;\n    var morpher = new Morphable(this._stepper).to(attrs);\n    var keys = Object.keys(attrs);\n    this.queue(function () {\n      morpher = morpher.from(this.element()[type](keys));\n    }, function (pos) {\n      this.element()[type](morpher.at(pos).valueOf());\n      return morpher.done();\n    }, function (newToAttrs) {\n      // Check if any new keys were added\n      var newKeys = Object.keys(newToAttrs);\n      var differences = difference(newKeys, keys);\n\n      // If their are new keys, initialize them and add them to morpher\n      if (differences.length) {\n        // Get the values\n        var addedFromAttrs = this.element()[type](differences);\n\n        // Get the already initialized values\n        var oldFromAttrs = new ObjectBag(morpher.from()).valueOf();\n\n        // Merge old and new\n        Object.assign(oldFromAttrs, addedFromAttrs);\n        morpher.from(oldFromAttrs);\n      }\n\n      // Get the object from the morpher\n      var oldToAttrs = new ObjectBag(morpher.to()).valueOf();\n\n      // Merge in new attributes\n      Object.assign(oldToAttrs, newToAttrs);\n\n      // Change morpher target\n      morpher.to(oldToAttrs);\n\n      // Make sure that we save the work we did so we don't need it to do again\n      keys = newKeys;\n      attrs = newToAttrs;\n    });\n    this._rememberMorpher(type, morpher);\n    return this;\n  },\n  zoom: function zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this;\n    var morpher = new Morphable(this._stepper).to(new SVGNumber(level));\n    this.queue(function () {\n      morpher = morpher.from(this.element().zoom());\n    }, function (pos) {\n      this.element().zoom(morpher.at(pos), point);\n      return morpher.done();\n    }, function (newLevel, newPoint) {\n      point = newPoint;\n      morpher.to(newLevel);\n    });\n    this._rememberMorpher('zoom', morpher);\n    return this;\n  },\n  /**\n   ** absolute transformations\n   **/\n  //\n  // M v -----|-----(D M v = F v)------|----->  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n  transform: function transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative;\n    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\n      return this;\n    }\n\n    // Parse the parameters\n    var isMatrix = Matrix.isMatrixLike(transforms);\n    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix;\n\n    // Create a morpher and set its type\n    var morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);\n    var origin;\n    var element;\n    var current;\n    var currentAngle;\n    var startTransform;\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element();\n      origin = origin || getOrigin(transforms, element);\n      startTransform = new Matrix(relative ? undefined : element);\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this);\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this);\n      }\n    }\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform();\n      var _Point$transform = new Point(origin).transform(element._currentTransform(this)),\n        x = _Point$transform.x,\n        y = _Point$transform.y;\n      var target = new Matrix(_objectSpread$1(_objectSpread$1({}, transforms), {}, {\n        origin: [x, y]\n      }));\n      var start = this._isDeclarative && current ? current : startTransform;\n      if (affine) {\n        target = target.decompose(x, y);\n        start = start.decompose(x, y);\n\n        // Get the current and target angle as it was set\n        var rTarget = target.rotate;\n        var rCurrent = start.rotate;\n\n        // Figure out the shortest path to rotate directly\n        var possibilities = [rTarget - 360, rTarget, rTarget + 360];\n        var distances = possibilities.map(function (a) {\n          return Math.abs(a - rCurrent);\n        });\n        var shortest = Math.min.apply(Math, _toConsumableArray(distances));\n        var index = distances.indexOf(shortest);\n        target.rotate = possibilities[index];\n      }\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0;\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle;\n        }\n      }\n      morpher.from(start);\n      morpher.to(target);\n      var affineParameters = morpher.at(pos);\n      currentAngle = affineParameters.rotate;\n      current = new Matrix(affineParameters);\n      this.addTransform(current);\n      element._addRunner(this);\n      return morpher.done();\n    }\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {\n        origin = getOrigin(newTransforms, element);\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = _objectSpread$1(_objectSpread$1({}, newTransforms), {}, {\n        origin: origin\n      });\n    }\n    this.queue(setup, run, retarget, true);\n    this._isDeclarative && this._rememberMorpher('transform', morpher);\n    return this;\n  },\n  // Animatable x-axis\n  x: function x(_x) {\n    return this._queueNumber('x', _x);\n  },\n  // Animatable y-axis\n  y: function y(_y) {\n    return this._queueNumber('y', _y);\n  },\n  ax: function ax(x) {\n    return this._queueNumber('ax', x);\n  },\n  ay: function ay(y) {\n    return this._queueNumber('ay', y);\n  },\n  dx: function dx() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._queueNumberDelta('x', x);\n  },\n  dy: function dy() {\n    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._queueNumberDelta('y', y);\n  },\n  dmove: function dmove(x, y) {\n    return this.dx(x).dy(y);\n  },\n  _queueNumberDelta: function _queueNumberDelta(method, to) {\n    to = new SVGNumber(to);\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    var morpher = new Morphable(this._stepper).to(to);\n    var from = null;\n    this.queue(function () {\n      from = this.element()[method]();\n      morpher.from(from);\n      morpher.to(from + to);\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    }, function (newTo) {\n      morpher.to(from + new SVGNumber(newTo));\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueObject: function _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this;\n\n    // Make a morpher and queue the animation\n    var morpher = new Morphable(this._stepper).to(to);\n    this.queue(function () {\n      morpher.from(this.element()[method]());\n    }, function (pos) {\n      this.element()[method](morpher.at(pos));\n      return morpher.done();\n    });\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher);\n    return this;\n  },\n  _queueNumber: function _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value));\n  },\n  // Animatable center x-axis\n  cx: function cx(x) {\n    return this._queueNumber('cx', x);\n  },\n  // Animatable center y-axis\n  cy: function cy(y) {\n    return this._queueNumber('cy', y);\n  },\n  // Add animatable move\n  move: function move(x, y) {\n    return this.x(x).y(y);\n  },\n  amove: function amove(x, y) {\n    return this.ax(x).ay(y);\n  },\n  // Add animatable center\n  center: function center(x, y) {\n    return this.cx(x).cy(y);\n  },\n  // Add animatable size\n  size: function size(width, height) {\n    // animate bbox based size for all other elements\n    var box;\n    if (!width || !height) {\n      box = this._element.bbox();\n    }\n    if (!width) {\n      width = box.width / box.height * height;\n    }\n    if (!height) {\n      height = box.height / box.width * width;\n    }\n    return this.width(width).height(height);\n  },\n  // Add animatable width\n  width: function width(_width) {\n    return this._queueNumber('width', _width);\n  },\n  // Add animatable height\n  height: function height(_height) {\n    return this._queueNumber('height', _height);\n  },\n  // Add animatable plot\n  plot: function plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d]);\n    }\n    if (this._tryRetarget('plot', a)) return this;\n    var morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);\n    this.queue(function () {\n      morpher.from(this._element.array());\n    }, function (pos) {\n      this._element.plot(morpher.at(pos));\n      return morpher.done();\n    });\n    this._rememberMorpher('plot', morpher);\n    return this;\n  },\n  // Add leading method\n  leading: function leading(value) {\n    return this._queueNumber('leading', value);\n  },\n  // Add animatable viewbox\n  viewbox: function viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height));\n  },\n  update: function update(o) {\n    if (_typeof$1(o) !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      });\n    }\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n    if (o.color != null) this.attr('stop-color', o.color);\n    if (o.offset != null) this.attr('offset', o.offset);\n    return this;\n  }\n});\nextend(Runner, {\n  rx: rx,\n  ry: ry,\n  from: from,\n  to: to\n});\nregister(Runner, 'Runner');\n\nfunction _callSuper$d(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Svg = /*#__PURE__*/function (_Container) {\n  function Svg(node) {\n    var _this;\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Svg);\n    _this = _callSuper$d(this, Svg, [nodeOrNew('svg', node), attrs]);\n    _this.namespace();\n    return _this;\n  }\n\n  // Creates and returns defs element\n  _inherits(Svg, _Container);\n  return _createClass$1(Svg, [{\n    key: \"defs\",\n    value: function defs() {\n      if (!this.isRoot()) return this.root().defs();\n      return adopt(this.node.querySelector('defs')) || this.put(new Defs());\n    }\n  }, {\n    key: \"isRoot\",\n    value: function isRoot() {\n      return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) && this.node.parentNode.nodeName !== '#document-fragment';\n    }\n\n    // Add namespaces\n  }, {\n    key: \"namespace\",\n    value: function namespace() {\n      if (!this.isRoot()) return this.root().namespace();\n      return this.attr({\n        xmlns: svg,\n        version: '1.1'\n      }).attr('xmlns:xlink', xlink, xmlns);\n    }\n  }, {\n    key: \"removeNamespace\",\n    value: function removeNamespace() {\n      return this.attr({\n        xmlns: null,\n        version: null\n      }).attr('xmlns:xlink', null, xmlns).attr('xmlns:svgjs', null, xmlns);\n    }\n\n    // Check if this is a root svg\n    // If not, call root() from this element\n  }, {\n    key: \"root\",\n    value: function root() {\n      if (this.isRoot()) return this;\n      return _get(_getPrototypeOf(Svg.prototype), \"root\", this).call(this);\n    }\n  }]);\n}(Container);\nregisterMethods({\n  Container: {\n    // Create nested svg document\n    nested: wrapWithAttrCheck(function () {\n      return this.put(new Svg());\n    })\n  }\n});\nregister(Svg, 'Svg', true);\n\nfunction _callSuper$c(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() { return !!t; })(); }\nvar _Symbol = /*#__PURE__*/function (_Container) {\n  // Initialize node\n  function _Symbol(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, _Symbol);\n    return _callSuper$c(this, _Symbol, [nodeOrNew('symbol', node), attrs]);\n  }\n  _inherits(_Symbol, _Container);\n  return _createClass$1(_Symbol);\n}(Container);\nregisterMethods({\n  Container: {\n    symbol: wrapWithAttrCheck(function () {\n      return this.put(new _Symbol());\n    })\n  }\n});\nregister(_Symbol, 'Symbol');\n\n// Create plain text node\nfunction plain(text) {\n  // clear if build mode is disabled\n  if (this._build === false) {\n    this.clear();\n  }\n\n  // create text node\n  this.node.appendChild(globals.document.createTextNode(text));\n  return this;\n}\n\n// Get length of text element\nfunction length() {\n  return this.node.getComputedTextLength();\n}\n\n// Move over x-axis\n// Text is moved by its bounding box\n// text-anchor does NOT matter\nfunction x$1(x) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (x == null) {\n    return box.x;\n  }\n  return this.attr('x', this.attr('x') + x - box.x);\n}\n\n// Move over y-axis\nfunction y$1(y) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (y == null) {\n    return box.y;\n  }\n  return this.attr('y', this.attr('y') + y - box.y);\n}\nfunction move$1(x, y) {\n  var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n  return this.x(x, box).y(y, box);\n}\n\n// Move center over x-axis\nfunction cx(x) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (x == null) {\n    return box.cx;\n  }\n  return this.attr('x', this.attr('x') + x - box.cx);\n}\n\n// Move center over y-axis\nfunction cy(y) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (y == null) {\n    return box.cy;\n  }\n  return this.attr('y', this.attr('y') + y - box.cy);\n}\nfunction center(x, y) {\n  var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n  return this.cx(x, box).cy(y, box);\n}\nfunction ax(x) {\n  return this.attr('x', x);\n}\nfunction ay(y) {\n  return this.attr('y', y);\n}\nfunction amove(x, y) {\n  return this.ax(x).ay(y);\n}\n\n// Enable / disable build mode\nfunction build(build) {\n  this._build = !!build;\n  return this;\n}\n\nvar textable = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  amove: amove,\n  ax: ax,\n  ay: ay,\n  build: build,\n  center: center,\n  cx: cx,\n  cy: cy,\n  length: length,\n  move: move$1,\n  plain: plain,\n  x: x$1,\n  y: y$1\n});\n\nfunction _callSuper$b(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Text = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Text(node) {\n    var _this$dom$leading;\n    var _this;\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Text);\n    _this = _callSuper$b(this, Text, [nodeOrNew('text', node), attrs]);\n    _this.dom.leading = (_this$dom$leading = _this.dom.leading) !== null && _this$dom$leading !== void 0 ? _this$dom$leading : new SVGNumber(1.3); // store leading value for rebuilding\n    _this._rebuild = true; // enable automatic updating of dy values\n    _this._build = false; // disable build mode for adding multiple lines\n    return _this;\n  }\n\n  // Set / get leading\n  _inherits(Text, _Shape);\n  return _createClass$1(Text, [{\n    key: \"leading\",\n    value: function leading(value) {\n      // act as getter\n      if (value == null) {\n        return this.dom.leading;\n      }\n\n      // act as setter\n      this.dom.leading = new SVGNumber(value);\n      return this.rebuild();\n    }\n\n    // Rebuild appearance type\n  }, {\n    key: \"rebuild\",\n    value: function rebuild(_rebuild) {\n      // store new rebuild flag if given\n      if (typeof _rebuild === 'boolean') {\n        this._rebuild = _rebuild;\n      }\n\n      // define position of all lines\n      if (this._rebuild) {\n        var self = this;\n        var blankLineOffset = 0;\n        var leading = this.dom.leading;\n        this.each(function (i) {\n          if (isDescriptive(this.node)) return;\n          var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n          var dy = leading * new SVGNumber(fontSize);\n          if (this.dom.newLined) {\n            this.attr('x', self.attr('x'));\n            if (this.text() === '\\n') {\n              blankLineOffset += dy;\n            } else {\n              this.attr('dy', i ? dy + blankLineOffset : 0);\n              blankLineOffset = 0;\n            }\n          }\n        });\n        this.fire('rebuild');\n      }\n      return this;\n    }\n\n    // overwrite method from parent to set data properly\n  }, {\n    key: \"setData\",\n    value: function setData(o) {\n      this.dom = o;\n      this.dom.leading = new SVGNumber(o.leading || 1.3);\n      return this;\n    }\n  }, {\n    key: \"writeDataToDom\",\n    value: function writeDataToDom$1() {\n      writeDataToDom(this, this.dom, {\n        leading: 1.3\n      });\n      return this;\n    }\n\n    // Set the text content\n  }, {\n    key: \"text\",\n    value: function text(_text) {\n      // act as getter\n      if (_text === undefined) {\n        var children = this.node.childNodes;\n        var firstLine = 0;\n        _text = '';\n        for (var i = 0, len = children.length; i < len; ++i) {\n          // skip textPaths - they are no lines\n          if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {\n            if (i === 0) firstLine = i + 1;\n            continue;\n          }\n\n          // add newline if its not the first child and newLined is set to true\n          if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {\n            _text += '\\n';\n          }\n\n          // add content of this node\n          _text += children[i].textContent;\n        }\n        return _text;\n      }\n\n      // remove existing content\n      this.clear().build(true);\n      if (typeof _text === 'function') {\n        // call block\n        _text.call(this, this);\n      } else {\n        // store text and make sure text is not blank\n        _text = (_text + '').split('\\n');\n\n        // build new lines\n        for (var j = 0, jl = _text.length; j < jl; j++) {\n          this.newLine(_text[j]);\n        }\n      }\n\n      // disable build mode and rebuild lines\n      return this.build(false).rebuild();\n    }\n  }]);\n}(Shape);\nextend(Text, textable);\nregisterMethods({\n  Container: {\n    // Create text element\n    text: wrapWithAttrCheck(function () {\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return this.put(new Text()).text(text);\n    }),\n    // Create plain text element\n    plain: wrapWithAttrCheck(function () {\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return this.put(new Text()).plain(text);\n    })\n  }\n});\nregister(Text, 'Text');\n\nfunction _callSuper$a(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$a() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Tspan = /*#__PURE__*/function (_Shape) {\n  // Initialize node\n  function Tspan(node) {\n    var _this;\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Tspan);\n    _this = _callSuper$a(this, Tspan, [nodeOrNew('tspan', node), attrs]);\n    _this._build = false; // disable build mode for adding multiple lines\n    return _this;\n  }\n\n  // Shortcut dx\n  _inherits(Tspan, _Shape);\n  return _createClass$1(Tspan, [{\n    key: \"dx\",\n    value: function dx(_dx) {\n      return this.attr('dx', _dx);\n    }\n\n    // Shortcut dy\n  }, {\n    key: \"dy\",\n    value: function dy(_dy) {\n      return this.attr('dy', _dy);\n    }\n\n    // Create new line\n  }, {\n    key: \"newLine\",\n    value: function newLine() {\n      // mark new line\n      this.dom.newLined = true;\n\n      // fetch parent\n      var text = this.parent();\n\n      // early return in case we are not in a text element\n      if (!(text instanceof Text)) {\n        return this;\n      }\n      var i = text.index(this);\n      var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n      var dy = text.dom.leading * new SVGNumber(fontSize);\n\n      // apply new position\n      return this.dy(i ? dy : 0).attr('x', text.x());\n    }\n\n    // Set text content\n  }, {\n    key: \"text\",\n    value: function text(_text) {\n      if (_text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n      if (typeof _text === 'function') {\n        this.clear().build(true);\n        _text.call(this, this);\n        this.build(false);\n      } else {\n        this.plain(_text);\n      }\n      return this;\n    }\n  }]);\n}(Shape);\nextend(Tspan, textable);\nregisterMethods({\n  Tspan: {\n    tspan: wrapWithAttrCheck(function () {\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var tspan = new Tspan();\n\n      // clear if build mode is disabled\n      if (!this._build) {\n        this.clear();\n      }\n\n      // add new tspan\n      return this.put(tspan).text(text);\n    })\n  },\n  Text: {\n    newLine: function newLine() {\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return this.tspan(text).newLine();\n    }\n  }\n});\nregister(Tspan, 'Tspan');\n\nfunction _callSuper$9(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$9() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Circle = /*#__PURE__*/function (_Shape) {\n  function Circle(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Circle);\n    return _callSuper$9(this, Circle, [nodeOrNew('circle', node), attrs]);\n  }\n  _inherits(Circle, _Shape);\n  return _createClass$1(Circle, [{\n    key: \"radius\",\n    value: function radius(r) {\n      return this.attr('r', r);\n    }\n\n    // Radius x value\n  }, {\n    key: \"rx\",\n    value: function rx(_rx) {\n      return this.attr('r', _rx);\n    }\n\n    // Alias radius x value\n  }, {\n    key: \"ry\",\n    value: function ry(_ry) {\n      return this.rx(_ry);\n    }\n  }, {\n    key: \"size\",\n    value: function size(_size) {\n      return this.radius(new SVGNumber(_size).divide(2));\n    }\n  }]);\n}(Shape);\nextend(Circle, {\n  x: x$3,\n  y: y$3,\n  cx: cx$1,\n  cy: cy$1,\n  width: width$2,\n  height: height$2\n});\nregisterMethods({\n  Container: {\n    // Create circle element\n    circle: wrapWithAttrCheck(function () {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.put(new Circle()).size(size).move(0, 0);\n    })\n  }\n});\nregister(Circle, 'Circle');\n\nfunction _callSuper$8(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$8() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar ClipPath = /*#__PURE__*/function (_Container) {\n  function ClipPath(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, ClipPath);\n    return _callSuper$8(this, ClipPath, [nodeOrNew('clipPath', node), attrs]);\n  }\n\n  // Unclip all clipped elements and remove itself\n  _inherits(ClipPath, _Container);\n  return _createClass$1(ClipPath, [{\n    key: \"remove\",\n    value: function remove() {\n      // unclip all targets\n      this.targets().forEach(function (el) {\n        el.unclip();\n      });\n\n      // remove clipPath from parent\n      return _get(_getPrototypeOf(ClipPath.prototype), \"remove\", this).call(this);\n    }\n  }, {\n    key: \"targets\",\n    value: function targets() {\n      return baseFind('svg [clip-path*=' + this.id() + ']');\n    }\n  }]);\n}(Container);\nregisterMethods({\n  Container: {\n    // Create clipping element\n    clip: wrapWithAttrCheck(function () {\n      return this.defs().put(new ClipPath());\n    })\n  },\n  Element: {\n    // Distribute clipPath to svg element\n    clipper: function clipper() {\n      return this.reference('clip-path');\n    },\n    clipWith: function clipWith(element) {\n      // use given clip or create a new one\n      var clipper = element instanceof ClipPath ? element : this.parent().clip().add(element);\n\n      // apply mask\n      return this.attr('clip-path', 'url(#' + clipper.id() + ')');\n    },\n    // Unclip element\n    unclip: function unclip() {\n      return this.attr('clip-path', null);\n    }\n  }\n});\nregister(ClipPath, 'ClipPath');\n\nfunction _callSuper$7(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$7() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar ForeignObject = /*#__PURE__*/function (_Element) {\n  function ForeignObject(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, ForeignObject);\n    return _callSuper$7(this, ForeignObject, [nodeOrNew('foreignObject', node), attrs]);\n  }\n  _inherits(ForeignObject, _Element);\n  return _createClass$1(ForeignObject);\n}(Element);\nregisterMethods({\n  Container: {\n    foreignObject: wrapWithAttrCheck(function (width, height) {\n      return this.put(new ForeignObject()).size(width, height);\n    })\n  }\n});\nregister(ForeignObject, 'ForeignObject');\n\nfunction dmove(dx, dy) {\n  this.children().forEach(function (child) {\n    var bbox;\n\n    // We have to wrap this for elements that dont have a bbox\n    // e.g. title and other descriptive elements\n    try {\n      // Get the childs bbox\n      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039\n      // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs\n      // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).\n      // Funnily enough the broken behavior would work for us but that breaks it in chrome\n      // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself\n      bbox = child.node instanceof getWindow().SVGSVGElement ? new Box(child.attr(['x', 'y', 'width', 'height'])) : child.bbox();\n    } catch (e) {\n      return;\n    }\n\n    // Get childs matrix\n    var m = new Matrix(child);\n    // Translate childs matrix by amount and\n    // transform it back into parents space\n    var matrix = m.translate(dx, dy).transform(m.inverse());\n    // Calculate new x and y from old box\n    var p = new Point(bbox.x, bbox.y).transform(matrix);\n    // Move element\n    child.move(p.x, p.y);\n  });\n  return this;\n}\nfunction dx(dx) {\n  return this.dmove(dx, 0);\n}\nfunction dy(dy) {\n  return this.dmove(0, dy);\n}\nfunction height(height) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (height == null) return box.height;\n  return this.size(box.width, height, box);\n}\nfunction move() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n  var dx = x - box.x;\n  var dy = y - box.y;\n  return this.dmove(dx, dy);\n}\nfunction size(width, height) {\n  var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n  var p = proportionalSize(this, width, height, box);\n  var scaleX = p.width / box.width;\n  var scaleY = p.height / box.height;\n  this.children().forEach(function (child) {\n    var o = new Point(box).transform(new Matrix(child).inverse());\n    child.scale(scaleX, scaleY, o.x, o.y);\n  });\n  return this;\n}\nfunction width(width) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (width == null) return box.width;\n  return this.size(width, box.height, box);\n}\nfunction x(x) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (x == null) return box.x;\n  return this.move(x, box.y, box);\n}\nfunction y(y) {\n  var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n  if (y == null) return box.y;\n  return this.move(box.x, y, box);\n}\n\nvar containerGeometry = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  dmove: dmove,\n  dx: dx,\n  dy: dy,\n  height: height,\n  move: move,\n  size: size,\n  width: width,\n  x: x,\n  y: y\n});\n\nfunction _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar G = /*#__PURE__*/function (_Container) {\n  function G(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, G);\n    return _callSuper$6(this, G, [nodeOrNew('g', node), attrs]);\n  }\n  _inherits(G, _Container);\n  return _createClass$1(G);\n}(Container);\nextend(G, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a group element\n    group: wrapWithAttrCheck(function () {\n      return this.put(new G());\n    })\n  }\n});\nregister(G, 'G');\n\nfunction _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar A = /*#__PURE__*/function (_Container) {\n  function A(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, A);\n    return _callSuper$5(this, A, [nodeOrNew('a', node), attrs]);\n  }\n\n  // Link target attribute\n  _inherits(A, _Container);\n  return _createClass$1(A, [{\n    key: \"target\",\n    value: function target(_target) {\n      return this.attr('target', _target);\n    }\n\n    // Link url\n  }, {\n    key: \"to\",\n    value: function to(url) {\n      return this.attr('href', url, xlink);\n    }\n  }]);\n}(Container);\nextend(A, containerGeometry);\nregisterMethods({\n  Container: {\n    // Create a hyperlink element\n    link: wrapWithAttrCheck(function (url) {\n      return this.put(new A()).to(url);\n    })\n  },\n  Element: {\n    unlink: function unlink() {\n      var link = this.linker();\n      if (!link) return this;\n      var parent = link.parent();\n      if (!parent) {\n        return this.remove();\n      }\n      var index = parent.index(link);\n      parent.add(this, index);\n      link.remove();\n      return this;\n    },\n    linkTo: function linkTo(url) {\n      // reuse old link if possible\n      var link = this.linker();\n      if (!link) {\n        link = new A();\n        this.wrap(link);\n      }\n      if (typeof url === 'function') {\n        url.call(link, link);\n      } else {\n        link.to(url);\n      }\n      return this;\n    },\n    linker: function linker() {\n      var link = this.parent();\n      if (link && link.node.nodeName.toLowerCase() === 'a') {\n        return link;\n      }\n      return null;\n    }\n  }\n});\nregister(A, 'A');\n\nfunction _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Mask = /*#__PURE__*/function (_Container) {\n  // Initialize node\n  function Mask(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Mask);\n    return _callSuper$4(this, Mask, [nodeOrNew('mask', node), attrs]);\n  }\n\n  // Unmask all masked elements and remove itself\n  _inherits(Mask, _Container);\n  return _createClass$1(Mask, [{\n    key: \"remove\",\n    value: function remove() {\n      // unmask all targets\n      this.targets().forEach(function (el) {\n        el.unmask();\n      });\n\n      // remove mask from parent\n      return _get(_getPrototypeOf(Mask.prototype), \"remove\", this).call(this);\n    }\n  }, {\n    key: \"targets\",\n    value: function targets() {\n      return baseFind('svg [mask*=' + this.id() + ']');\n    }\n  }]);\n}(Container);\nregisterMethods({\n  Container: {\n    mask: wrapWithAttrCheck(function () {\n      return this.defs().put(new Mask());\n    })\n  },\n  Element: {\n    // Distribute mask to svg element\n    masker: function masker() {\n      return this.reference('mask');\n    },\n    maskWith: function maskWith(element) {\n      // use given mask or create a new one\n      var masker = element instanceof Mask ? element : this.parent().mask().add(element);\n\n      // apply mask\n      return this.attr('mask', 'url(#' + masker.id() + ')');\n    },\n    // Unmask element\n    unmask: function unmask() {\n      return this.attr('mask', null);\n    }\n  }\n});\nregister(Mask, 'Mask');\n\nfunction _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Stop = /*#__PURE__*/function (_Element) {\n  function Stop(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Stop);\n    return _callSuper$3(this, Stop, [nodeOrNew('stop', node), attrs]);\n  }\n\n  // add color stops\n  _inherits(Stop, _Element);\n  return _createClass$1(Stop, [{\n    key: \"update\",\n    value: function update(o) {\n      if (typeof o === 'number' || o instanceof SVGNumber) {\n        o = {\n          offset: arguments[0],\n          color: arguments[1],\n          opacity: arguments[2]\n        };\n      }\n\n      // set attributes\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n      if (o.color != null) this.attr('stop-color', o.color);\n      if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));\n      return this;\n    }\n  }]);\n}(Element);\nregisterMethods({\n  Gradient: {\n    // Add a color stop\n    stop: function stop(offset, color, opacity) {\n      return this.put(new Stop()).update(offset, color, opacity);\n    }\n  }\n});\nregister(Stop, 'Stop');\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction cssRule(selector, rule) {\n  if (!selector) return '';\n  if (!rule) return selector;\n  var ret = selector + '{';\n  for (var i in rule) {\n    ret += unCamelCase(i) + ':' + rule[i] + ';';\n  }\n  ret += '}';\n  return ret;\n}\nvar Style = /*#__PURE__*/function (_Element) {\n  function Style(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Style);\n    return _callSuper$2(this, Style, [nodeOrNew('style', node), attrs]);\n  }\n  _inherits(Style, _Element);\n  return _createClass$1(Style, [{\n    key: \"addText\",\n    value: function addText() {\n      var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.node.textContent += w;\n      return this;\n    }\n  }, {\n    key: \"font\",\n    value: function font(name, src) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.rule('@font-face', _objectSpread({\n        fontFamily: name,\n        src: src\n      }, params));\n    }\n  }, {\n    key: \"rule\",\n    value: function rule(selector, obj) {\n      return this.addText(cssRule(selector, obj));\n    }\n  }]);\n}(Element);\nregisterMethods('Dom', {\n  style: function style(selector, obj) {\n    return this.put(new Style()).rule(selector, obj);\n  },\n  fontface: function fontface(name, src, params) {\n    return this.put(new Style()).font(name, src, params);\n  }\n});\nregister(Style, 'Style');\n\nfunction _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }\nvar TextPath = /*#__PURE__*/function (_Text) {\n  // Initialize node\n  function TextPath(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, TextPath);\n    return _callSuper$1(this, TextPath, [nodeOrNew('textPath', node), attrs]);\n  }\n\n  // return the array of the path track element\n  _inherits(TextPath, _Text);\n  return _createClass$1(TextPath, [{\n    key: \"array\",\n    value: function array() {\n      var track = this.track();\n      return track ? track.array() : null;\n    }\n\n    // Plot path if any\n  }, {\n    key: \"plot\",\n    value: function plot(d) {\n      var track = this.track();\n      var pathArray = null;\n      if (track) {\n        pathArray = track.plot(d);\n      }\n      return d == null ? pathArray : this;\n    }\n\n    // Get the path element\n  }, {\n    key: \"track\",\n    value: function track() {\n      return this.reference('href');\n    }\n  }]);\n}(Text);\nregisterMethods({\n  Container: {\n    textPath: wrapWithAttrCheck(function (text, path) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = this.text(text);\n      }\n      return text.path(path);\n    })\n  },\n  Text: {\n    // Create path for text to run on\n    path: wrapWithAttrCheck(function (track) {\n      var importNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var textPath = new TextPath();\n\n      // if track is a path, reuse it\n      if (!(track instanceof Path)) {\n        // create path element\n        track = this.defs().path(track);\n      }\n\n      // link textPath to path and add content\n      textPath.attr('href', '#' + track, xlink);\n\n      // Transplant all nodes from text to textPath\n      var node;\n      if (importNodes) {\n        while (node = this.node.firstChild) {\n          textPath.node.appendChild(node);\n        }\n      }\n\n      // add textPath element as child node and return textPath\n      return this.put(textPath);\n    }),\n    // Get the textPath children\n    textPath: function textPath() {\n      return this.findOne('textPath');\n    }\n  },\n  Path: {\n    // creates a textPath from this path\n    text: wrapWithAttrCheck(function (text) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = new Text().addTo(this.parent()).text(text);\n      }\n\n      // Create textPath from text and path and return\n      return text.path(this);\n    }),\n    targets: function targets() {\n      var _this = this;\n      return baseFind('svg textPath').filter(function (node) {\n        return (node.attr('href') || '').includes(_this.id());\n      });\n\n      // Does not work in IE11. Use when IE support is dropped\n      // return baseFind('svg textPath[*|href*=' + this.id() + ']')\n    }\n  }\n});\nTextPath.prototype.MorphArray = PathArray;\nregister(TextPath, 'TextPath');\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nvar Use = /*#__PURE__*/function (_Shape) {\n  function Use(node) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node;\n    _classCallCheck$1(this, Use);\n    return _callSuper(this, Use, [nodeOrNew('use', node), attrs]);\n  }\n\n  // Use element as a reference\n  _inherits(Use, _Shape);\n  return _createClass$1(Use, [{\n    key: \"use\",\n    value: function use(element, file) {\n      // Set lined element\n      return this.attr('href', (file || '') + '#' + element, xlink);\n    }\n  }]);\n}(Shape);\nregisterMethods({\n  Container: {\n    // Create a use element\n    use: wrapWithAttrCheck(function (element, file) {\n      return this.put(new Use()).use(element, file);\n    })\n  }\n});\nregister(Use, 'Use');\n\n/* Optional Modules */\nvar SVG = makeInstance;\nextend([Svg, _Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));\nextend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));\nextend(Text, getMethodsFor('Text'));\nextend(Path, getMethodsFor('Path'));\nextend(Defs, getMethodsFor('Defs'));\nextend([Text, Tspan], getMethodsFor('Tspan'));\nextend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'));\nextend(EventTarget, getMethodsFor('EventTarget'));\nextend(Dom, getMethodsFor('Dom'));\nextend(Element, getMethodsFor('Element'));\nextend(Shape, getMethodsFor('Shape'));\nextend([Container, Fragment], getMethodsFor('Container'));\nextend(Gradient, getMethodsFor('Gradient'));\nextend(Runner, getMethodsFor('Runner'));\nList.extend(getMethodNames());\nregisterMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray, Point]);\nmakeMorphable();\n\nvar FileSaver_min = {exports: {}};\n\n(function (module, exports) {\n  (function (a, b) {\n    b();\n  })(commonjsGlobal, function () {\n\n    function b(a, b) {\n      return \"undefined\" == typeof b ? b = {\n        autoBom: !1\n      } : \"object\" != _typeof$1(b) && (console.warn(\"Deprecated: Expected third argument to be a object\"), b = {\n        autoBom: !b\n      }), b.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type) ? new Blob([\"\\uFEFF\", a], {\n        type: a.type\n      }) : a;\n    }\n    function c(a, b, c) {\n      var d = new XMLHttpRequest();\n      d.open(\"GET\", a), d.responseType = \"blob\", d.onload = function () {\n        g(d.response, b, c);\n      }, d.onerror = function () {\n        console.error(\"could not download file\");\n      }, d.send();\n    }\n    function d(a) {\n      var b = new XMLHttpRequest();\n      b.open(\"HEAD\", a, !1);\n      try {\n        b.send();\n      } catch (a) {}\n      return 200 <= b.status && 299 >= b.status;\n    }\n    function e(a) {\n      try {\n        a.dispatchEvent(new MouseEvent(\"click\"));\n      } catch (c) {\n        var b = document.createEvent(\"MouseEvents\");\n        b.initMouseEvent(\"click\", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);\n      }\n    }\n    var f = \"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof$1(window)) && window.window === window ? window : \"object\" == (typeof self === \"undefined\" ? \"undefined\" : _typeof$1(self)) && self.self === self ? self : \"object\" == _typeof$1(commonjsGlobal) && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0,\n      a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),\n      g = f.saveAs || (\"object\" != (typeof window === \"undefined\" ? \"undefined\" : _typeof$1(window)) || window !== f ? function () {} : \"download\" in HTMLAnchorElement.prototype && !a ? function (b, g, h) {\n        var i = f.URL || f.webkitURL,\n          j = document.createElement(\"a\");\n        g = g || b.name || \"download\", j.download = g, j.rel = \"noopener\", \"string\" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = \"_blank\")) : (j.href = i.createObjectURL(b), setTimeout(function () {\n          i.revokeObjectURL(j.href);\n        }, 4E4), setTimeout(function () {\n          e(j);\n        }, 0));\n      } : \"msSaveOrOpenBlob\" in navigator ? function (f, g, h) {\n        if (g = g || f.name || \"download\", \"string\" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {\n          var i = document.createElement(\"a\");\n          i.href = f, i.target = \"_blank\", setTimeout(function () {\n            e(i);\n          });\n        }\n      } : function (b, d, e, g) {\n        if (g = g || open(\"\", \"_blank\"), g && (g.document.title = g.document.body.innerText = \"downloading...\"), \"string\" == typeof b) return c(b, d, e);\n        var h = \"application/octet-stream\" === b.type,\n          i = /constructor/i.test(f.HTMLElement) || f.safari,\n          j = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n        if ((j || h && i || a) && \"undefined\" != typeof FileReader) {\n          var k = new FileReader();\n          k.onloadend = function () {\n            var a = k.result;\n            a = j ? a : a.replace(/^data:[^;]*;/, \"data:attachment/file;\"), g ? g.location.href = a : location = a, g = null;\n          }, k.readAsDataURL(b);\n        } else {\n          var l = f.URL || f.webkitURL,\n            m = l.createObjectURL(b);\n          g ? g.location = m : location.href = m, g = null, setTimeout(function () {\n            l.revokeObjectURL(m);\n          }, 4E4);\n        }\n      });\n    f.saveAs = g.saveAs = g, (module.exports = g);\n  });\n})(FileSaver_min);\nvar FileSaver_minExports = FileSaver_min.exports;\nvar FileSaver = /*@__PURE__*/getDefaultExportFromCjs(FileSaver_minExports);\n\n/**\n * Formatter which is used for translation.\n * This will be replaced which is used in the runtime.\n * @param {object} messageData - format-message object\n * @returns {string} - message for the locale\n */\nvar formatMessage = function formatMessage(messageData) {\n  return messageData.default;\n};\n\n/**\n * Setup format-message for this extension.\n */\nvar setupTranslations = function setupTranslations() {\n  var localeSetup = formatMessage.setup();\n  if (localeSetup && localeSetup.translations[localeSetup.locale]) {\n    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);\n  }\n};\nvar EXTENSION_ID = 'xcxVPen';\n\n/**\n * URL to get this extension as a module.\n * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.\n * @type {string}\n */\nvar extensionURL = 'https://yokobond.github.io/xcx-vpen/dist/xcxVPen.mjs';\n\n/**\n * Scratch 3.0 blocks for example of Xcratch.\n */\nvar VPenBlocks = /*#__PURE__*/function () {\n  /**\n   * Construct a set of blocks for vector pen.\n   * @param {Runtime} runtime - the Scratch 3.0 runtime.\n   */\n  function VPenBlocks(runtime) {\n    _classCallCheck$1(this, VPenBlocks);\n    /**\n     * The Scratch 3.0 runtime.\n     * @type {Runtime}\n     */\n    this.runtime = runtime;\n    if (runtime.formatMessage) {\n      // Replace 'formatMessage' to a formatter which is used in the runtime.\n      formatMessage = runtime.formatMessage;\n    }\n\n    /**\n     * The pen states for each target.\n     * @type {object.<string, object>}\n     */\n    this._penStates = {};\n    var _this$runtime$rendere = this.runtime.renderer.getNativeSize(),\n      _this$runtime$rendere2 = _slicedToArray(_this$runtime$rendere, 2),\n      stageWidth = _this$runtime$rendere2[0],\n      stageHeight = _this$runtime$rendere2[1];\n    this._updateStageSize(stageWidth, stageHeight);\n\n    /**\n     * The step per mm.\n     * @type {number}\n     */\n    this.stepPerMM = 2; // 180mm for stage height\n\n    // Bind event handlers.\n    this.onTargetMoved = this.onTargetMoved.bind(this);\n\n    // Register block to the runtime.\n    runtime.on('targetWasCreated', this.onTargetCreated.bind(this));\n    runtime.on('targetWasRemoved', this.onTargetWillExit.bind(this));\n    runtime.on('RUNTIME_DISPOSED', this.onRuntimeDisposed.bind(this));\n  }\n\n  /**\n   * Update the stage size.\n   * @param {number} stageWidth - the width of the stage.\n   * @param {number} stageHeight - the height of the stage.\n   */\n  return _createClass$1(VPenBlocks, [{\n    key: \"_updateStageSize\",\n    value: function _updateStageSize(stageWidth, stageHeight) {\n      /**\n       * The width of the stage.\n       * @type {number}\n       */\n      this.stageWidth = stageWidth;\n\n      /**\n       * The height of the stage.\n       * @type {number}\n       */\n      this.stageHeight = stageHeight;\n    }\n\n    /**\n     * Create a new SVG drawing for the pen layer.\n     * @returns {SVG} - the new SVG drawing.\n     */\n  }, {\n    key: \"_createDrawingSVG\",\n    value: function _createDrawingSVG() {\n      var stageWidth = this.stageWidth;\n      var stageHeight = this.stageHeight;\n      var dummy = document.implementation.createHTMLDocument();\n      return SVG().addTo(dummy.body).size(\"\".concat(stageWidth), \"\".concat(stageHeight)).viewbox(0, 0, stageWidth, stageHeight);\n    }\n\n    /**\n     * Retrieve the ID of the renderer \"Skin\" corresponding to the pen layer. If\n     * the pen Skin doesn't yet exist, create it.\n     * @param {Target} target - the target to query.\n     * @returns {int} the Skin ID of the pen layer, or -1 on failure.\n     * @private\n     */\n  }, {\n    key: \"_getSkinIDFor\",\n    value: function _getSkinIDFor(target) {\n      var penState = this._getPenState(target);\n      var renderer = this.runtime.renderer;\n      if (penState.skinID < 0 && renderer) {\n        var drawing = penState.drawing;\n        penState.skinID = this.runtime.renderer.createSVGSkin(this.convertSVGForPenLayer(drawing.svg()));\n        penState.drawableID = this.runtime.renderer.createDrawable(StageLayering$2.PEN_LAYER);\n        renderer.updateDrawableSkinId(penState.drawableID, penState.skinID);\n      }\n      return penState.skinID;\n    }\n\n    /**\n     * Get the state of the pen for the target if it exists.\n     * If the state doesn't exist, return null.\n     * @param {Target} target - the target to query.\n     * @return {object?} - the pen state or null.\n     */\n  }, {\n    key: \"_penStateFor\",\n    value: function _penStateFor(target) {\n      var targetID = target.id;\n      return this._penStates[targetID];\n    }\n\n    /**\n     * Get the state of the pen for the target.\n     * Initializes the pen state if it doesn't exist.\n     * @param {Target} target - the target to query.\n     * @return {object} - the pen state.\n     * @property {int} skinID - the ID of the renderer Skin corresponding to the pen layer.\n     * @property {Path} penPath - the current pen line.\n     * @property {Container} drawing - the container for the pen lines.\n     * @property {object} penAttributes - the pen attributes.\n     * @property {object} penAttributes.color3b - the pen color[RGB 0-255].\n     * @property {number} penAttributes.diameter - the pen diameter[mm].\n     * @property {string} penAttributes.lineShape - the shape of the line.\n     * @property {object} penAttributes.fillColor3b - the fill color[RGB 0-255].\n     * @property {number} penAttributes.fillOpacity - the fill opacity.\n     * @property {object} referencePoint - the reference point for the plotter pen.\n     * @private\n     */\n  }, {\n    key: \"_getPenState\",\n    value: function _getPenState(target) {\n      var penState = this._penStateFor(target);\n      if (!penState) {\n        penState = Clone$2.simple(VPenBlocks.DEFAULT_PEN_STATE);\n        this._penStates[target.id] = penState;\n      }\n      if (!penState.drawing) {\n        penState.drawing = this._createDrawingSVG();\n      }\n      return penState;\n    }\n\n    /**\n     * Clear the pen layer for the target.\n     * @param {Target} target - the target to clear the pen layer for.\n     */\n  }, {\n    key: \"_clearForTarget\",\n    value: function _clearForTarget(target) {\n      var penState = this._penStateFor(target);\n      if (!penState || !penState.drawing) {\n        return;\n      }\n      penState.drawing.remove();\n      penState.drawing = null;\n      if (penState.penPath) {\n        this._startPenPath(target);\n      }\n      this._updatePenSkinFor(target);\n    }\n\n    /**\n     * Update the pen skin for the target.\n     * @param {Target} target - the target to update the pen skin for.\n     */\n  }, {\n    key: \"_updatePenSkinFor\",\n    value: function _updatePenSkinFor(target) {\n      var penSkinId = this._getSkinIDFor(target);\n      if (penSkinId < 0) {\n        throw new Error('No SVG Skin ID');\n      }\n      var penState = this._penStateFor(target);\n      var svg = penState.drawing.root();\n      this.runtime.renderer.updateSVGSkin(penSkinId, this.convertSVGForPenLayer(svg.svg()));\n      this.runtime.requestRedraw();\n    }\n\n    /**\n     * Map the x, y position to the SVG viewBox.\n     * @param {number} x - the x position on the stage.\n     * @param {number} y - the y position on the stage.\n     * @returns {Array.<number>} - the x, y position on the SVG viewBox.\n     */\n  }, {\n    key: \"_mapToSVGViewBox\",\n    value: function _mapToSVGViewBox(x, y) {\n      return [x + this.stageWidth / 2, this.stageHeight / 2 - y];\n    }\n\n    /**\n     * Finish the current pen.\n     * @param {object} penState - the pen state.\n     */\n  }, {\n    key: \"_finishPen\",\n    value: function _finishPen(penState) {\n      if (!penState.penPath) {\n        return;\n      }\n      this._removeReferenceLine(penState);\n      var penPath = penState.penPath;\n      penState.penPath = null;\n      var plots = penPath.array();\n      if (plots.length === 1) {\n        // If the pen line only has one instruction (MoveTo), it hasn't been drawn yet.\n        penPath.remove();\n        return;\n      }\n      if (plots.length === 2) {\n        return;\n      }\n      // Close the path if it's a closed line.\n      var start = plots[1][0] === 'L' ? plots[0] : plots[1];\n      var lastLine = plots[plots.length - 1]; // L or T\n      var closingDistance = 8; // pixels distance for closing the path.\n      if (Math.sqrt(Math.pow(start[1] - lastLine[1], 2) + Math.pow(start[2] - lastLine[2], 2)) > closingDistance) {\n        return;\n      }\n      // It's a closed line.\n      var firstLine = plots[1]; // L or Q\n      if (firstLine[0] === 'Q' && lastLine[0] === 'T') {\n        plots.pop(); // remove T\n        plots.push(_toConsumableArray(plots[1])); // copy the first Q to the end\n        plots[0] = ['M'].concat(_toConsumableArray(plots[1].slice(3))); // move the start to the control point of the first Q\n        plots.splice(1, 1); // remove the first Q\n      }\n      penPath.plot(plots.concat(['Z']));\n    }\n\n    /**\n     * Remove the last reference point for the plotter pen.\n     * @param {object} penState - the pen state.\n     */\n  }, {\n    key: \"_removeReferenceLine\",\n    value: function _removeReferenceLine(penState) {\n      if (!penState.referencePoint) {\n        return;\n      }\n      var penPath = penState.penPath;\n      if (penState.penAttributes.lineShape === VPenBlocks.LINE_SHAPES.CURVE) {\n        penPath.array().pop(); // remove T\n        var referenceCurve = penPath.array().pop(); // Q\n        penPath.array().push(['T', referenceCurve[1], referenceCurve[2]]);\n      } else {\n        // The reference is a straight line.\n        penState.penPath.array().pop();\n      }\n      penPath.plot(penPath.array());\n      penState.referencePoint = null;\n    }\n\n    /**\n     * Start a new pen path for the target.\n     * @param {Target} target - the target to start the pen path for.\n     */\n  }, {\n    key: \"_startPenPath\",\n    value: function _startPenPath(target) {\n      var penState = this._getPenState(target);\n      this._finishPen(penState);\n      var newPath = penState.drawing.path(['M'].concat(_toConsumableArray(this._mapToSVGViewBox(target.x, target.y))));\n      newPath.fill(penState.penAttributes.fillOpacity > 0 ? {\n        color: penState.penAttributes.fillColor3b,\n        opacity: penState.penAttributes.fillOpacity\n      } : 'none').stroke({\n        width: penState.penAttributes.diameter * this.stepPerMM,\n        color: penState.penAttributes.color3b,\n        opacity: penState.penAttributes.opacity,\n        linecap: 'round',\n        linejoin: 'round'\n      });\n      penState.penPath = newPath;\n    }\n\n    /**\n     * Add a line to the pen path for the target.\n     * @param {Path} path - the path to add the line to.\n     * @param {number} x - the x position of the line.\n     * @param {number} y - the y position of the line.\n     */\n  }, {\n    key: \"_addLineToPenPath\",\n    value: function _addLineToPenPath(path, x, y) {\n      path.array().push(['L'].concat(_toConsumableArray(this._mapToSVGViewBox(x, y))));\n      path.plot(path.array());\n    }\n\n    /**\n     * Add a line to the pen path for the target.\n     * @param {Path} path - the path to add the line to.\n     * @param {number} x - the x position of the line.\n     * @param {number} y - the y position of the line.\n     */\n  }, {\n    key: \"_addCurveToPenPath\",\n    value: function _addCurveToPenPath(path, x, y) {\n      var pathArray = path.array();\n      var prevNode = pathArray[pathArray.length - 1]; // T or M or L\n      if (prevNode[0] === 'T') {\n        pathArray.pop();\n      }\n      var prevPoint = [prevNode[1], prevNode[2]];\n      var endPoint = this._mapToSVGViewBox(x, y);\n      var controlPoint = [(prevPoint[0] + endPoint[0]) / 2, (prevPoint[1] + endPoint[1]) / 2];\n      pathArray.push(['Q'].concat(prevPoint, controlPoint));\n      pathArray.push(['T'].concat(_toConsumableArray(endPoint)));\n      path.plot(pathArray);\n    }\n\n    /**\n     * Clamp a pen size value to the range allowed by the pen.\n     * @param {number} requestedSize - the requested pen size.\n     * @returns {number} the clamped size.\n     * @private\n     */\n  }, {\n    key: \"_clampPenSize\",\n    value: function _clampPenSize(requestedSize) {\n      return Math.max(0, requestedSize);\n    }\n\n    /**\n     * Get the SVG for the pen layer.\n     * @param {string} svg - the SVG string.\n     * @returns {string} - the SVG string for the pen layer.\n     */\n  }, {\n    key: \"convertSVGForPenLayer\",\n    value: function convertSVGForPenLayer(svg) {\n      // Ensure that all strokes have a minimum width for visibility.\n      var thinStrokeWidth = VPenBlocks.DISPLAY_STROKE_WIDTH_MIN;\n      return svg.replace(/stroke-width=\"([^\"]+)\"/g, function (match, strokeWidth) {\n        if (parseFloat(strokeWidth) < thinStrokeWidth) {\n          return \"stroke-width=\\\"\".concat(thinStrokeWidth, \"\\\"\");\n        }\n        return match;\n      });\n    }\n\n    /**\n     * Return the step per mm.\n     * @returns {number} - the step per mm.\n     */\n  }, {\n    key: \"getStepPerMM\",\n    value: function getStepPerMM() {\n      return this.stepPerMM;\n    }\n\n    /**\n     * Return the step for the given mm.\n     * @param {object} args - the block arguments.\n     * @param {number} args.MM - the mm.\n     * @returns {number} - the step.\n     */\n  }, {\n    key: \"stepForMM\",\n    value: function stepForMM(args) {\n      return Cast$2.toNumber(args.MM) * this.stepPerMM;\n    }\n\n    /**\n     * Return the mm for the given step.\n     * @param {object} args - the block arguments.\n     * @param {number} args.STEP - the step.\n     * @returns {number} - the mm.\n     */\n  }, {\n    key: \"mmForStep\",\n    value: function mmForStep(args) {\n      return Cast$2.toNumber(args.STEP) / this.stepPerMM;\n    }\n\n    /**\n     * Set the step per mm.\n     * @param {object} args - the block arguments.\n     * @param {number} args.STEP_PER_MM - the step per mm.\n     */\n  }, {\n    key: \"setStepPerMM\",\n    value: function setStepPerMM(args) {\n      this.stepPerMM = Cast$2.toNumber(args.STEP_PER_MM);\n    }\n\n    /**\n     * Clear pen layer for the target.\n     * @param {Target} targetID - the target to clear the pen layer for.\n     */\n  }, {\n    key: \"destroyPenLayerForID\",\n    value: function destroyPenLayerForID(targetID) {\n      var penState = this._penStates[targetID];\n      if (penState) {\n        var target = this.runtime.getTargetById(targetID);\n        if (target && target.isOriginal) {\n          this.runtime.renderer.destroyDrawable(penState.drawableID, StageLayering$2.PEN_LAYER);\n          this.runtime.renderer.destroySkin(penState.skinID);\n        }\n        delete this._penStates[targetID];\n        this.runtime.requestRedraw();\n      }\n    }\n\n    /**\n     * Handle a target which is exiting.\n     * @param {RenderedTarget} target - the target.\n     * @private\n     */\n  }, {\n    key: \"onTargetWillExit\",\n    value: function onTargetWillExit(target) {\n      var penState = this._penStateFor(target);\n      if (penState) {\n        this.penUp({}, {\n          target: target\n        });\n        this.destroyPenLayerForID(target.id);\n      }\n    }\n  }, {\n    key: \"onRuntimeDisposed\",\n    value: function onRuntimeDisposed() {\n      var _this = this;\n      Object.keys(this._penStates).forEach(function (targetID) {\n        _this.destroyPenLayerForID(targetID);\n      });\n    }\n\n    /**\n     * When a pen-using Target is cloned, clone the pen state.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @listens Runtime#event:targetWasCreated\n     * @private\n     */\n  }, {\n    key: \"onTargetCreated\",\n    value: function onTargetCreated(newTarget, sourceTarget) {\n      if (sourceTarget) {\n        var sourcePenState = this._penStateFor(sourceTarget);\n        if (sourcePenState) {\n          var newPenState = VPenBlocks.DEFAULT_PEN_STATE;\n          newPenState.skinID = sourcePenState.skinID;\n          newPenState.drawableID = sourcePenState.drawableID;\n          newPenState.penType = sourcePenState.penType;\n          newPenState.penAttributes = Clone$2.simple(sourcePenState.penAttributes);\n          this._penStates[newTarget.id] = newPenState;\n          newPenState.drawing = sourcePenState.drawing.group();\n        }\n      }\n    }\n\n    /**\n     * Handle a target which has moved. This only fires when the pen is down.\n     * @param {RenderedTarget} target - the target which has moved.\n     * @param {number} oldX - the previous X position.\n     * @param {number} oldY - the previous Y position.\n     * @param {boolean} isForce - whether the movement was forced.\n     * @private\n     */\n  }, {\n    key: \"onTargetMoved\",\n    value: function onTargetMoved(target, oldX, oldY, isForce) {\n      var penState = this._penStateFor(target);\n      var penPath = penState.penPath;\n      if (!penPath) {\n        // If the pen is up, there's nothing to draw.\n        return;\n      }\n      if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {\n        if (isForce) {\n          // Only move the pen if the movement isn't forced (ie. dragged).\n          // This prevents the pen from drawing when the sprite is dragged.\n          this._startPenPath(target);\n          this._updatePenSkinFor(target);\n          return;\n        }\n      }\n      if (penState.penType === VPenBlocks.PEN_TYPES.PLOTTER) {\n        this._removeReferenceLine(penState);\n      }\n      penState.referencePoint = {\n        x: target.x,\n        y: target.y\n      };\n      if (penState.penAttributes.lineShape === VPenBlocks.LINE_SHAPES.CURVE) {\n        this._addCurveToPenPath(penPath, target.x, target.y);\n      } else {\n        this._addLineToPenPath(penPath, target.x, target.y);\n      }\n      this._updatePenSkinFor(target);\n    }\n\n    /**\n     * Plot a node of the path.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"plot\",\n    value: function plot(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      if (penState.penPath) {\n        if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {\n          // Trail pen was down, so nothing to plot.\n          return;\n        }\n      } else {\n        // If there's no line started, start plotter.\n        penState.penType = VPenBlocks.PEN_TYPES.PLOTTER;\n        this._startPenPath(target);\n        this._updatePenSkinFor(target);\n        target.addListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);\n      }\n      // Change the reference point to the drawing position.\n      penState.referencePoint = null;\n    }\n\n    /**\n     * The pen \"pen down\" block causes the target to leave pen trails on future motion.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"penDown\",\n    value: function penDown(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      if (penState.penPath) {\n        if (penState.penType === args.PEN_TYPE) {\n          // If there's already a same type line started, nothing to do.\n          return;\n        }\n        this.penUp(args, util);\n      }\n      penState.penType = args.PEN_TYPE;\n      if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {\n        this._startPenPath(target);\n      }\n      this._updatePenSkinFor(target);\n      target.addListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);\n    }\n\n    /**\n     * The pen \"pen up\" block stops the target from leaving pen trails.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"penUp\",\n    value: function penUp(args, util) {\n      var target = util.target;\n      var penState = this._penStateFor(target);\n      if (!penState || !penState.penPath) {\n        // If there's no line started, there's nothing to end.\n        return;\n      }\n      this._finishPen(penState);\n      this._updatePenSkinFor(target);\n      target.removeListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);\n    }\n\n    /**\n     * Clears the drawings of this target.\n     * @param {object} _args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear(_args, util) {\n      var target = util.target;\n      this._clearForTarget(target);\n    }\n\n    /**\n     * Set the pen color by color tool.\n     * @param {object} args - the block arguments.\n     * @param {string|number} args.COLOR - the color to set the pen to.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenColorToColor\",\n    value: function setPenColorToColor(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var rgba = Cast$2.toRgbColorObject(args.COLOR);\n      var opacity = 1 - (rgba.a ? rgba.a : 0) / 255;\n      if (penState.penAttributes.color3b.r === rgba.r && penState.penAttributes.color3b.g === rgba.g && penState.penAttributes.color3b.b === rgba.b && penState.penAttributes.opacity === opacity) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.color3b = {\n        r: rgba.r,\n        g: rgba.g,\n        b: rgba.b\n      };\n      penState.penAttributes.opacity = opacity;\n      var penPath = penState.penPath;\n      if (penPath) {\n        // If there's a pen line started, end it and start a new one.\n        this._startPenPath(target);\n      }\n    }\n\n    /**\n     * Set the pen opacity.\n     * @param {object} args - the block arguments.\n     * @param {number} args.OPACITY - the opacity of the pen.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenOpacity\",\n    value: function setPenOpacity(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var newOpacity = Math.max(0, Math.min(1, Cast$2.toNumber(args.OPACITY) / 100));\n      if (penState.penAttributes.opacity === newOpacity) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.opacity = newOpacity;\n      var penPath = penState.penPath;\n      if (penPath) {\n        // If there's a pen line started, end it and start a new one.\n        this._startPenPath(target);\n      }\n    }\n\n    /**\n     * Set the pen size (mm).\n     * @param {object} args - the block arguments.\n     * @param {number} args.SIZE - the size of the pen in mm.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setPenSizeTo\",\n    value: function setPenSizeTo(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var newPenSize = this._clampPenSize(Cast$2.toNumber(args.SIZE));\n      if (penState.penAttributes.diameter === newPenSize) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.diameter = newPenSize;\n      var penPath = penState.penPath;\n      if (penPath) {\n        // If there's a pen line started, end it and start a new one.\n        this._startPenPath(target);\n      }\n    }\n\n    /**\n     * Set the line shape.\n     * @param {object} args - the block arguments.\n     * @param {string} args.LINE_SHAPE - the shape of the line.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setLineShape\",\n    value: function setLineShape(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var newLineShape = args.LINE_SHAPE;\n      if (penState.penAttributes.lineShape === newLineShape) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.lineShape = newLineShape;\n    }\n\n    /**\n     * Set fill color of the pen by color tool.\n     * @param {object} args - the block arguments.\n     * @param {string|number} args.COLOR - the color to set.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setFillColorToColor\",\n    value: function setFillColorToColor(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var rgba = Cast$2.toRgbColorObject(args.COLOR);\n      var opacity = 1 - (rgba.a ? rgba.a : 0) / 255;\n      if (penState.penAttributes.fillColor3b.r === rgba.r && penState.penAttributes.fillColor3b.g === rgba.g && penState.penAttributes.fillColor3b.b === rgba.b && penState.penAttributes.fillOpacity === opacity) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.fillColor3b = {\n        r: rgba.r,\n        g: rgba.g,\n        b: rgba.b\n      };\n      penState.penAttributes.fillOpacity = opacity;\n      var penPath = penState.penPath;\n      if (penPath) {\n        penPath.fill(penState.penAttributes.fillOpacity > 0 ? {\n          color: penState.penAttributes.fillColor3b,\n          opacity: penState.penAttributes.fillOpacity\n        } : 'none');\n        this._updatePenSkinFor(target);\n      }\n    }\n\n    /**\n     * Set fill opacity of the pen.\n     * @param {object} args - the block arguments.\n     * @param {number} args.OPACITY - the opacity of the fill color.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"setFillOpacity\",\n    value: function setFillOpacity(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var newOpacity = Math.max(0, Math.min(1, Cast$2.toNumber(args.OPACITY) / 100));\n      if (penState.penAttributes.fillOpacity === newOpacity) {\n        // No change.\n        return;\n      }\n      penState.penAttributes.fillOpacity = newOpacity;\n      var penPath = penState.penPath;\n      if (penPath) {\n        penPath.fill(penState.penAttributes.fillOpacity > 0 ? {\n          color: penState.penAttributes.fillColor3b,\n          opacity: penState.penAttributes.fillOpacity\n        } : 'none');\n        this._updatePenSkinFor(target);\n      }\n    }\n\n    /**\n     * The pen \"stamp\" block stamps the current drawable's image onto the pen layer.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"stamp\",\n    value: function stamp(args, util) {\n      var target = util.target;\n      var drawable = target.drawableID;\n      var drawableData = this.runtime.renderer.extractDrawableScreenSpace(drawable);\n      // Get the dataURL of the drawable\n      var canvas = document.createElement('canvas');\n      canvas.width = drawableData.imageData.width;\n      canvas.height = drawableData.imageData.height;\n      var ctx = canvas.getContext('2d');\n      ctx.putImageData(drawableData.imageData, 0, 0);\n      var drawableURL = canvas.toDataURL();\n      // Stamp the drawable onto the pen layer\n      var penState = this._getPenState(target);\n      var drawing = penState.drawing;\n\n      // Get the actual stage size from the renderer.\n      var canvasWidth = this.runtime.renderer.canvas.clientWidth;\n      var canvasHeight = this.runtime.renderer.canvas.clientHeight;\n      var stageResolution = [canvasWidth / this.stageWidth, canvasHeight / this.stageHeight];\n\n      // Get the costume and its resolution.\n      var costume = target.sprite.costumes[target.currentCostume];\n      var costumeResolution = costume.bitmapResolution || 1; // Default to 1 if resolution isn't specified\n\n      // Stamp the drawable onto the pen layer\n      var stamp = drawing.image(drawableURL);\n\n      // Adjust position and size for stage size change\n      var adjustedX = drawableData.x / stageResolution[0];\n      var adjustedY = drawableData.y / stageResolution[1];\n      var adjustedWidth = drawableData.width / stageResolution[0] / costumeResolution;\n      var adjustedHeight = drawableData.height / stageResolution[1] / costumeResolution;\n      stamp.move(adjustedX, adjustedY);\n      stamp.size(adjustedWidth, adjustedHeight);\n      stamp.opacity((100 - target.effects.ghost) / 100);\n      this._updatePenSkinFor(target);\n    }\n\n    /**\n     * Move drawing to the front layer.\n     * @param {number} drawableID - the drawable to move.\n     */\n  }, {\n    key: \"_moveLayerToFront\",\n    value: function _moveLayerToFront(drawableID) {\n      // RenderWebGL.setDrawableOrder() has a bug which breaks the order of groups when moving drawable up.\n      // So we move the drawable up under the sprite layer.\n      var renderer = this.runtime.renderer;\n      var topOrder = renderer._layerGroups[StageLayering$2.SPRITE_LAYER].drawListOffset - 1;\n      renderer.setDrawableOrder(drawableID, topOrder, StageLayering$2.PEN_LAYER, false);\n    }\n\n    /**\n     * Move drawing to the back layer.\n     * @param {number} drawableID - the drawable to move.\n     */\n  }, {\n    key: \"_moveLayerToBack\",\n    value: function _moveLayerToBack(drawableID) {\n      this.runtime.renderer.setDrawableOrder(drawableID, -Infinity, StageLayering$2.PEN_LAYER, false);\n    }\n\n    /**\n     * Move drawing forward a number of layers.\n     * @param {number} drawableID - the drawable to move.\n     * @param {number} nLayers How many layers to go forward.\n     */\n  }, {\n    key: \"_moveLayerUp\",\n    value: function _moveLayerUp(drawableID, nLayers) {\n      // RenderWebGL.setDrawableOrder() has a bug which breaks the order of groups when moving drawable up.\n      // So we move the drawable up under the sprite layer.\n      var renderer = this.runtime.renderer;\n      var drawableOrder = renderer.getDrawableOrder(drawableID);\n      var topOrder = renderer._layerGroups[StageLayering$2.SPRITE_LAYER].drawListOffset - 1;\n      nLayers = Math.min(nLayers, topOrder - drawableOrder);\n      renderer.setDrawableOrder(drawableID, nLayers, StageLayering$2.PEN_LAYER, true);\n    }\n\n    /**\n     * Move drawing backward a number of layers.\n     * @param {number} drawableID - the drawable to move.\n     * @param {number} nLayers How many layers to go backward.\n     */\n  }, {\n    key: \"_moveLayerDown\",\n    value: function _moveLayerDown(drawableID, nLayers) {\n      this._moveLayerUp(drawableID, -nLayers);\n    }\n\n    /**\n     * Change the layer of the drawing.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {string} args.LAYER - the layer name to change to.\n     */\n  }, {\n    key: \"changeLayerTo\",\n    value: function changeLayerTo(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var layer = args.LAYER;\n      if (layer === VPenBlocks.CHANGE_LAYER.TOP) {\n        this._moveLayerToFront(penState.drawableID);\n      } else if (layer === VPenBlocks.CHANGE_LAYER.BOTTOM) {\n        this._moveLayerToBack(penState.drawableID);\n      }\n      this.runtime.requestRedraw();\n    }\n\n    /**\n     * Move the drawing a number of layers.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @param {number} args.LAYERS - the number of layers to move.\n     * @param {string} args.DIRECTION - the direction to move.\n     */\n  }, {\n    key: \"moveLayerBy\",\n    value: function moveLayerBy(args, util) {\n      var target = util.target;\n      var penState = this._getPenState(target);\n      var layerCount = Cast$2.toNumber(args.LAYERS);\n      if (args.DIRECTION === VPenBlocks.MOVE_LAYER.UP) {\n        this._moveLayerUp(penState.drawableID, layerCount);\n      } else if (args.DIRECTION === VPenBlocks.MOVE_LAYER.DOWN) {\n        this._moveLayerDown(penState.drawableID, layerCount);\n      }\n      this.runtime.requestRedraw();\n    }\n\n    /**\n     * Get the order of the drawing in the all drawable.\n     * @param {object} target - the target to get the order for.\n     * @returns {number} - the order of the drawing.\n     */\n  }, {\n    key: \"_getDrawableOrderFor\",\n    value: function _getDrawableOrderFor(target) {\n      var penState = this._penStates[target.id];\n      if (!penState) {\n        return -1;\n      }\n      var renderer = this.runtime.renderer;\n      return renderer.getDrawableOrder(penState.drawableID);\n    }\n\n    /**\n     * Clears the pen layer's contents.\n     */\n  }, {\n    key: \"clearAll\",\n    value: function clearAll() {\n      var _this2 = this;\n      this.runtime.targets.forEach(function (target) {\n        _this2._clearForTarget(target);\n      });\n    }\n\n    /**\n     * Save the drawing as an SVG file.\n     * @param {SVG} svg - the SVG drawing.\n     * @param {string} fileName - the name of the file to save.\n     * @returns {Promise} - a promise that resolves after the file has been saved.\n     */\n  }, {\n    key: \"_saveSVGAsFile\",\n    value: function _saveSVGAsFile(svg, fileName) {\n      var saveData = svg.size(\"\".concat(this.stageWidth / this.stepPerMM, \"mm\"), \"\".concat(this.stageHeight / this.stepPerMM, \"mm\")).svg();\n      var blob = new Blob([saveData], {\n        type: 'application/octet-stream'\n      });\n      return FileSaver.saveAs(blob, \"\".concat(fileName, \".svg\"));\n    }\n\n    /**\n     * Add the sprite drawing group to the SVG if the sprite has a drawing.\n     * @param {Target} target - the target to add the sprite drawing for.\n     * @param {Container} svgContainer - the SVG container to add the sprite drawing to.\n     * @returns {Container?} - a new group for the sprite drawing or null.\n     */\n  }, {\n    key: \"_addSpriteDrawingTo\",\n    value: function _addSpriteDrawingTo(target, svgContainer) {\n      var penState = this._penStateFor(target);\n      if (!penState || !penState.drawing) {\n        return null;\n      }\n      var drawings = penState.drawing.children();\n      if (drawings.length === 0) {\n        return null;\n      }\n      var spriteGroup = svgContainer.group();\n      spriteGroup.id(target.sprite.name);\n      drawings.forEach(function (child) {\n        spriteGroup.add(child.clone());\n      });\n      return spriteGroup;\n    }\n\n    /**\n     * Save the sprite drawing as an SVG file.\n     * @param {object} args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     * @returns {string} - the result of saving the sprite drawing.\n     */\n  }, {\n    key: \"downloadSpriteDrawing\",\n    value: function downloadSpriteDrawing(args, util) {\n      var target = util.target;\n      var fileName = Cast$2.toString(args.FILENAME);\n      var penState = this._penStateFor(target);\n      if (!penState || !penState.drawing) {\n        return 'no drawing';\n      }\n      // eslint-disable-next-line no-alert\n      if (fileName === null || fileName === '') {\n        fileName = target.sprite.name;\n      }\n      var saveSVG = this._createDrawingSVG();\n      this._addSpriteDrawingTo(target, saveSVG);\n      return this._saveSVGAsFile(saveSVG, fileName);\n    }\n\n    /**\n     * Save the SVG drawing.\n     * @param {object} args - the block arguments.\n     * @param {string} args.NAME - the name of the file to save.\n     * @param {object} util - utility object provided by the runtime.\n     * @returns {string} - the result of saving the SVG drawing.\n     */\n  }, {\n    key: \"downloadAllDrawing\",\n    value: function downloadAllDrawing(args, util) {\n      var _this3 = this;\n      // eslint-disable-next-line no-alert\n      var fileName = Cast$2.toString(args.FILENAME);\n      if (fileName === null || fileName === '') {\n        fileName = 'vpen';\n      }\n      var saveSVG = this._createDrawingSVG();\n      var saveTargets = util.runtime.targets.filter(function (target) {\n        return target.isSprite();\n      }).sort(function (a, b) {\n        return _this3._getDrawableOrderFor(a) - _this3._getDrawableOrderFor(b);\n      });\n      if (saveTargets.length === 0) {\n        return 'no drawing';\n      }\n      saveTargets.forEach(function (target) {\n        _this3._addSpriteDrawingTo(target, saveSVG);\n      });\n      if (saveSVG.children().length === 0) {\n        return 'no drawing';\n      }\n      return this._saveSVGAsFile(saveSVG, fileName);\n    }\n\n    /**\n     * Remove the last drawing of the sprite.\n     * @param {object} _args - the block arguments.\n     * @param {object} util - utility object provided by the runtime.\n     */\n  }, {\n    key: \"eraseLast\",\n    value: function eraseLast(_args, util) {\n      var target = util.target;\n      var penState = this._penStateFor(target);\n      if (penState && penState.drawing) {\n        var drawings = penState.drawing.children();\n        if (drawings.length > 0) {\n          drawings[drawings.length - 1].remove();\n          this._updatePenSkinFor(target);\n        }\n      }\n    }\n\n    /**\n     * @returns {object} metadata for this extension and its blocks.\n     */\n  }, {\n    key: \"getInfo\",\n    value: function getInfo() {\n      setupTranslations();\n      return {\n        id: VPenBlocks.EXTENSION_ID,\n        name: VPenBlocks.EXTENSION_NAME,\n        extensionURL: VPenBlocks.extensionURL,\n        blockIconURI: img,\n        showStatusButton: false,\n        blocks: [{\n          opcode: 'clearAll',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.clearAll',\n            default: 'erase all drawings',\n            description: 'erase all pen trails and stamps'\n          })\n        }, {\n          opcode: 'clear',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.clear',\n            default: 'erase drawings of this sprite',\n            description: 'clear the pen trails of the sprite'\n          }),\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'eraseLast',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.eraseLast',\n            default: 'erase last drawing',\n            description: 'remove the last drawing of the sprite'\n          }),\n          filter: [TargetType$1.SPRITE]\n        }, '---', {\n          opcode: 'stamp',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'pen.stamp',\n            default: 'stamp',\n            description: 'stamp a copy of the sprite'\n          }),\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'penDown',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.penDown',\n            default: '[PEN_TYPE] pen down',\n            description: 'start leaving a trail when the sprite moves'\n          }),\n          arguments: {\n            PEN_TYPE: {\n              type: ArgumentType$1.STRING,\n              menu: 'penTypesMenu'\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'penUp',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'pen.penUp',\n            default: 'pen up',\n            description: 'stop leaving a trail behind the sprite'\n          }),\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'plot',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.plot',\n            default: 'plot',\n            description: 'plot a node of the path'\n          }),\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setPenColorToColor',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'pen.setColor',\n            default: 'set pen color to [COLOR]',\n            description: 'set the pen color'\n          }),\n          arguments: {\n            COLOR: {\n              type: ArgumentType$1.COLOR\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setPenOpacity',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setPenOpacity',\n            default: 'set pen opacity to [OPACITY]',\n            description: 'set the vpen opacity'\n          }),\n          arguments: {\n            OPACITY: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 100\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setPenSizeTo',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setSize',\n            default: 'set pen size to [SIZE] mm',\n            description: 'set the diameter of a trail left by a sprite'\n          }),\n          arguments: {\n            SIZE: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 1\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setLineShape',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setLineShape',\n            default: 'set line shape to [LINE_SHAPE]',\n            description: 'set the shape of a line'\n          }),\n          arguments: {\n            LINE_SHAPE: {\n              type: ArgumentType$1.STRING,\n              menu: 'lineShapesMenu'\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setFillColorToColor',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setFillColorToColor',\n            default: 'set fill color to [COLOR]',\n            description: 'set fill color of the pen'\n          }),\n          arguments: {\n            COLOR: {\n              type: ArgumentType$1.COLOR\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'setFillOpacity',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setFillOpacity',\n            default: 'set fill opacity to [OPACITY]',\n            description: 'set fill opacity of the pen'\n          }),\n          arguments: {\n            OPACITY: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 100\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'changeLayerTo',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.changeLayerTo',\n            default: 'change layer to [LAYER]',\n            description: 'change the layer of the pen'\n          }),\n          arguments: {\n            LAYER: {\n              type: ArgumentType$1.STRING,\n              menu: 'changeLayerMenu'\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, {\n          opcode: 'moveLayerBy',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.moveLayerBy',\n            default: 'move [DIRECTION] [LAYERS] layers',\n            description: 'move the layer of the pen'\n          }),\n          arguments: {\n            DIRECTION: {\n              type: ArgumentType$1.STRING,\n              menu: 'moveLayerDirectionMenu'\n            },\n            LAYERS: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 1\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }, '---', {\n          opcode: 'stepForMM',\n          blockType: BlockType$1.REPORTER,\n          text: formatMessage({\n            id: 'xcxVPen.stepForMM',\n            default: 'steps for [MM] mm',\n            description: 'convert millimeters to steps'\n          }),\n          arguments: {\n            MM: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 10\n            }\n          }\n        }, {\n          opcode: 'mmForStep',\n          blockType: BlockType$1.REPORTER,\n          text: formatMessage({\n            id: 'xcxVPen.mmForStep',\n            default: 'mm for [STEP] steps',\n            description: 'convert steps to millimeters'\n          }),\n          arguments: {\n            STEP: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 100\n            }\n          }\n        }, {\n          opcode: 'getStepPerMM',\n          blockType: BlockType$1.REPORTER,\n          text: formatMessage({\n            id: 'xcxVPen.getStepPerMM',\n            default: 'step/mm',\n            description: 'step per mm'\n          })\n        }, {\n          opcode: 'setStepPerMM',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.setStepPerMM',\n            default: 'set step/mm to [STEP_PER_MM]',\n            description: 'set step per mm'\n          }),\n          arguments: {\n            STEP_PER_MM: {\n              type: ArgumentType$1.NUMBER,\n              defaultValue: 2\n            }\n          }\n        }, {\n          opcode: 'downloadAllDrawing',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.downloadAllDrawing',\n            default: 'download all drawings named [FILENAME]',\n            description: 'download the SVG of all sprites'\n          }),\n          arguments: {\n            FILENAME: {\n              type: ArgumentType$1.STRING,\n              defaultValue: 'vpen'\n            }\n          }\n        }, {\n          opcode: 'downloadSpriteDrawing',\n          blockType: BlockType$1.COMMAND,\n          text: formatMessage({\n            id: 'xcxVPen.downloadSpriteDrawing',\n            default: 'download drawing by the sprite named [FILENAME]',\n            description: 'download SVG of the sprite'\n          }),\n          arguments: {\n            FILENAME: {\n              type: ArgumentType$1.STRING,\n              defaultValue: 'sprite'\n            }\n          },\n          filter: [TargetType$1.SPRITE]\n        }],\n        menus: {\n          penTypesMenu: {\n            acceptReporters: false,\n            items: 'getPenTypesMenuItems'\n          },\n          lineShapesMenu: {\n            acceptReporters: false,\n            items: 'getLineShapesMenuItems'\n          },\n          changeLayerMenu: {\n            acceptReporters: false,\n            items: 'getChangeLayerMenuItems'\n          },\n          moveLayerDirectionMenu: {\n            acceptReporters: false,\n            items: 'getMoveLayerDirectionMenuItems'\n          }\n        }\n      };\n    }\n  }, {\n    key: \"getPenTypesMenuItems\",\n    value: function getPenTypesMenuItems() {\n      return [{\n        text: formatMessage({\n          id: 'xcxVPen.penTypesMenu.trail',\n          default: 'trail',\n          description: 'pen type'\n        }),\n        value: VPenBlocks.PEN_TYPES.TRAIL\n      }, {\n        text: formatMessage({\n          id: 'xcxVPen.penTypesMenu.plotter',\n          default: 'plotter',\n          description: 'plotter pen type'\n        }),\n        value: VPenBlocks.PEN_TYPES.PLOTTER\n      }];\n    }\n  }, {\n    key: \"getLineShapesMenuItems\",\n    value: function getLineShapesMenuItems() {\n      return [{\n        text: formatMessage({\n          id: 'xcxVPen.lineShapesMenu.straight',\n          default: 'straight',\n          description: 'line shape'\n        }),\n        value: VPenBlocks.LINE_SHAPES.STRAIGHT\n      }, {\n        text: formatMessage({\n          id: 'xcxVPen.lineShapesMenu.curve',\n          default: 'curve',\n          description: 'curve line shape'\n        }),\n        value: VPenBlocks.LINE_SHAPES.CURVE\n      }];\n    }\n  }, {\n    key: \"getChangeLayerMenuItems\",\n    value: function getChangeLayerMenuItems() {\n      return [{\n        text: formatMessage({\n          id: 'xcxVPen.changeLayerMenu.top',\n          default: 'top',\n          description: 'change pen layer to top'\n        }),\n        value: VPenBlocks.CHANGE_LAYER.TOP\n      }, {\n        text: formatMessage({\n          id: 'xcxVPen.changeLayerMenu.bottom',\n          default: 'bottom',\n          description: 'change pen layer to bottom'\n        }),\n        value: VPenBlocks.CHANGE_LAYER.BOTTOM\n      }];\n    }\n  }, {\n    key: \"getMoveLayerDirectionMenuItems\",\n    value: function getMoveLayerDirectionMenuItems() {\n      return [{\n        text: formatMessage({\n          id: 'xcxVPen.moveLayerDirectionMenu.up',\n          default: 'up',\n          description: 'move pen layer up'\n        }),\n        value: VPenBlocks.MOVE_LAYER.UP\n      }, {\n        text: formatMessage({\n          id: 'xcxVPen.moveLayerDirectionMenu.down',\n          default: 'down',\n          description: 'move pen layer down'\n        }),\n        value: VPenBlocks.MOVE_LAYER.DOWN\n      }];\n    }\n  }], [{\n    key: \"formatMessage\",\n    set:\n    /**\n     * A translation object which is used in this class.\n     * @param {FormatObject} formatter - translation object\n     */\n    function set(formatter) {\n      formatMessage = formatter;\n      if (formatMessage) setupTranslations();\n    }\n\n    /**\n     * @return {string} - the name of this extension.\n     */\n  }, {\n    key: \"EXTENSION_NAME\",\n    get: function get() {\n      return formatMessage({\n        id: 'xcxVPen.name',\n        default: 'Vector Pen',\n        description: 'name of the extension'\n      });\n    }\n\n    /**\n     * @return {string} - the ID of this extension.\n     */\n  }, {\n    key: \"EXTENSION_ID\",\n    get: function get() {\n      return EXTENSION_ID;\n    }\n\n    /**\n     * URL to get this extension.\n     * @type {string}\n     */\n  }, {\n    key: \"extensionURL\",\n    get: function get() {\n      return extensionURL;\n    }\n\n    /**\n     * Set URL to get this extension.\n     * The extensionURL will be changed to the URL of the loading server.\n     * @param {string} url - URL\n     */,\n    set: function set(url) {\n      extensionURL = url;\n    }\n\n    /**\n     * The minimum stroke width for display purposes.\n     * @type {number}\n     */\n  }, {\n    key: \"DISPLAY_STROKE_WIDTH_MIN\",\n    get: function get() {\n      return 0.1;\n    }\n\n    /**\n     * The types of pen.\n     * @type {object}\n     * @property {string} TRAIL - trail pen.\n     * @property {string} PLOTTER - plotter pen.\n     */\n  }, {\n    key: \"PEN_TYPES\",\n    get: function get() {\n      return {\n        TRAIL: 'trail',\n        PLOTTER: 'plotter'\n      };\n    }\n\n    /**\n     * The types of line shapes.\n     * @type {object}\n     * @property {string} STRAIGHT - straight line.\n     * @property {string} CURVE - curve line.\n     */\n  }, {\n    key: \"LINE_SHAPES\",\n    get: function get() {\n      return {\n        STRAIGHT: 'straight',\n        CURVE: 'curve'\n      };\n    }\n\n    /**\n     * The name of layers.\n     * @type {object}\n     * @property {string} TOP - the top layer.\n     * @property {string} BOTTOM - the bottom layer.\n     */\n  }, {\n    key: \"CHANGE_LAYER\",\n    get: function get() {\n      return {\n        TOP: 'top',\n        BOTTOM: 'bottom'\n      };\n    }\n\n    /**\n     * The directions to move the pen layer.\n     * @type {object}\n     * @property {string} UP - move the pen layer up.\n     * @property {string} DOWN - move the pen layer down.\n     */\n  }, {\n    key: \"MOVE_LAYER\",\n    get: function get() {\n      return {\n        UP: 'up',\n        DOWN: 'down'\n      };\n    }\n\n    /**\n     * The default state of the vector pen.\n     * @type {object}\n     * @property {int} skinID - the ID of the renderer Skin corresponding to the pen layer.\n     * @property {int} drawableID - the ID of the renderer Drawable corresponding to the pen layer.\n     * @property {Path} penPath - the current pen line.\n     * @property {Container} drawing - the container for the pen lines.\n     * @property {object} penAttributes - the pen attributes.\n     * @property {object} penAttributes.color3b - the pen color[RGB 0-255].\n     * @property {number} penAttributes.diameter - the pen diameter[mm].\n     * @property {string} penAttributes.lineShape - the shape of the line.\n     * @property {object} penAttributes.fillColor3b - the fill color[RGB 0-255].\n     * @property {number} penAttributes.fillOpacity - the fill opacity.\n     * @property {object} referencePoint - the reference point for the plotter pen.\n     */\n  }, {\n    key: \"DEFAULT_PEN_STATE\",\n    get: function get() {\n      return {\n        skinID: -1,\n        drawableID: -1,\n        penType: VPenBlocks.PEN_TYPES.TRAIL,\n        penPath: null,\n        drawing: null,\n        penAttributes: {\n          color3b: {\n            r: 0,\n            g: 0,\n            b: 0\n          },\n          // RGB 0-255,\n          opacity: 1,\n          // 0.0-1.0\n          diameter: 1,\n          // mm\n          lineShape: VPenBlocks.LINE_SHAPES.STRAIGHT,\n          fillColor3b: {\n            r: 0,\n            g: 0,\n            b: 0\n          },\n          // RGB 0-255,\n          fillOpacity: 0 // 0.0-1.0\n        },\n        referencePoint: null\n      };\n    }\n  }]);\n}();\n\nexport { VPenBlocks as blockClass, entry };\n//# sourceMappingURL=xcxVPen.mjs.map\n"],"names":[],"sourceRoot":""}